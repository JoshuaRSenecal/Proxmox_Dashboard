#!/bin/bash
# install-proxmox-temp-api.sh
# Run this on EACH Proxmox node

set -e

echo "=== Installing Proxmox Temperature API ==="
echo ""

# 1. Create temperature reader script
echo "[1/5] Creating temperature reader script..."

cat > /usr/local/bin/proxmox-temp-reader.py << 'PYTHON_READER'
#!/usr/bin/env python3
"""
Robust CPU Temperature Reader with Dynamic Cache
"""
import os
import glob
import json
import sys
import time

class CPUTemperatureReader:
    CPU_SENSOR_NAMES = ['coretemp', 'k10temp', 'zenpower', 'cpu_thermal', 'acpitz']
    CPU_TEMP_PATTERNS = ['temp1_input', 'temp2_input', 'temp_input', 'package_temp']
    
    def __init__(self, cache_timeout=None):
        self.hwmon_base = '/sys/class/hwmon'
        self.cache_file = '/var/cache/proxmox-temp-sensor.cache'
        self.cache_valid_seconds = cache_timeout if cache_timeout else 30
    
    def find_cpu_sensor(self):
        cached = self._load_cache()
        if cached and self._verify_sensor_exists(cached):
            return cached
        return self._scan_for_cpu_sensor()
    
    def _scan_for_cpu_sensor(self):
        hwmon_devices = sorted(glob.glob(f'{self.hwmon_base}/hwmon*'))
        
        for hwmon_path in hwmon_devices:
            name_file = os.path.join(hwmon_path, 'name')
            if not os.path.exists(name_file):
                continue
            
            try:
                with open(name_file, 'r') as f:
                    sensor_name = f.read().strip()
                
                if sensor_name in self.CPU_SENSOR_NAMES:
                    temp_file = self._find_temp_input(hwmon_path)
                    if temp_file:
                        result = (hwmon_path, sensor_name, temp_file)
                        self._save_cache(result)
                        return result
            except (IOError, OSError):
                continue
        
        return (None, None, None)
    
    def _find_temp_input(self, hwmon_path):
        for pattern in self.CPU_TEMP_PATTERNS:
            temp_path = os.path.join(hwmon_path, pattern)
            if os.path.exists(temp_path):
                try:
                    with open(temp_path, 'r') as f:
                        value = int(f.read().strip())
                        if 0 < value < 150000:
                            return pattern
                except (IOError, ValueError):
                    continue
        return None
    
    def _verify_sensor_exists(self, cached_sensor):
        hwmon_path, sensor_name, temp_file = cached_sensor
        try:
            if not os.path.exists(hwmon_path):
                return False
            
            name_file = os.path.join(hwmon_path, 'name')
            with open(name_file, 'r') as f:
                current_name = f.read().strip()
            
            if current_name != sensor_name:
                return False
            
            temp_path = os.path.join(hwmon_path, temp_file)
            if not os.path.exists(temp_path):
                return False
            
            with open(temp_path, 'r') as f:
                value = int(f.read().strip())
                if not (0 < value < 150000):
                    return False
            
            return True
        except (IOError, ValueError, OSError):
            return False
    
    def _load_cache(self):
        try:
            if not os.path.exists(self.cache_file):
                return None
            
            cache_age = time.time() - os.path.getmtime(self.cache_file)
            if cache_age > self.cache_valid_seconds:
                return None
            
            with open(self.cache_file, 'r') as f:
                data = json.load(f)
                return (data['path'], data['name'], data['file'])
        except (IOError, json.JSONDecodeError, KeyError):
            return None
    
    def _save_cache(self, sensor_info):
        hwmon_path, sensor_name, temp_file = sensor_info
        try:
            os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)
            with open(self.cache_file, 'w') as f:
                json.dump({
                    'path': hwmon_path,
                    'name': sensor_name,
                    'file': temp_file,
                    'cached_at': time.time(),
                    'cache_timeout': self.cache_valid_seconds
                }, f)
            os.chmod(self.cache_file, 0o644)
        except (IOError, OSError):
            pass
    
    def read_temperature(self):
        hwmon_path, sensor_name, temp_file = self.find_cpu_sensor()
        
        if not hwmon_path:
            return {
                'temperature': None,
                'source': 'none',
                'status': 'no_sensor_found',
                'cache_timeout': self.cache_valid_seconds
            }
        
        try:
            temp_path = os.path.join(hwmon_path, temp_file)
            with open(temp_path, 'r') as f:
                temp_raw = int(f.read().strip())
            
            temp_celsius = round(temp_raw / 1000.0, 1)
            hwmon_num = os.path.basename(hwmon_path)
            
            return {
                'temperature': temp_celsius,
                'source': sensor_name,
                'hwmon': hwmon_num,
                'file': temp_file,
                'status': 'ok',
                'cache_timeout': self.cache_valid_seconds
            }
        except (IOError, ValueError, OSError) as e:
            return {
                'temperature': None,
                'source': sensor_name,
                'status': f'read_error: {str(e)}',
                'cache_timeout': self.cache_valid_seconds
            }

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Read CPU temperature')
    parser.add_argument('--json', action='store_true', help='Output JSON')
    parser.add_argument('--cache', type=int, metavar='SECONDS', help='Cache timeout')
    args = parser.parse_args()
    
    reader = CPUTemperatureReader(cache_timeout=args.cache)
    result = reader.read_temperature()
    
    if args.json:
        print(json.dumps(result))
    else:
        if result['status'] == 'ok':
            print(f"{result['temperature']}C ({result['source']} @ {result['hwmon']}/{result['file']}) [cache: {result['cache_timeout']}s]")
        else:
            print(f"Error: {result['status']}")
            sys.exit(1)

if __name__ == '__main__':
    main()
PYTHON_READER

chmod +x /usr/local/bin/proxmox-temp-reader.py

# 2. Create HTTP service
echo "[2/5] Creating HTTP service..."

cat > /usr/local/bin/proxmox-temp-service.py << 'PYTHON_SERVICE'
#!/usr/bin/env python3
"""
Proxmox Temperature HTTP Service
"""
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import json
import sys
import os

sys.path.insert(0, '/usr/local/bin')
from proxmox_temp_reader import CPUTemperatureReader

class TemperatureHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed_url = urlparse(self.path)
        query_params = parse_qs(parsed_url.query)
        
        if parsed_url.path == '/temperature':
            try:
                cache_timeout = None
                if 'cache' in query_params:
                    try:
                        cache_timeout = int(query_params['cache'][0])
                        cache_timeout = max(1, min(300, cache_timeout))
                    except (ValueError, IndexError):
                        pass
                
                reader = CPUTemperatureReader(cache_timeout=cache_timeout)
                result = reader.read_temperature()
                
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Access-Control-Allow-Origin', '*')
                self.send_header('Cache-Control', f'max-age={result.get("cache_timeout", 30)}')
                self.end_headers()
                
                self.wfile.write(json.dumps(result).encode())
            
            except Exception as e:
                self.send_response(500)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                
                error_response = {
                    'temperature': None,
                    'source': 'none',
                    'status': f'error: {str(e)}'
                }
                self.wfile.write(json.dumps(error_response).encode())
        
        elif parsed_url.path == '/health':
            self.send_response(200)
            self.send_header('Content-Type', 'text/plain')
            self.end_headers()
            self.wfile.write(b'OK')
        
        else:
            self.send_response(404)
            self.end_headers()
    
    def log_message(self, format, *args):
        pass

def main():
    server = HTTPServer(('127.0.0.1', 8899), TemperatureHandler)
    print("Proxmox Temperature API listening on localhost:8899")
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        server.shutdown()

if __name__ == '__main__':
    main()
PYTHON_SERVICE

chmod +x /usr/local/bin/proxmox-temp-service.py

# 3. Test the temperature reader
echo "[3/5] Testing temperature reader..."
if /usr/local/bin/proxmox-temp-reader.py; then
    echo "  Temperature reader: OK"
else
    echo "  WARNING: Temperature reader failed - check your hardware"
fi

# 4. Create systemd service
echo "[4/5] Creating systemd service..."

cat > /etc/systemd/system/proxmox-temp-api.service << 'SYSTEMD_UNIT'
[Unit]
Description=Proxmox Temperature API Service
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/python3 /usr/local/bin/proxmox-temp-service.py
Restart=always
RestartSec=10
User=root
StandardOutput=journal
StandardError=journal
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/cache

[Install]
WantedBy=multi-user.target
SYSTEMD_UNIT

systemctl daemon-reload
systemctl enable proxmox-temp-api.service
systemctl start proxmox-temp-api.service

# 5. Test HTTP service
echo "[5/5] Testing HTTP service..."
sleep 2
if curl -s http://localhost:8899/temperature | grep -q "temperature"; then
    echo "  HTTP service: OK"
else
    echo "  WARNING: HTTP service test failed"
    systemctl status proxmox-temp-api.service
fi

# 6. Optional: Integrate with Proxmox API
echo ""
read -p "Integrate with Proxmox API (allows dashboard to use standard API)? [y/N] " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo "Configuring Apache proxy..."
    
    cat > /etc/apache2/conf-available/proxmox-temp-api.conf << 'APACHE_CONF'
# Custom Temperature API Endpoint
<Location /api2/json/nodes/*/temperature>
    ProxyPass http://127.0.0.1:8899/temperature
    ProxyPassReverse http://127.0.0.1:8899/temperature
    AuthType PVE
    Require valid-user
</Location>
APACHE_CONF
    
    a2enmod proxy_http 2>/dev/null || true
    a2enconf proxmox-temp-api
    systemctl reload apache2
    
    echo "  Apache integration: OK"
fi

echo ""
echo "=== Installation Complete! ==="
echo ""
echo "Test commands:"
echo "  Direct:  curl http://localhost:8899/temperature"
echo "  Health:  curl http://localhost:8899/health"
if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo "  Via API: pvesh get /nodes/\$(hostname)/temperature"
fi
echo ""
echo "Service management:"
echo "  Status:  systemctl status proxmox-temp-api"
echo "  Logs:    journalctl -u proxmox-temp-api -f"
echo ""
