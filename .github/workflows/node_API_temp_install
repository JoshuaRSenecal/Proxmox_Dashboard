#!/bin/bash
# install-proxmox-temp-api.sh
# Proxmox Temperature API Installation
# Run this on EACH Proxmox node
#
# This installs a temperature service on port 8899:
#   GET http://{node-ip}:8899/temperature

set -e

echo "========================================================"
echo "Proxmox Temperature API Installation"
echo "========================================================"
echo ""
echo "This script will install a temperature service"
echo "accessible directly on port 8899:"
echo ""
echo "  GET http://{node-ip}:8899/temperature"
echo ""
echo "Components installed:"
echo "  1. Temperature reader (Python script)"
echo "  2. HTTP service (port 8899)"
echo "  3. Systemd service (auto-start)"
echo ""
read -p "Continue installation? [y/N] " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Installation cancelled."
    exit 0
fi

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    echo "ERROR: Please run as root"
    exit 1
fi

# Check if this is a Proxmox system
if [ ! -f /etc/pve/.version ]; then
    echo "ERROR: This doesn't appear to be a Proxmox VE system"
    exit 1
fi

echo ""
echo "========================================================"
echo "Step 1/4: Installing Temperature Reader"
echo "========================================================"

cat > /usr/local/bin/proxmox-temp-reader.py << 'PYTHON_READER_EOF'
#!/usr/bin/env python3
"""
Robust CPU Temperature Reader with Dynamic Cache
Handles hwmon device renumbering and multiple CPU sensor types
"""
import os
import glob
import json
import sys
import time

class CPUTemperatureReader:
    # Priority order for CPU sensors
    CPU_SENSOR_NAMES = [
        'coretemp',     # Intel CPUs
        'k10temp',      # AMD Ryzen/EPYC
        'zenpower',     # AMD Zen (alternative driver)
        'cpu_thermal',  # ARM CPUs
        'acpitz',       # ACPI thermal zone (fallback)
    ]
    
    # Patterns to identify CPU temp inputs
    CPU_TEMP_PATTERNS = [
        'temp1_input',
        'temp2_input',
        'temp_input',
        'package_temp',
    ]
    
    def __init__(self, cache_timeout=None):
        self.hwmon_base = '/sys/class/hwmon'
        self.cache_file = '/var/cache/proxmox-temp/sensor.cache'
        self.cache_valid_seconds = cache_timeout if cache_timeout else 30
    
    def find_cpu_sensor(self):
        """Dynamically find CPU temperature sensor"""
        cached = self._load_cache()
        if cached and self._verify_sensor_exists(cached):
            return cached
        return self._scan_for_cpu_sensor()
    
    def _scan_for_cpu_sensor(self):
        """Scan hwmon devices for CPU sensor"""
        hwmon_devices = sorted(glob.glob(f'{self.hwmon_base}/hwmon*'))
        
        for hwmon_path in hwmon_devices:
            name_file = os.path.join(hwmon_path, 'name')
            if not os.path.exists(name_file):
                continue
            
            try:
                with open(name_file, 'r') as f:
                    sensor_name = f.read().strip()
                
                if sensor_name in self.CPU_SENSOR_NAMES:
                    temp_file = self._find_temp_input(hwmon_path)
                    if temp_file:
                        result = (hwmon_path, sensor_name, temp_file)
                        self._save_cache(result)
                        return result
            except (IOError, OSError):
                continue
        
        return (None, None, None)
    
    def _find_temp_input(self, hwmon_path):
        """Find the correct temperature input file"""
        for pattern in self.CPU_TEMP_PATTERNS:
            temp_path = os.path.join(hwmon_path, pattern)
            if os.path.exists(temp_path):
                try:
                    with open(temp_path, 'r') as f:
                        value = int(f.read().strip())
                        if 0 < value < 150000:
                            return pattern
                except (IOError, ValueError):
                    continue
        return None
    
    def _verify_sensor_exists(self, cached_sensor):
        """Verify cached sensor still exists and works"""
        hwmon_path, sensor_name, temp_file = cached_sensor
        try:
            if not os.path.exists(hwmon_path):
                return False
            
            name_file = os.path.join(hwmon_path, 'name')
            with open(name_file, 'r') as f:
                current_name = f.read().strip()
            
            if current_name != sensor_name:
                return False
            
            temp_path = os.path.join(hwmon_path, temp_file)
            if not os.path.exists(temp_path):
                return False
            
            with open(temp_path, 'r') as f:
                value = int(f.read().strip())
                if not (0 < value < 150000):
                    return False
            
            return True
        except (IOError, ValueError, OSError):
            return False
    
    def _load_cache(self):
        """Load cached sensor location"""
        try:
            if not os.path.exists(self.cache_file):
                return None
            
            cache_age = time.time() - os.path.getmtime(self.cache_file)
            if cache_age > self.cache_valid_seconds:
                return None
            
            with open(self.cache_file, 'r') as f:
                data = json.load(f)
                return (data['path'], data['name'], data['file'])
        except (IOError, json.JSONDecodeError, KeyError):
            return None
    
    def _save_cache(self, sensor_info):
        """Cache sensor location for faster subsequent reads"""
        hwmon_path, sensor_name, temp_file = sensor_info
        try:
            os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)
            with open(self.cache_file, 'w') as f:
                json.dump({
                    'path': hwmon_path,
                    'name': sensor_name,
                    'file': temp_file,
                    'cached_at': time.time(),
                    'cache_timeout': self.cache_valid_seconds
                }, f)
            os.chmod(self.cache_file, 0o644)
        except (IOError, OSError):
            pass
    
    def read_temperature(self):
        """Read CPU temperature"""
        hwmon_path, sensor_name, temp_file = self.find_cpu_sensor()
        
        if not hwmon_path:
            return {
                'temperature': None,
                'source': 'none',
                'status': 'no_sensor_found',
                'cache_timeout': self.cache_valid_seconds
            }
        
        try:
            temp_path = os.path.join(hwmon_path, temp_file)
            with open(temp_path, 'r') as f:
                temp_raw = int(f.read().strip())
            
            temp_celsius = round(temp_raw / 1000.0, 1)
            hwmon_num = os.path.basename(hwmon_path)
            
            return {
                'temperature': temp_celsius,
                'source': sensor_name,
                'hwmon': hwmon_num,
                'file': temp_file,
                'status': 'ok',
                'cache_timeout': self.cache_valid_seconds
            }
        except (IOError, ValueError, OSError) as e:
            return {
                'temperature': None,
                'source': sensor_name,
                'status': f'read_error: {str(e)}',
                'cache_timeout': self.cache_valid_seconds
            }

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Read CPU temperature')
    parser.add_argument('--json', action='store_true', help='Output JSON')
    parser.add_argument('--cache', type=int, metavar='SECONDS', help='Cache timeout')
    args = parser.parse_args()
    
    reader = CPUTemperatureReader(cache_timeout=args.cache)
    result = reader.read_temperature()
    
    if args.json:
        print(json.dumps(result))
    else:
        if result['status'] == 'ok':
            print(f"{result['temperature']}C ({result['source']} @ {result['hwmon']}/{result['file']})")
        else:
            print(f"Error: {result['status']}")
            sys.exit(1)

if __name__ == '__main__':
    main()
PYTHON_READER_EOF

chmod +x /usr/local/bin/proxmox-temp-reader.py
echo "  Installed: /usr/local/bin/proxmox-temp-reader.py"

# Test the reader
echo ""
echo "  Testing temperature reader..."
if /usr/local/bin/proxmox-temp-reader.py; then
    echo "  Status: OK"
else
    echo "  WARNING: No temperature sensors detected"
    echo "  Temperature monitoring may not work on this system"
fi

echo ""
echo "========================================================"
echo "Step 2/4: Installing HTTP Service"
echo "========================================================"

cat > /usr/local/bin/proxmox-temp-service.py << 'PYTHON_SERVICE_EOF'
#!/usr/bin/env python3
"""
Proxmox Temperature HTTP Service
Provides temperature data via HTTP on port 8899
Accessed directly by the Proxmox Dashboard
"""
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import json
import sys
import os
import glob
import time

class CPUTemperatureReader:
    """CPU Temperature Reader"""
    CPU_SENSOR_NAMES = ['coretemp', 'k10temp', 'zenpower', 'cpu_thermal', 'acpitz']
    CPU_TEMP_PATTERNS = ['temp1_input', 'temp2_input', 'temp_input', 'package_temp']
    
    def __init__(self, cache_timeout=None):
        self.hwmon_base = '/sys/class/hwmon'
        self.cache_file = '/var/cache/proxmox-temp/sensor.cache'
        self.cache_valid_seconds = cache_timeout if cache_timeout else 30
    
    def find_cpu_sensor(self):
        cached = self._load_cache()
        if cached and self._verify_sensor_exists(cached):
            return cached
        return self._scan_for_cpu_sensor()
    
    def _scan_for_cpu_sensor(self):
        hwmon_devices = sorted(glob.glob(f'{self.hwmon_base}/hwmon*'))
        for hwmon_path in hwmon_devices:
            name_file = os.path.join(hwmon_path, 'name')
            if not os.path.exists(name_file):
                continue
            try:
                with open(name_file, 'r') as f:
                    sensor_name = f.read().strip()
                if sensor_name in self.CPU_SENSOR_NAMES:
                    temp_file = self._find_temp_input(hwmon_path)
                    if temp_file:
                        result = (hwmon_path, sensor_name, temp_file)
                        self._save_cache(result)
                        return result
            except (IOError, OSError):
                continue
        return (None, None, None)
    
    def _find_temp_input(self, hwmon_path):
        for pattern in self.CPU_TEMP_PATTERNS:
            temp_path = os.path.join(hwmon_path, pattern)
            if os.path.exists(temp_path):
                try:
                    with open(temp_path, 'r') as f:
                        value = int(f.read().strip())
                        if 0 < value < 150000:
                            return pattern
                except (IOError, ValueError):
                    continue
        return None
    
    def _verify_sensor_exists(self, cached_sensor):
        hwmon_path, sensor_name, temp_file = cached_sensor
        try:
            if not os.path.exists(hwmon_path):
                return False
            name_file = os.path.join(hwmon_path, 'name')
            with open(name_file, 'r') as f:
                current_name = f.read().strip()
            if current_name != sensor_name:
                return False
            temp_path = os.path.join(hwmon_path, temp_file)
            if not os.path.exists(temp_path):
                return False
            with open(temp_path, 'r') as f:
                value = int(f.read().strip())
                if not (0 < value < 150000):
                    return False
            return True
        except (IOError, ValueError, OSError):
            return False
    
    def _load_cache(self):
        try:
            if not os.path.exists(self.cache_file):
                return None
            cache_age = time.time() - os.path.getmtime(self.cache_file)
            if cache_age > self.cache_valid_seconds:
                return None
            with open(self.cache_file, 'r') as f:
                data = json.load(f)
                return (data['path'], data['name'], data['file'])
        except (IOError, json.JSONDecodeError, KeyError):
            return None
    
    def _save_cache(self, sensor_info):
        hwmon_path, sensor_name, temp_file = sensor_info
        try:
            os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)
            with open(self.cache_file, 'w') as f:
                json.dump({
                    'path': hwmon_path,
                    'name': sensor_name,
                    'file': temp_file,
                    'cached_at': time.time(),
                    'cache_timeout': self.cache_valid_seconds
                }, f)
            os.chmod(self.cache_file, 0o644)
        except (IOError, OSError):
            pass
    
    def read_temperature(self):
        hwmon_path, sensor_name, temp_file = self.find_cpu_sensor()
        if not hwmon_path:
            return {
                'temperature': None,
                'source': 'none',
                'status': 'no_sensor_found',
                'cache_timeout': self.cache_valid_seconds
            }
        try:
            temp_path = os.path.join(hwmon_path, temp_file)
            with open(temp_path, 'r') as f:
                temp_raw = int(f.read().strip())
            temp_celsius = round(temp_raw / 1000.0, 1)
            hwmon_num = os.path.basename(hwmon_path)
            return {
                'temperature': temp_celsius,
                'source': sensor_name,
                'hwmon': hwmon_num,
                'file': temp_file,
                'status': 'ok',
                'cache_timeout': self.cache_valid_seconds
            }
        except (IOError, ValueError, OSError) as e:
            return {
                'temperature': None,
                'source': sensor_name,
                'status': f'read_error: {str(e)}',
                'cache_timeout': self.cache_valid_seconds
            }

class TemperatureHandler(BaseHTTPRequestHandler):
    """HTTP Request Handler"""
    
    def do_GET(self):
        parsed_url = urlparse(self.path)
        query_params = parse_qs(parsed_url.query)
        
        if parsed_url.path == '/temperature':
            try:
                cache_timeout = None
                if 'cache' in query_params:
                    try:
                        cache_timeout = int(query_params['cache'][0])
                        cache_timeout = max(1, min(300, cache_timeout))
                    except (ValueError, IndexError):
                        pass
                
                reader = CPUTemperatureReader(cache_timeout=cache_timeout)
                result = reader.read_temperature()
                
                # Wrap in 'data' to match Proxmox API format
                response = {'data': result}
                
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Cache-Control', f'max-age={result.get("cache_timeout", 30)}')
                self.end_headers()
                self.wfile.write(json.dumps(response).encode())
            
            except Exception as e:
                self.send_response(500)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                error_response = {'data': {'temperature': None, 'status': f'error: {str(e)}'}}
                self.wfile.write(json.dumps(error_response).encode())
        
        elif parsed_url.path == '/health':
            self.send_response(200)
            self.send_header('Content-Type', 'text/plain')
            self.end_headers()
            self.wfile.write(b'OK')
        
        else:
            self.send_response(404)
            self.end_headers()
    
    def log_message(self, format, *args):
        pass  # Suppress access logs

def main():
    server = HTTPServer(('0.0.0.0', 8899), TemperatureHandler)
    print("Proxmox Temperature Service listening on 0.0.0.0:8899")
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        server.shutdown()

if __name__ == '__main__':
    main()
PYTHON_SERVICE_EOF

chmod +x /usr/local/bin/proxmox-temp-service.py
echo "  Created: /usr/local/bin/proxmox-temp-service.py"

echo ""
echo "========================================================"
echo "Step 3/4: Creating Service User and Systemd Service"
echo "========================================================"

# Create unprivileged user for the service
if ! id "proxmox-temp" &>/dev/null; then
    useradd --system --no-create-home --shell /usr/sbin/nologin proxmox-temp
    echo "  Created user: proxmox-temp"
else
    echo "  User proxmox-temp already exists"
fi

# Create cache directory with proper permissions
mkdir -p /var/cache/proxmox-temp
chown proxmox-temp:proxmox-temp /var/cache/proxmox-temp
chmod 755 /var/cache/proxmox-temp
echo "  Created cache directory: /var/cache/proxmox-temp"

cat > /etc/systemd/system/proxmox-temp-api.service << 'SYSTEMD_EOF'
[Unit]
Description=Proxmox Temperature API Service
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/python3 /usr/local/bin/proxmox-temp-service.py
Restart=always
RestartSec=10

# Run as unprivileged user
User=proxmox-temp
Group=proxmox-temp

# Logging
StandardOutput=journal
StandardError=journal

# Security hardening
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/cache/proxmox-temp
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true
RestrictRealtime=true
RestrictSUIDSGID=true

[Install]
WantedBy=multi-user.target
SYSTEMD_EOF

echo "  Created: /etc/systemd/system/proxmox-temp-api.service"

systemctl daemon-reload
systemctl enable proxmox-temp-api.service
systemctl start proxmox-temp-api.service

echo "  Service enabled and started"

echo ""
echo "========================================================"
echo "Step 4/4: Testing Installation"
echo "========================================================"

sleep 2

# Test the service
echo ""
echo "  Testing temperature service (port 8899)..."
if curl -s http://localhost:8899/health > /dev/null 2>&1; then
    echo "    Health check: OK"
    TEMP_RESULT=$(curl -s http://localhost:8899/temperature)
    TEMP_VALUE=$(echo "$TEMP_RESULT" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('data',{}).get('temperature','N/A'))" 2>/dev/null || echo "N/A")
    echo "    Temperature: ${TEMP_VALUE}Â°C"
else
    echo "    WARNING: Service not responding"
    systemctl status proxmox-temp-api.service --no-pager
fi

echo ""
echo "========================================================"
echo "Installation Complete!"
echo "========================================================"
echo ""
NODE_IP=$(hostname -I | awk '{print $1}')
NODE_NAME=$(hostname)
echo "The temperature service is now available at:"
echo "  http://${NODE_IP}:8899/temperature"
echo ""
echo "Test with curl:"
echo "  curl http://${NODE_IP}:8899/temperature"
echo ""
echo "Response format:"
echo "  {\"data\":{\"temperature\":45.0,\"source\":\"coretemp\",\"status\":\"ok\"}}"
echo ""
echo "Service management:"
echo "  systemctl status proxmox-temp-api"
echo "  systemctl restart proxmox-temp-api"
echo "  journalctl -u proxmox-temp-api -f"
echo ""
echo "Files installed:"
echo "  /usr/local/bin/proxmox-temp-reader.py"
echo "  /usr/local/bin/proxmox-temp-service.py"
echo "  /etc/systemd/system/proxmox-temp-api.service"
echo ""
echo "These files survive Proxmox updates!"
echo ""
echo "========================================================"
echo "FIREWALL NOTE"
echo "========================================================"
echo ""
echo "If you have a firewall, allow port 8899 from your dashboard:"
echo "  iptables -I INPUT -p tcp --dport 8899 -s YOUR_LAPTOP_IP -j ACCEPT"
echo ""
echo "========================================================"
echo "UNINSTALL"
echo "========================================================"
echo ""
echo "To remove this installation, run:"
echo "  systemctl stop proxmox-temp-api"
echo "  systemctl disable proxmox-temp-api"
echo "  rm /etc/systemd/system/proxmox-temp-api.service"
echo "  rm /usr/local/bin/proxmox-temp-reader.py"
echo "  rm /usr/local/bin/proxmox-temp-service.py"
echo "  rm -rf /var/cache/proxmox-temp"
echo "  userdel proxmox-temp"
echo "  systemctl daemon-reload"
echo ""
echo "========================================================"
echo "NEXT: Install this script on ALL other Proxmox nodes"
echo "========================================================"
echo ""
