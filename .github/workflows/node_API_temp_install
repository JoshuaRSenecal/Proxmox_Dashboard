#!/bin/bash
# install-proxmox-temp-api-with-firewall.sh
# Proxmox Temperature API Installation with Optional Firewall Security
# Run this on EACH Proxmox node
#
# This installs a temperature service on port 8899:
#   GET http://{node-ip}:8899/temperature

set -e

# Parse command line arguments
SKIP_FIREWALL=false
FIREWALL_IP=""
AUTO_FIREWALL=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --skip-firewall)
            SKIP_FIREWALL=true
            shift
            ;;
        --firewall-ip)
            FIREWALL_IP="$2"
            AUTO_FIREWALL=true
            shift 2
            ;;
        --help)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --skip-firewall          Skip firewall configuration"
            echo "  --firewall-ip IP         Auto-configure firewall for specified IP"
            echo "  --help                   Show this help message"
            echo ""
            echo "Examples:"
            echo "  $0                                    # Interactive mode"
            echo "  $0 --skip-firewall                    # Install without firewall"
            echo "  $0 --firewall-ip 192.168.1.50         # Auto-configure for IP"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

echo "========================================================"
echo "Proxmox Temperature API Installation"
echo "========================================================"
echo ""
echo "This script will install a temperature service"
echo "accessible directly on port 8899:"
echo ""
echo "  GET http://{node-ip}:8899/temperature"
echo ""
echo "Components installed:"
echo "  1. Temperature reader (Python script)"
echo "  2. HTTP service (port 8899)"
echo "  3. Systemd service (auto-start)"
if [ "$SKIP_FIREWALL" = false ]; then
    echo "  4. Firewall configuration (optional)"
fi
echo ""
read -p "Continue installation? [y/N] " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Installation cancelled."
    exit 0
fi

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    echo "ERROR: Please run as root"
    exit 1
fi

# Check if this is a Proxmox system
if [ ! -f /etc/pve/.version ]; then
    echo "ERROR: This doesn't appear to be a Proxmox VE system"
    exit 1
fi

echo ""
echo "========================================================"
echo "Step 1/4: Installing Temperature Reader"
echo "========================================================"

cat > /usr/local/bin/proxmox-temp-reader.py << 'PYTHON_READER_EOF'
#!/usr/bin/env python3
"""
Robust CPU Temperature Reader with Dynamic Cache
Handles hwmon device renumbering and multiple CPU sensor types
"""
import os
import glob
import json
import sys
import time

class CPUTemperatureReader:
    # Priority order for CPU sensors
    CPU_SENSOR_NAMES = [
        'coretemp',     # Intel CPUs
        'k10temp',      # AMD Ryzen/EPYC
        'zenpower',     # AMD Zen (alternative driver)
        'cpu_thermal',  # ARM CPUs
        'acpitz',       # ACPI thermal zone (fallback)
    ]
    
    # Patterns to identify CPU temp inputs
    CPU_TEMP_PATTERNS = [
        'temp1_input',
        'temp2_input',
        'temp_input',
        'package_temp',
    ]
    
    def __init__(self, cache_timeout=None):
        self.hwmon_base = '/sys/class/hwmon'
        self.cache_file = '/var/cache/proxmox-temp/sensor.cache'
        self.cache_valid_seconds = cache_timeout if cache_timeout else 30
    
    def find_cpu_sensor(self):
        """Dynamically find CPU temperature sensor"""
        cached = self._load_cache()
        if cached and self._verify_sensor_exists(cached):
            return cached
        return self._scan_for_cpu_sensor()
    
    def _scan_for_cpu_sensor(self):
        """Scan hwmon devices for CPU sensor"""
        hwmon_devices = sorted(glob.glob(f'{self.hwmon_base}/hwmon*'))
        
        for hwmon_path in hwmon_devices:
            name_file = os.path.join(hwmon_path, 'name')
            if not os.path.exists(name_file):
                continue
            
            try:
                with open(name_file, 'r') as f:
                    sensor_name = f.read().strip()
                
                if sensor_name in self.CPU_SENSOR_NAMES:
                    temp_file = self._find_temp_input(hwmon_path)
                    if temp_file:
                        result = (hwmon_path, sensor_name, temp_file)
                        self._save_cache(result)
                        return result
            except (IOError, OSError):
                continue
        
        return (None, None, None)
    
    def _find_temp_input(self, hwmon_path):
        """Find the correct temperature input file"""
        for pattern in self.CPU_TEMP_PATTERNS:
            temp_path = os.path.join(hwmon_path, pattern)
            if os.path.exists(temp_path):
                try:
                    with open(temp_path, 'r') as f:
                        value = int(f.read().strip())
                        if 0 < value < 150000:
                            return pattern
                except (IOError, ValueError):
                    continue
        return None
    
    def _verify_sensor_exists(self, cached_sensor):
        """Verify cached sensor still exists and works"""
        hwmon_path, sensor_name, temp_file = cached_sensor
        try:
            if not os.path.exists(hwmon_path):
                return False
            
            name_file = os.path.join(hwmon_path, 'name')
            with open(name_file, 'r') as f:
                current_name = f.read().strip()
            
            if current_name != sensor_name:
                return False
            
            temp_path = os.path.join(hwmon_path, temp_file)
            if not os.path.exists(temp_path):
                return False
            
            with open(temp_path, 'r') as f:
                value = int(f.read().strip())
                if not (0 < value < 150000):
                    return False
            
            return True
        except (IOError, ValueError, OSError):
            return False
    
    def _load_cache(self):
        """Load cached sensor location"""
        try:
            if not os.path.exists(self.cache_file):
                return None
            
            cache_age = time.time() - os.path.getmtime(self.cache_file)
            if cache_age > self.cache_valid_seconds:
                return None
            
            with open(self.cache_file, 'r') as f:
                data = json.load(f)
                return (data['path'], data['name'], data['file'])
        except (IOError, json.JSONDecodeError, KeyError):
            return None
    
    def _save_cache(self, sensor_info):
        """Cache sensor location for faster subsequent reads"""
        hwmon_path, sensor_name, temp_file = sensor_info
        try:
            os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)
            with open(self.cache_file, 'w') as f:
                json.dump({
                    'path': hwmon_path,
                    'name': sensor_name,
                    'file': temp_file,
                    'cached_at': time.time(),
                    'cache_timeout': self.cache_valid_seconds
                }, f)
            os.chmod(self.cache_file, 0o644)
        except (IOError, OSError):
            pass
    
    def read_temperature(self):
        """Read CPU temperature"""
        hwmon_path, sensor_name, temp_file = self.find_cpu_sensor()
        
        if not hwmon_path:
            return {
                'temperature': None,
                'source': 'none',
                'status': 'no_sensor_found',
                'cache_timeout': self.cache_valid_seconds
            }
        
        try:
            temp_path = os.path.join(hwmon_path, temp_file)
            with open(temp_path, 'r') as f:
                temp_raw = int(f.read().strip())
            
            temp_celsius = round(temp_raw / 1000.0, 1)
            hwmon_num = os.path.basename(hwmon_path)
            
            return {
                'temperature': temp_celsius,
                'source': sensor_name,
                'hwmon': hwmon_num,
                'file': temp_file,
                'status': 'ok',
                'cache_timeout': self.cache_valid_seconds
            }
        except (IOError, ValueError, OSError) as e:
            return {
                'temperature': None,
                'source': sensor_name,
                'status': f'read_error: {str(e)}',
                'cache_timeout': self.cache_valid_seconds
            }

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Read CPU temperature')
    parser.add_argument('--json', action='store_true', help='Output JSON')
    parser.add_argument('--cache', type=int, metavar='SECONDS', help='Cache timeout')
    args = parser.parse_args()
    
    reader = CPUTemperatureReader(cache_timeout=args.cache)
    result = reader.read_temperature()
    
    if args.json:
        print(json.dumps(result))
    else:
        if result['status'] == 'ok':
            print(f"{result['temperature']}C ({result['source']} @ {result['hwmon']}/{result['file']})")
        else:
            print(f"Error: {result['status']}")
            sys.exit(1)

if __name__ == '__main__':
    main()
PYTHON_READER_EOF

chmod +x /usr/local/bin/proxmox-temp-reader.py
echo "  Installed: /usr/local/bin/proxmox-temp-reader.py"

# Test the reader
echo ""
echo "  Testing temperature reader..."
if /usr/local/bin/proxmox-temp-reader.py; then
    echo "  Status: OK"
else
    echo "  WARNING: No temperature sensors detected"
    echo "  Temperature monitoring may not work on this system"
fi

echo ""
echo "========================================================"
echo "Step 2/4: Installing HTTP Service"
echo "========================================================"

cat > /usr/local/bin/proxmox-temp-service.py << 'PYTHON_SERVICE_EOF'
#!/usr/bin/env python3
"""
Proxmox Temperature HTTP Service
Provides temperature data via HTTP on port 8899
Accessed directly by the Proxmox Dashboard
"""
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import json
import sys
import os
import glob
import time

class CPUTemperatureReader:
    """CPU Temperature Reader"""
    CPU_SENSOR_NAMES = ['coretemp', 'k10temp', 'zenpower', 'cpu_thermal', 'acpitz']
    CPU_TEMP_PATTERNS = ['temp1_input', 'temp2_input', 'temp_input', 'package_temp']
    
    def __init__(self, cache_timeout=None):
        self.hwmon_base = '/sys/class/hwmon'
        self.cache_file = '/var/cache/proxmox-temp/sensor.cache'
        self.cache_valid_seconds = cache_timeout if cache_timeout else 30
    
    def find_cpu_sensor(self):
        cached = self._load_cache()
        if cached and self._verify_sensor_exists(cached):
            return cached
        return self._scan_for_cpu_sensor()
    
    def _scan_for_cpu_sensor(self):
        hwmon_devices = sorted(glob.glob(f'{self.hwmon_base}/hwmon*'))
        for hwmon_path in hwmon_devices:
            name_file = os.path.join(hwmon_path, 'name')
            if not os.path.exists(name_file):
                continue
            try:
                with open(name_file, 'r') as f:
                    sensor_name = f.read().strip()
                if sensor_name in self.CPU_SENSOR_NAMES:
                    temp_file = self._find_temp_input(hwmon_path)
                    if temp_file:
                        result = (hwmon_path, sensor_name, temp_file)
                        self._save_cache(result)
                        return result
            except (IOError, OSError):
                continue
        return (None, None, None)
    
    def _find_temp_input(self, hwmon_path):
        for pattern in self.CPU_TEMP_PATTERNS:
            temp_path = os.path.join(hwmon_path, pattern)
            if os.path.exists(temp_path):
                try:
                    with open(temp_path, 'r') as f:
                        value = int(f.read().strip())
                        if 0 < value < 150000:
                            return pattern
                except (IOError, ValueError):
                    continue
        return None
    
    def _verify_sensor_exists(self, cached_sensor):
        hwmon_path, sensor_name, temp_file = cached_sensor
        try:
            if not os.path.exists(hwmon_path):
                return False
            name_file = os.path.join(hwmon_path, 'name')
            with open(name_file, 'r') as f:
                current_name = f.read().strip()
            if current_name != sensor_name:
                return False
            temp_path = os.path.join(hwmon_path, temp_file)
            if not os.path.exists(temp_path):
                return False
            with open(temp_path, 'r') as f:
                value = int(f.read().strip())
                if not (0 < value < 150000):
                    return False
            return True
        except (IOError, ValueError, OSError):
            return False
    
    def _load_cache(self):
        try:
            if not os.path.exists(self.cache_file):
                return None
            cache_age = time.time() - os.path.getmtime(self.cache_file)
            if cache_age > self.cache_valid_seconds:
                return None
            with open(self.cache_file, 'r') as f:
                data = json.load(f)
                return (data['path'], data['name'], data['file'])
        except (IOError, json.JSONDecodeError, KeyError):
            return None
    
    def _save_cache(self, sensor_info):
        hwmon_path, sensor_name, temp_file = sensor_info
        try:
            os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)
            with open(self.cache_file, 'w') as f:
                json.dump({
                    'path': hwmon_path,
                    'name': sensor_name,
                    'file': temp_file,
                    'cached_at': time.time(),
                    'cache_timeout': self.cache_valid_seconds
                }, f)
            os.chmod(self.cache_file, 0o644)
        except (IOError, OSError):
            pass
    
    def read_temperature(self):
        hwmon_path, sensor_name, temp_file = self.find_cpu_sensor()
        if not hwmon_path:
            return {
                'temperature': None,
                'source': 'none',
                'status': 'no_sensor_found',
                'cache_timeout': self.cache_valid_seconds
            }
        try:
            temp_path = os.path.join(hwmon_path, temp_file)
            with open(temp_path, 'r') as f:
                temp_raw = int(f.read().strip())
            temp_celsius = round(temp_raw / 1000.0, 1)
            hwmon_num = os.path.basename(hwmon_path)
            return {
                'temperature': temp_celsius,
                'source': sensor_name,
                'hwmon': hwmon_num,
                'file': temp_file,
                'status': 'ok',
                'cache_timeout': self.cache_valid_seconds
            }
        except (IOError, ValueError, OSError) as e:
            return {
                'temperature': None,
                'source': sensor_name,
                'status': f'read_error: {str(e)}',
                'cache_timeout': self.cache_valid_seconds
            }

class TemperatureHandler(BaseHTTPRequestHandler):
    """HTTP Request Handler"""
    
    def do_GET(self):
        parsed_url = urlparse(self.path)
        query_params = parse_qs(parsed_url.query)
        
        if parsed_url.path == '/temperature':
            try:
                cache_timeout = None
                if 'cache' in query_params:
                    try:
                        cache_timeout = int(query_params['cache'][0])
                        cache_timeout = max(1, min(300, cache_timeout))
                    except (ValueError, IndexError):
                        pass
                
                reader = CPUTemperatureReader(cache_timeout=cache_timeout)
                result = reader.read_temperature()
                
                # Wrap in 'data' to match Proxmox API format
                response = {'data': result}
                
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Cache-Control', f'max-age={result.get("cache_timeout", 30)}')
                self.end_headers()
                self.wfile.write(json.dumps(response).encode())
            
            except Exception as e:
                self.send_response(500)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                error_response = {'data': {'temperature': None, 'status': f'error: {str(e)}'}}
                self.wfile.write(json.dumps(error_response).encode())
        
        elif parsed_url.path == '/health':
            self.send_response(200)
            self.send_header('Content-Type', 'text/plain')
            self.end_headers()
            self.wfile.write(b'OK')
        
        else:
            self.send_response(404)
            self.end_headers()
    
    def log_message(self, format, *args):
        pass  # Suppress access logs

def main():
    server = HTTPServer(('0.0.0.0', 8899), TemperatureHandler)
    print("Proxmox Temperature Service listening on 0.0.0.0:8899")
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        server.shutdown()

if __name__ == '__main__':
    main()
PYTHON_SERVICE_EOF

chmod +x /usr/local/bin/proxmox-temp-service.py
echo "  Created: /usr/local/bin/proxmox-temp-service.py"

echo ""
echo "========================================================"
echo "Step 3/4: Creating Service User and Systemd Service"
echo "========================================================"

# Create unprivileged user for the service
if ! id "proxmox-temp" &>/dev/null; then
    useradd --system --no-create-home --shell /usr/sbin/nologin proxmox-temp
    echo "  Created user: proxmox-temp"
else
    echo "  User proxmox-temp already exists"
fi

# Create cache directory with proper permissions
mkdir -p /var/cache/proxmox-temp
chown proxmox-temp:proxmox-temp /var/cache/proxmox-temp
chmod 755 /var/cache/proxmox-temp
echo "  Created cache directory: /var/cache/proxmox-temp"

cat > /etc/systemd/system/proxmox-temp-api.service << 'SYSTEMD_EOF'
[Unit]
Description=Proxmox Temperature API Service
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/python3 /usr/local/bin/proxmox-temp-service.py
Restart=always
RestartSec=10

# Run as unprivileged user
User=proxmox-temp
Group=proxmox-temp

# Logging
StandardOutput=journal
StandardError=journal

# Security hardening
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/cache/proxmox-temp
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true
RestrictRealtime=true
RestrictSUIDSGID=true

[Install]
WantedBy=multi-user.target
SYSTEMD_EOF

echo "  Created: /etc/systemd/system/proxmox-temp-api.service"

systemctl daemon-reload
systemctl enable proxmox-temp-api.service
systemctl start proxmox-temp-api.service

echo "  Service enabled and started"

echo ""
echo "========================================================"
echo "Step 4/4: Testing Installation"
echo "========================================================"

sleep 2

# Test the service
echo ""
echo "  Testing temperature service (port 8899)..."
if curl -s http://localhost:8899/health > /dev/null 2>&1; then
    echo "    Health check: OK"
    TEMP_RESULT=$(curl -s http://localhost:8899/temperature)
    TEMP_VALUE=$(echo "$TEMP_RESULT" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('data',{}).get('temperature','N/A'))" 2>/dev/null || echo "N/A")
    echo "    Temperature: ${TEMP_VALUE}°C"
else
    echo "    WARNING: Service not responding"
    systemctl status proxmox-temp-api.service --no-pager
fi

echo ""
echo "========================================================"
echo "Installation Complete!"
echo "========================================================"
echo ""
NODE_IP=$(hostname -I | awk '{print $1}')
NODE_NAME=$(hostname)
echo "The temperature service is now available at:"
echo "  http://${NODE_IP}:8899/temperature"
echo ""
echo "Test with curl:"
echo "  curl http://${NODE_IP}:8899/temperature"
echo ""

# ============================================================================
# FIREWALL CONFIGURATION (OPTIONAL)
# ============================================================================

if [ "$SKIP_FIREWALL" = false ]; then
    echo ""
    echo "========================================================"
    echo "OPTIONAL: Firewall Security Configuration"
    echo "========================================================"
    echo ""
    echo "The temperature service is currently accessible from"
    echo "ANY IP address on your network."
    echo ""
    echo "Would you like to configure firewall rules to restrict"
    echo "access to specific IP addresses? (Recommended)"
    echo ""
    
    if [ "$AUTO_FIREWALL" = true ]; then
        # Auto mode - use provided IP
        CONFIGURE_FIREWALL="y"
        DASHBOARD_IP="$FIREWALL_IP"
        echo "Auto-configuring firewall for IP: $FIREWALL_IP"
    else
        # Interactive mode - ask user
        read -p "Configure firewall now? [Y/n] " -n 1 -r
        echo
        CONFIGURE_FIREWALL="$REPLY"
    fi
    
    if [[ $CONFIGURE_FIREWALL =~ ^[Yy]$|^$ ]]; then
        echo ""
        echo "Setting up firewall rules for port 8899..."
        echo ""
        
        # Get dashboard IP if not provided
        if [ -z "$DASHBOARD_IP" ]; then
            CURRENT_IP=$(who am i | awk '{print $5}' | tr -d '()')
            if [ -z "$CURRENT_IP" ]; then
                CURRENT_IP="YOUR_LAPTOP_IP"
            fi
            
            echo "Your current IP appears to be: $CURRENT_IP"
            echo ""
            read -p "Enter dashboard IP address [$CURRENT_IP]: " INPUT_IP
            DASHBOARD_IP=${INPUT_IP:-$CURRENT_IP}
        fi
        
        # Ask for additional IPs (only in interactive mode)
        ADDITIONAL_IPS=""
        if [ "$AUTO_FIREWALL" = false ]; then
            echo ""
            echo "Additional IPs to allow (comma-separated, or press Enter to skip):"
            read -p "Additional IPs: " ADDITIONAL_IPS
        fi
        
        # Check if iptables-persistent is installed
        if ! command -v iptables-save &> /dev/null; then
            echo ""
            echo "Installing iptables-persistent..."
            apt-get update -qq
            DEBIAN_FRONTEND=noninteractive apt-get install -y iptables-persistent >/dev/null 2>&1
            echo "  Installed iptables-persistent"
        fi
        
        echo ""
        echo "Configuring firewall rules..."
        
        # Check if rules already exist
        EXISTING_RULES=$(iptables -L INPUT -n | grep -c "dpt:8899" || true)
        if [ "$EXISTING_RULES" -gt 0 ]; then
            echo "  Found existing rules for port 8899"
            read -p "  Remove existing rules and reconfigure? [y/N] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                # Remove existing rules
                while iptables -D INPUT -p tcp --dport 8899 -j ACCEPT 2>/dev/null; do :; done
                while iptables -D INPUT -p tcp --dport 8899 -j DROP 2>/dev/null; do :; done
                echo "  Removed existing rules"
            else
                echo "  Keeping existing rules"
                DASHBOARD_IP=""  # Skip adding new rules
            fi
        fi
        
        # Add new rules if needed
        if [ -n "$DASHBOARD_IP" ] && [ "$DASHBOARD_IP" != "YOUR_LAPTOP_IP" ]; then
            # Allow localhost
            iptables -I INPUT -p tcp --dport 8899 -s 127.0.0.1 -j ACCEPT 2>/dev/null || true
            
            # Allow dashboard IP
            iptables -I INPUT -p tcp --dport 8899 -s "$DASHBOARD_IP" -j ACCEPT
            echo "  Allowed: $DASHBOARD_IP"
            
            # Allow additional IPs
            if [ -n "$ADDITIONAL_IPS" ]; then
                IFS=',' read -ra IPS <<< "$ADDITIONAL_IPS"
                for ip in "${IPS[@]}"; do
                    ip=$(echo "$ip" | xargs)  # Trim whitespace
                    if [ -n "$ip" ]; then
                        iptables -I INPUT -p tcp --dport 8899 -s "$ip" -j ACCEPT
                        echo "  Allowed: $ip"
                    fi
                done
            fi
            
            # Drop all other connections to port 8899
            iptables -A INPUT -p tcp --dport 8899 -j DROP 2>/dev/null || true
            echo "  All other IPs blocked"
            
            # Save rules
            echo ""
            echo "Saving firewall rules..."
            iptables-save > /etc/iptables/rules.v4
            echo "  Rules saved to /etc/iptables/rules.v4"
            
            echo ""
            echo "══════════════════════════════════════════════════"
            echo "Firewall Configuration Complete"
            echo "══════════════════════════════════════════════════"
            echo ""
            echo "Active rules for port 8899:"
            iptables -L INPUT -n -v | grep 8899 || echo "  (No rules found)"
            echo ""
            echo "To manage firewall rules later:"
            echo ""
            echo "  Add IP:    iptables -I INPUT -p tcp --dport 8899 -s NEW_IP -j ACCEPT"
            echo "             iptables-save > /etc/iptables/rules.v4"
            echo ""
            echo "  Remove IP: iptables -D INPUT -p tcp --dport 8899 -s OLD_IP -j ACCEPT"
            echo "             iptables-save > /etc/iptables/rules.v4"
            echo ""
            echo "  View:      iptables -L INPUT -n -v | grep 8899"
            echo ""
        fi
    else
        echo ""
        echo "Skipping firewall configuration."
        echo ""
        echo "WARNING: Port 8899 is accessible from any IP!"
        echo ""
        echo "To configure firewall later, run:"
        echo "  iptables -I INPUT -p tcp --dport 8899 -s YOUR_LAPTOP_IP -j ACCEPT"
        echo "  iptables -A INPUT -p tcp --dport 8899 -j DROP"
        echo "  iptables-save > /etc/iptables/rules.v4"
        echo ""
    fi
fi

echo ""
echo "========================================================"
echo "Setup Summary"
echo "========================================================"
echo ""
echo "Service management:"
echo "  systemctl status proxmox-temp-api"
echo "  systemctl restart proxmox-temp-api"
echo "  journalctl -u proxmox-temp-api -f"
echo ""
echo "Files installed:"
echo "  /usr/local/bin/proxmox-temp-reader.py"
echo "  /usr/local/bin/proxmox-temp-service.py"
echo "  /etc/systemd/system/proxmox-temp-api.service"
echo ""
echo "These files survive Proxmox updates!"
echo ""
echo "========================================================"
echo "NEXT: Install this script on ALL other Proxmox nodes"
echo "========================================================"
echo ""
