### Boolean Context
- **Python**: Explicit True/False, specific falsy values (None, 0, empty containers)
- **Perl**: Any value can be boolean - 0, '', undef are false; everything else is true

### List Processing
- **Python**: List comprehensions `[x for x in list if condition]`
- **Perl**: `grep`, `map` functions - `grep { condition } @list`

### Method Calls
- **Python**: Dot notation `object.method()`
- **Perl**: Arrow notation `$object->method()`

### Hash/Dictionary Access
- **Python**: Square brackets `dict['key']`
- **Perl**: Arrow for references `$hashref->{key}`, or `$hash{key}` for regular hashes

### String Formatting
- **Python**: F-strings `f"{var}"`, `.format()`, old-style `%`
- **Perl**: `sprintf`, string interpolation in double quotes, `.` concatenation

### Regular Expressions
- **Python**: `re` module, `re.match()`, `re.search()`
- **Perl**: Built-in with `=~` operator, `/pattern/` syntax

### Postfix Conditionals
- **Python**: Not supported - must use full if statement
- **Perl**: `statement if condition;` and `statement unless condition;`

### Array/List Operations
- **Python**: `.append()`, `.extend()`, slicing with `[start:end]`
- **Perl**: `push`, `pop`, `shift`, `unshift`, slicing with `[start..end]`

---

## Complete Code Flow Summary

### Python Script Flow:
1. Import libraries and disable SSL warnings
2. Get credentials (command line or interactive)
3. Validate credentials exist
4. Create Proxmox object (authenticates automatically)
5. Enter main loop:
   - Call `show()` to display dashboard
   - Call `menu()` for user interaction
   - Break loop if menu returns False
6. Handle Ctrl+C and other exceptions gracefully

### Perl Script Flow:
1. Load modules and enable strict/warnings
2. Get credentials (command line or interactive with hidden password)
3. Validate credentials exist
4. Create Proxmox object (authenticates automatically)
5. Enter main loop:
   - Call `show()` to display dashboard
   - Call `menu()` for user interaction
   - Exit loop if menu returns 0
6. Dies on any unhandled errors

### Show Function Flow (Both Scripts):
1. Initialize empty items list/array
2. Get all Proxmox nodes
3. For each node:
   - Get all VMs:
     - Fetch config and status
     - Extract CPU, memory info
     - Parse disk size from config
     - If running, query guest agent for filesystem usage
     - Add VM info to items
   - Get all containers:
     - Fetch config and status
     - Extract CPU, memory info
     - Parse rootfs size
     - If running, get disk usage from status
     - Add container info to items
4. Sort items by ID
5. Print formatted table with all information
6. Return items list/array

### Menu Function Flow (Both Scripts):
1. Display menu options
2. Read user choice
3. Handle choice:
   - **Option 1**: Prompt for ID, find item, start it via API
   - **Option 2**: Prompt for ID, find item, stop it via API
   - **Option 3**: Filter stopped items, start each one via API
   - **Option 4**: Do nothing (refresh by returning to main loop)
   - **Option 5**: Return False/0 to exit program
4. Return True/1 to continue (except option 5)

---

## API Endpoints Used

### Authentication:
```
POST /api2/json/access/ticket
Body: username=root@pam&password=yourpassword
Returns: {data: {ticket: "...", CSRFPreventionToken: "..."}}
```

### Get Nodes:
```
GET /api2/json/nodes
Returns: [{node: "pve", status: "online", ...}, ...]
```

### Get VMs on Node:
```
GET /api2/json/nodes/{node}/qemu
Returns: [{vmid: 100, name: "vm1", status: "running", ...}, ...]
```

### Get VM Configuration:
```
GET /api2/json/nodes/{node}/qemu/{vmid}/config
Returns: {cores: 2, memory: 2048, balloon: 1024, scsi0: "...", ...}
```

### Get VM Status:
```
GET /api2/json/nodes/{node}/qemu/{vmid}/status/current
Returns: {status: "running", uptime: 12345, ...}
```

### Get VM Filesystem Info (via Guest Agent):
```
GET /api2/json/nodes/{node}/qemu/{vmid}/agent/get-fsinfo
Returns: {result: [{mountpoint: "/", total-bytes: 20000000000, used-bytes: 5000000000, ...}, ...]}
```

### Get Containers on Node:
```
GET /api2/json/nodes/{node}/lxc
Returns: [{vmid: 101, name: "ct1", status: "running", ...}, ...]
```

### Get Container Configuration:
```
GET /api2/json/nodes/{node}/lxc/{vmid}/config
Returns: {cores: 1, memory: 512, rootfs: "local-lvm:vm-101-disk-0,size=8G", ...}
```

### Get Container Status:
```
GET /api2/json/nodes/{node}/lxc/{vmid}/status/current
Returns: {status: "running", disk: 2000000000, maxdisk: 8000000000, ...}
```

### Start VM:
```
POST /api2/json/nodes/{node}/qemu/{vmid}/status/start
Headers: CSRFPreventionToken
Cookie: PVEAuthCookie
```

### Stop VM:
```
POST /api2/json/nodes/{node}/qemu/{vmid}/status/stop
Headers: CSRFPreventionToken
Cookie: PVEAuthCookie
```

### Start Container:
```
POST /api2/json/nodes/{node}/lxc/{vmid}/status/start
Headers: CSRFPreventionToken
Cookie: PVEAuthCookie
```

### Stop Container:
```
POST /api2/json/nodes/{node}/lxc/{vmid}/status/stop
Headers: CSRFPreventionToken
Cookie: PVEAuthCookie
```

---

## Memory Usage Explained

### VMs - Ballooning:
- **Balloon Memory (Minimum)**: Lowest amount of RAM the VM can use
- **Maximum Memory**: Highest amount of RAM the VM can use
- **Ballooning**: Dynamic memory allocation - VM can release unused RAM back to host
- **Display Format**: "2.0GB - 4.0GB" means VM uses between 2-4 GB

### Containers - Memory + Swap:
- **Memory**: Regular RAM allocated to container
- **Swap**: Swap space allocated to container
- **Display Format**: "512.0MB - 512.0MB" shows memory and swap
- **No Ballooning**: Containers use fixed allocation model

---

## Disk Information Explained

### Total Disk:
- Size configured in VM/container settings
- Read from config file (e.g., `size=22G`)
- Fixed value - doesn't change while running

### Total FS (Total Filesystem):
- Actual usable filesystem size reported by OS
- Usually slightly less than Total Disk due to:
  - Partition tables
  - Filesystem metadata
  - Boot partitions
- Only available when VM/container is running

### Free Disk:
- Actual free space on filesystem
- **VMs**: Retrieved from QEMU guest agent
- **Containers**: Retrieved from status API
- Only available when running

### Free %:
- Percentage: (Free Disk / Total FS) × 100
- Shows how much space is available
- "N/A" when stopped (can't measure)

---

## Why Guest Agent is Needed for VMs

### VMs are Isolated:
- Run in full virtualization
- Host cannot directly access VM's filesystem
- Need agent inside VM to report filesystem info

### QEMU Guest Agent:
- Small daemon running inside the VM
- Communicates with host via virtual serial port
- Provides filesystem info, time sync, shutdown signals
- Installation required:
  - **Linux**: `dnf install qemu-guest-agent`
  - **Windows**: Install from VirtIO drivers ISO

### Containers Don't Need Agent:
- Use OS-level virtualization
- Share host kernel
- Host has direct visibility into container filesystems
- Disk usage available via simple system calls

---

## Error Handling Philosophy

### Python Script:
- **Graceful degradation**: Errors in filesystem query are caught but script continues
- **User-friendly messages**: Clear error messages for authentication failures
- **Keyboard interrupt handling**: Ctrl+C exits cleanly
- **Validation**: Checks credentials before attempting connection

### Perl Script:
- **Die on critical errors**: Authentication failures stop execution immediately
- **Silent failures**: Guest agent errors are ignored with `eval`
- **Detailed error messages**: Shows HTTP status and response body
- **Validation**: Uses `unless` to ensure credentials exist

### Both Scripts:
- Disable SSL verification for self-signed certificates
- Provide helpful connection information during authentication
- Show which VM/CT operations succeed/fail
- Continue running even if some API calls fail

---

## Performance Considerations

### API Calls:
- Each VM/container requires 2-3 API calls (config, status, agent)
- Large environments (100+ VMs) may take several seconds
- No parallel execution - calls are sequential
- Refresh on demand rather than automatic polling

### Memory Usage:
- Items stored in list/array (small memory footprint)
- JSON parsing creates temporary objects
- Hash/dictionary storage for each VM/container
- Minimal - suitable for large environments

### Network Traffic:
- All HTTPS requests (encrypted overhead)
- JSON responses (text-based, compressed by HTTP)
- Cookies reused (no re-authentication)
- Efficient for LAN usage

---

## Security Considerations

### Password Handling:
- **Python**: `getpass` module hides input
- **Perl**: `Term::ReadKey` disables echo
- Password stored in memory only (not written to disk)
- Command-line arguments visible in process list (less secure)

### SSL/TLS:
- Verification disabled for self-signed certificates
- WARNING: Vulnerable to man-in-the-middle attacks
- Acceptable for trusted internal networks
- Production use should enable verification with proper certificates

### Authentication:
- Uses Proxmox's native authentication
- Ticket-based (expires after period of inactivity)
- CSRF token prevents cross-site request forgery
- Cookies and tokens stored only in memory

### Permissions:
- Requires permissions to view/control VMs and containers
- Root account has full access
- Can use restricted accounts with specific privileges
- Check Proxmox user management for proper access control

---

## Troubleshooting Guide

### Authentication Fails (401):
1. Verify username includes realm (e.g., `root@pam`)
2. Check password is correct
3. Test with curl: `curl -k -d "username=root@pam&password=pass" https://host:8006/api2/json/access/ticket`
4. Ensure port 8006 is accessible

### VM Filesystem Shows N/A:
1. Install QEMU guest agent in VM
2. Enable agent in VM options
3. Restart VM after installation
4. Check agent status: `systemctl status qemu-guest-agent`

### Container Disk Shows N/A:
1. Container must be running
2. Check container status in Proxmox GUI
3. Verify container is using proper storage backend

### Connection Timeout:
1. Check host IP/hostname is correct
2. Verify firewall allows port 8006
3. Ensure Proxmox service is running
4. Test network connectivity: `ping host`

### Perl Module Errors:
- Install missing modules: `dnf install perl-LWP-Protocol-https perl-JSON perl-TermReadKey`
- Check CPAN if modules not in repository

### Python Module Errors:
- Install missing modules: `pip3 install requests urllib3`
- Use virtual environment if permission issues

---

## Future Enhancement Ideas

### Features to Add:
1. **Automatic refresh**: Poll every N seconds
2. **Filtering**: Show only VMs, only containers, or specific nodes
3. **Sorting options**: By name, status, memory usage, etc.
4. **Color coding**: Green for running, red for stopped
5. **Resource graphs**: CPU/memory usage over time
6. **Backup status**: Show last backup date/time
7. **Migration support**: Move VMs between nodes
8. **Bulk operations**: Start/stop multiple VMs at once
9. **Configuration file**: Store credentials securely
10. **Logging**: Record all operations to file
11. **Email alerts**: Notify on status changes
12. **Web interface**: Replace CLI with web dashboard

### Code Improvements:
1. **Parallel API calls**: Use threading/async for speed
2. **Caching**: Store results briefly to reduce API calls
3. **Configuration profiles**: Support multiple Proxmox servers
4. **Better error recovery**: Retry failed operations
5. **Progress indicators**: Show loading status for large environments
6. **Export functionality**: Save data to CSV/JSON
7. **Search/filter**: Find specific VMs quickly
8. **Statistics**: Show totals, averages, utilization
9. **Templates**: Support VM templates and clones
10. **Snapshots**: List and manage VM snapshots

---

## Conclusion

Both scripts accomplish the same goal using different programming languages:

### Python Advantages:
- Cleaner, more readable syntax
- Better string formatting (f-strings)
- More intuitive object system
- Easier for beginners
- Better error messages by default

### Perl Advantages:
- More powerful regex built-in
- Postfix conditionals (more concise)
- CPAN has extensive module library
- Better text processing capabilities
- Mature system administration tradition

### When to Use Each:
- **Python**: Modern deployments, teams familiar with Python, cleaner codebases
- **Perl**: Legacy systems, existing Perl infrastructure, text-heavy processing

Both scripts are functionally equivalent and will work identically in production. Choose based on:
1. Team expertise
2. Existing codebase language
3. Available libraries and tools
4. Personal preference
5. Integration requirements

The most important factor is that both scripts work reliably and are maintainable by your team.```perl
    print "Password: ";
    ReadMode('noecho');
    $PASSWORD = <STDIN>;
    ReadMode('restore');
    chomp $PASSWORD;
    print "\n";
```
**Lines 25-30**: Reads password with hidden input.
**`ReadMode('noecho')`**: Turns off echo to screen (hides typing).
**`ReadMode('restore')`**: Restores normal terminal mode after input.
**Why needed**: Without restoring, terminal stays in no-echo mode.

```perl
}

unless ($HOST && $USER && $PASSWORD) {
    die "Error: Host, username, and password are required.\n";
}
```
**Lines 33-35**: Validates that all credentials were provided.
**`unless`**: Negative form of `if` - runs if condition is false.
**`&&`**: Logical AND operator.
**`die`**: Prints error message and exits program immediately.

### Lines 37-77: Proxmox Package (Class) Definition

```perl
package Proxmox {
```
**Line 38**: Starts package definition (Perl's version of a class).
**Package**: Namespace that groups related subroutines.
**`{...}`**: Modern Perl syntax for package scope.

```perl
    sub new {
        my ($class, $host, $user, $password) = @_;
```
**Lines 39-40**: Constructor method.
**`sub`**: Defines a subroutine (function/method).
**`@_`**: Special array containing all arguments passed to subroutine.
**`my (...) = @_`**: Unpacks arguments into named variables.
**`$class`**: First argument is always the class name when called as `Proxmox->new()`.

```perl
        my $self = {
            base => "https://$host:8006/api2/json",
            ua => LWP::UserAgent->new(ssl_opts => { verify_hostname => 0, SSL_verify_mode => 0 }),
            cookies => {},
            headers => {}
        };
```
**Lines 41-46**: Creates object as a hash reference.
**`{...}`**: Creates anonymous hash (dictionary).
**`=>`**: "Fat comma" - same as comma but more readable for key-value pairs.
**`LWP::UserAgent->new(...)`**: Creates new HTTP client object.
**`ssl_opts`**: Hash reference with SSL options.
**`verify_hostname => 0`**: Disables hostname verification.
**`SSL_verify_mode => 0`**: Disables certificate verification.
**`{}`**: Empty hash reference for cookies/headers.

```perl
        bless $self, $class;
```
**Line 47**: Associates hash reference with the class.
**`bless`**: Marks the reference as belonging to this class.
**Effect**: Now `$self` is a Proxmox object, not just a hash.

```perl
        $self->authenticate($user, $password);
```
**Line 48**: Calls authenticate method on the new object.
**`->`**: Method call operator (like `.` in other languages).

```perl
        return $self;
```
**Line 49**: Returns the blessed object.

```perl
    }
```
**Line 50**: Ends the `new` subroutine.

```perl
    sub authenticate {
        my ($self, $user, $password) = @_;
```
**Lines 52-53**: Authenticate method.
**`$self`**: First argument is always the object when called as method.

```perl
        my $url = "$self->{base}/access/ticket";
```
**Line 54**: Constructs authentication URL.
**`$self->{base}`**: Accesses 'base' key from the hash reference.
**`->`**: Dereference operator for hash/array references.
**`"..."`**: String with variable interpolation.

```perl
        my $response = $self->{ua}->post($url, {
            username => $user,
            password => $password
        });
```
**Lines 55-58**: Makes POST request.
**`$self->{ua}->post`**: Calls post method on the UserAgent object.
**Second argument**: Hash reference with form data.

```perl
        unless ($response->is_success) {
```
**Line 60**: Checks if request failed.
**`is_success`**: Returns true if HTTP status is 2xx.

```perl
            die "Authentication failed: " . $response->status_line . "\n" . 
                "Response: " . $response->content . "\n";
```
**Lines 61-62**: Dies with detailed error message.
**`.`**: String concatenation.
**`status_line`**: Returns status code and message (e.g., "401 Unauthorized").
**`content`**: Returns response body.

```perl
        }
```
**Line 63**: Ends unless block.

```perl
        my $json = JSON->new;
        my $data = $json->decode($response->content)->{data};
```
**Lines 65-66**: Parses JSON response.
**`JSON->new`**: Creates JSON parser object.
**`->decode()`**: Converts JSON string to Perl data structure.
**`->{data}`**: Accesses 'data' key from resulting hash reference.

```perl
        $self->{cookies} = { PVEAuthCookie => $data->{ticket} };
        $self->{headers} = { CSRFPreventionToken => $data->{CSRFPreventionToken} };
```
**Lines 67-68**: Stores authentication data in object.
**`{ key => value }`**: Creates anonymous hash reference.

```perl
    }
```
**Line 69**: Ends authenticate subroutine.

```perl
    sub get {
        my ($self, $path) = @_;
```
**Lines 71-72**: GET request method.

```perl
        my $url = "$self->{base}$path";
```
**Line 73**: Constructs full URL.

```perl
        my $req = HTTP::Request->new(GET => $url);
```
**Line 74**: Creates new GET request object.
**`GET => $url`**: Fat comma syntax for clarity.

```perl
        $req->header('Cookie' => "PVEAuthCookie=$self->{cookies}{PVEAuthCookie}");
```
**Line 75**: Adds authentication cookie to request.
**`$self->{cookies}{PVEAuthCookie}`**: Nested hash access.
**Equivalent to**: `$self->{cookies}->{PVEAuthCookie}` (arrow optional between braces).

```perl
        my $response = $self->{ua}->request($req);
```
**Line 76**: Sends the request.

```perl
        die "GET failed: " . $response->status_line unless $response->is_success;
```
**Line 77**: Dies if request failed.
**Postfix `unless`**: Modifier form - statement unless condition.

```perl
        my $json = JSON->new;
        return $json->decode($response->content)->{data};
```
**Lines 78-79**: Parses JSON and returns data field.

```perl
    }
```
**Line 80**: Ends get subroutine.

```perl
    sub post {
        my ($self, $path) = @_;
        my $url = "$self->{base}$path";
        my $req = HTTP::Request->new(POST => $url);
        $req->header('Cookie' => "PVEAuthCookie=$self->{cookies}{PVEAuthCookie}");
        $req->header('CSRFPreventionToken' => $self->{headers}{CSRFPreventionToken});
        my $response = $self->{ua}->request($req);
        die "POST failed: " . $response->status_line unless $response->is_success;
        return $response;
    }
}
```
**Lines 82-91**: POST request method - similar to GET but adds CSRF token.
**Line 91**: Ends Proxmox package.

```perl
package main;
```
**Line 93**: Returns to main namespace.
**Why needed**: After defining package, we need to explicitly return to main.

### Lines 95-105: Format Bytes Function

```perl
sub fmt {
    my ($b) = @_;
```
**Lines 96-97**: Format bytes function.
**Parentheses**: Converts `@_` to list, then extracts first element.

```perl
    return 'N/A' unless defined $b && $b ne 'N/A';
```
**Line 98**: Returns 'N/A' if undefined or already 'N/A'.
**`defined $b`**: Checks if variable has a defined value (not undef).
**`ne`**: String inequality operator ("not equal").
**String operators**: `eq` (equal), `ne` (not equal), `lt` (less than), etc.

```perl
    $b = 0 + $b;  # Convert to number
```
**Line 99**: Forces numeric conversion.
**`0 + $b`**: Adding zero coerces string to number.

```perl
    for my $u ('B', 'KB', 'MB', 'GB', 'TB') {
```
**Line 100**: Loops through units.
**`for my $u (...)`**: Iterates over list, assigning each value to `$u`.

```perl
        return sprintf("%.1f%s", $b, $u) if $b < 1024;
```
**Line 101**: Returns formatted string if value is small enough.
**`sprintf`**: Formats string like C's printf.
**`%.1f`**: Float with 1 decimal place.
**`%s`**: String.
**Postfix `if`**: Statement if condition.

```perl
        $b /= 1024;
```
**Line 102**: Divides by 1024 for next iteration.
**`/=`**: Divide and assign operator.

```perl
    }
    return sprintf("%.1fPB", $b);
}
```
**Lines 103-105**: If loop completes, format as petabytes.

### Lines 107-304: Show Function

```perl
sub show {
    my ($px) = @_;
    my @items;
```
**Lines 108-110**: Show function definition.
**`@items`**: Array (not reference) to store items.
**`@` prefix**: Indicates array variable.

```perl
    my $nodes = $px->get('/nodes');
```
**Line 112**: Gets list of nodes.
**Returns**: Array reference.

```perl
    for my $node (@$nodes) {
```
**Line 114**: Loops through nodes.
**`@$nodes`**: Dereferences array reference to get array.
**`@{$nodes}`**: Alternative syntax (more explicit).

```perl
        my $n = $node->{node};
```
**Line 115**: Extracts node name from hash reference.

### Lines 117-195: Process VMs

```perl
        my $vms = $px->get("/nodes/$n/qemu");
```
**Line 118**: Gets VMs for this node.

```perl
        for my $vm (@$vms) {
```
**Line 119**: Loops through VMs.

```perl
            my $cfg = $px->get("/nodes/$n/qemu/$vm->{vmid}/config");
            my $stat = $px->get("/nodes/$n/qemu/$vm->{vmid}/status/current");
```
**Lines 120-121**: Gets VM config and status.
**`$vm->{vmid}`**: Accesses vmid key from VM hash reference.

```perl
            my $balloon = ($cfg->{balloon} || 0) * 1024 * 1024;
            my $maxmem = ($cfg->{memory} || 0) * 1024 * 1024;
```
**Lines 124-125**: Calculates memory in bytes.
**`|| 0`**: "Or" operator - returns 0 if left side is false/undef.
**Short-circuit evaluation**: Doesn't evaluate right side if left is true.

```perl
            my $cores = $cfg->{cores} || 'N/A';
            my $sockets = $cfg->{sockets} || 'N/A';
            my $cpu_type = $cfg->{cpu} || 'N/A';
```
**Lines 128-130**: Extracts CPU info with defaults.

```perl
            my $total_disk = 0;
            for my $key (sort keys %$cfg) {
```
**Lines 133-134**: Loops through sorted config keys.
**`keys %$cfg`**: Dereferences hash reference and gets keys.
**`%{$cfg}`**: Alternative dereferencing syntax.
**`sort`**: Sorts keys alphabetically.

```perl
                if ($key =~ /^(scsi0|sata0|ide0|virtio0)$/) {
```
**Line 135**: Checks if key matches disk controller pattern.
**`=~`**: Binding operator - applies regex to variable.
**`/^...$/'**: Regex pattern anchored to start (^) and end ($).
**`|`**: Alternation in regex (OR).

```perl
                    my $value = $cfg->{$key};
```
**Line 136**: Gets value for this key.

```perl
                    if ($value =~ /size=(\d+\.?\d*)([GMT])/) {
```
**Line 137**: Extracts size with regex.
**`\d+`**: One or more digits.
**`\.?`**: Optional decimal point.
**`\d*`**: Zero or more digits (fractional part).
**`[GMT]`**: Character class - matches G, M, or T.
**`(...)`**: Capturing groups - saves matched text.

```perl
                        my ($size, $unit) = ($1, $2);
```
**Line 138**: Extracts captured groups.
**`$1, $2`**: Special variables containing regex captures.
**Must use immediately**: Captures are overwritten by next regex match.

```perl
                        if ($unit eq 'G') {
                            $total_disk = $size * 1024 * 1024 * 1024;
```
**Lines 139-140**: Converts gigabytes to bytes.
**`eq`**: String equality operator.

```perl
                        } elsif ($unit eq 'M') {
                            $total_disk = $size * 1024 * 1024;
                        } elsif ($unit eq 'T') {
                            $total_disk = $size * 1024 * 1024 * 1024 * 1024;
                        }
```
**Lines 141-144**: Handles other units.

```perl
                        last if $total_disk > 0;
```
**Line 145**: Exits innermost loop if disk found.
**`last`**: Perl's equivalent of `break`.

```perl
                    }
                }
            }
```
**Lines 146-148**: Closes if blocks and for loop.

```perl
            my $disk_free = 'N/A';
            my $disk_free_pct = 'N/A';
            my $total_filesystem = 'N/A';
```
**Lines 151-153**: Initializes disk usage variables.

```perl
            if ($vm->{status} eq 'running') {
```
**Line 155**: Only process if VM is running.

```perl
                eval {
```
**Line 156**: Starts error-catching block.
**`eval`**: Catches runtime errors (like try/catch).

```perl
                    my $agent_data = $px->get("/nodes/$n/qemu/$vm->{vmid}/agent/get-fsinfo");
```
**Line 157**: Queries guest agent.

```perl
                    if ($agent_data && ref $agent_data->{result} eq 'ARRAY') {
```
**Line 158**: Validates response.
**`ref`**: Returns type of reference ('ARRAY', 'HASH', 'CODE', etc.).
**`eq 'ARRAY'`**: Checks if it's an array reference.

```perl
                        my $total_fs = 0;
                        my $avail_fs = 0;
```
**Lines 159-160**: Initializes accumulators.

```perl
                        for my $fs (@{$agent_data->{result}}) {
```
**Line 162**: Loops through filesystems.
**`@{...}`**: Dereferences array reference.

```perl
                            my $mp = $fs->{mountpoint} || $fs->{target} || '';
                            my $fs_type = $fs->{type} || '';
```
**Lines 163-164**: Extracts mountpoint and type with fallbacks.
**Chained `||`**: Returns first true value.

```perl
                            next if $fs_type =~ /^(iso9660|udf|tmpfs|devtmpfs)$/;
```
**Line 166**: Skips non-disk filesystems.
**`next`**: Perl's equivalent of `continue`.
**Postfix `if`**: Modifier form.

```perl
                            if ($mp =~ /^(\/$|\/boot$|\/home$|\/var$|\/tmp$|\/usr$)/) {
```
**Line 168**: Checks if mountpoint is important.
**`\/**: Escaped forward slash followed by end anchor.

```perl
                                my $total = $fs->{'total-bytes'} || 0;
                                my $used = $fs->{'used-bytes'} || 0;
```
**Lines 169-170**: Gets total and used bytes.
**`{'total-bytes'}`**: Quotes needed because of hyphen in key name.

```perl
                                if ($total > 0 && $used >= 0) {
                                    $total_fs += $total;
                                    $avail_fs += ($total - $used);
                                }
```
**Lines 171-174**: Accumulates totals if valid.
**`>=`**: Numeric greater-than-or-equal operator.

```perl
                        }
                        
                        if ($total_fs > 0 && $avail_fs > 0) {
                            $total_filesystem = fmt($total_fs);
                            $disk_free = fmt($avail_fs);
                            $disk_free_pct = ($avail_fs / $total_fs * 100);
                        }
```
**Lines 177-181**: Formats final values if valid.

```perl
                    }
                };
```
**Lines 182-183**: Closes if block and eval block.
**Note**: Semicolon after eval block is required.

```perl
            }
```
**Line 184**: Closes running status check.

```perl
            push @items, {
```
**Line 186**: Adds item to array.
**`push`**: Appends to end of array.
**Second argument**: Anonymous hash reference.

```perl
                id => $vm->{vmid},
                name => $vm->{name},
                type => 'VM',
                status => $vm->{status},
                node => $n,
                cores => $cores,
                sockets => $sockets,
                cpu_type => $cpu_type,
                mem => fmt($balloon) . " - " . fmt($maxmem),
                total_disk => $total_disk > 0 ? fmt($total_disk) : 'N/A',
                total_filesystem => $total_filesystem,
                free_disk => $disk_free,
                free => $disk_free_pct
            };
```
**Lines 187-199**: Creates hash reference with VM info.
**`.`**: String concatenation.
**`? :`**: Ternary operator.

```perl
        }
```
**Line 200**: Closes VM loop.

### Lines 203-262: Process Containers

```perl
        my $cts = $px->get("/nodes/$n/lxc");
        for my $ct (@$cts) {
```
**Lines 203-204**: Gets and loops through containers.

```perl
            my $cfg = $px->get("/nodes/$n/lxc/$ct->{vmid}/config");
            my $stat = $px->get("/nodes/$n/lxc/$ct->{vmid}/status/current");
```
**Lines 205-206**: Gets container config and status.

```perl
            my $memory = ($cfg->{memory} || 0) * 1024 * 1024;
            my $swap = ($cfg->{swap} || 0) * 1024 * 1024;
```
**Lines 209-210**: Calculates memory and swap.

```perl
            my $cores = $cfg->{cores} || 'N/A';
            my $sockets = 'N/A';  # Containers don't have sockets
            my $cpu_type = 'N/A';  # Containers don't have CPU type
```
**Lines 213-215**: Gets CPU info (containers lack sockets/type).

```perl
            my $total_disk = 0;
            my $rootfs = $cfg->{rootfs} || '';
```
**Lines 218-219**: Gets rootfs config.

```perl
            if ($rootfs =~ /size=(\d+\.?\d*)([GMT])/) {
```
**Line 220**: Extracts size from rootfs string.

```perl
                my ($size, $unit) = ($1, $2);
                if ($unit eq 'G') {
                    $total_disk = $size * 1024 * 1024 * 1024;
                } elsif ($unit eq 'M') {
                    $total_disk = $size * 1024 * 1024;
                } elsif ($unit eq 'T') {
                    $total_disk = $size * 1024 * 1024 * 1024 * 1024;
                }
            }
```
**Lines 221-228**: Converts size to bytes.

```perl
            my $disk_free = 'N/A';
            my $disk_free_pct = 'N/A';
            my $total_filesystem = 'N/A';
```
**Lines 231-233**: Initializes disk variables.

```perl
            if ($ct->{status} eq 'running') {
```
**Line 235**: Only process if container is running.

```perl
                my $disk_used = $stat->{disk} || 0;
                my $disk_max = $stat->{maxdisk} || 0;
```
**Lines 236-237**: Gets disk usage from status.

```perl
                if ($disk_max > 0) {
                    my $free_bytes = $disk_max - $disk_used;
                    $total_filesystem = fmt($disk_max);
                    $disk_free = fmt($free_bytes);
                    $disk_free_pct = ($free_bytes / $disk_max * 100);
                }
```
**Lines 238-243**: Calculates disk usage.

```perl
            }
            
            push @items, {
                id => $ct->{vmid},
                name => $ct->{name},
                type => 'CT',
                status => $ct->{status},
                node => $n,
                cores => $cores,
                sockets => $sockets,
                cpu_type => $cpu_type,
                mem => fmt($memory) . " - " . fmt($swap),
                total_disk => $total_disk > 0 ? fmt($total_disk) : 'N/A',
                total_filesystem => $total_filesystem,
                free_disk => $disk_free,
                free => $disk_free_pct
            };
```
**Lines 246-261**: Adds container to items array.

```perl
        }
    }
```
**Lines 262-263**: Closes container and node loops.

### Lines 265-281: Display Items

```perl
    @items = sort { $a->{id} <=> $b->{id} } @items;
```
**Line 265**: Sorts items by ID.
**`sort { ... } @items`**: Custom sort with comparison function.
**`$a` and `$b`**: Special variables for sort comparison.
**`<=>`**: Numeric comparison operator (spaceship operator).
**Returns**: -1 if $a < $b, 0 if equal, 1 if $a > $b.

```perl
    print "\n" . "=" x 170 . "\n";
```
**Line 267**: Prints separator line.
**`.`**: String concatenation.
**`x 170`**: Repeats string 170 times.

```perl
    printf "%-6s %-4s %-10s %-20s %-12s %-6s %-8s %-15s %-20s %-12s %-12s %-12s %-8s\n",
        'ID', 'Type', 'Status', 'Name', 'Node', 'Cores', 'Sockets', 'CPU Type', 'Memory', 'Total Disk', 'Total FS', 'Free Disk', 'Free%';
```
**Lines 268-269**: Prints header row.
**`printf`**: Formatted print (like C's printf).
**`%-6s`**: Left-aligned string in 6-character field.
**`%6s`** would be right-aligned.

```perl
    print "-" x 170 . "\n";
```
**Line 270**: Prints separator.

```perl
    for my $i (@items) {
```
**Line 272**: Loops through items.

```perl
        my $free_display = (ref $i->{free} || $i->{free} =~ /^\d/) ? sprintf("%.1f%%", $i->{free}) : $i->{free};
```
**Line 273**: Formats free percentage.
**`ref $i->{free}`**: Returns true if it's a reference.
**`=~ /^\d/`**: Checks if starts with digit.
**`sprintf("%.1f%%", ...)`**: Formats with 1 decimal, `%%` prints literal %.

```perl
        printf "%-6s %-4s %-10s %-20s %-12s %-6s %-8s %-15s %-20s %-12s %-12s %-12s %-8s\n",
            $i->{id}, $i->{type}, $i->{status}, $i->{name}, $i->{node},
            $i->{cores}, $i->{sockets}, $i->{cpu_type}, $i->{mem}, $i->{total_disk}, $i->{total_filesystem},
            $i->{free_disk}, $free_display;
```
**Lines 274-277**: Prints each row with formatting.

```perl
    }
    
    print "=" x 170 . "\n";
    return \@items;
```
**Lines 279-281**: Prints footer and returns array reference.
**`\@items`**: Backslash creates reference to array.

```perl
}
```
**Line 282**: Closes show subroutine.

### Lines 284-330: Menu Function

```perl
sub menu {
    my ($px, $items) = @_;
```
**Lines 285-286**: Menu function definition.

```perl
    print "\n1. Start VM/CT  2. Stop VM/CT  3. Start all stopped  4. Refresh  5. Exit\n";
    print "Choice: ";
    my $c = <STDIN>;
    chomp $c;
```
**Lines 288-291**: Displays menu and reads choice.

```perl
    if ($c eq '1') {
        print "ID: ";
        my $vid = <STDIN>;
        chomp $vid;
```
**Lines 293-296**: Gets VM/CT ID for start option.

```perl
        my ($item) = grep { $_->{id} eq $vid } @$items;
```
**Line 297**: Finds item with matching ID.
**`grep { ... } @$items`**: Filters array, returns matching elements.
**`$_`**: Special variable - current element in grep/map.
**`my ($item)`**: List context forces grep to return list, takes first element.

```perl
        if ($item) {
            my $type = $item->{type} eq 'VM' ? 'qemu' : 'lxc';
```
**Lines 298-299**: Checks if item found and determines type.
**`? :`**: Ternary operator.

```perl
            $px->post("/nodes/$item->{node}/$type/$item->{id}/status/start");
            print "✓ Started $item->{type} $item->{id}\n";
        }
    }
```
**Lines 300-302**: Starts VM/CT and prints confirmation.

```perl
    elsif ($c eq '2') {
        print "ID: ";
        my $vid = <STDIN>;
        chomp $vid;
        my ($item) = grep { $_->{id} eq $vid } @$items;
        if ($item) {
            my $type = $item->{type} eq 'VM' ? 'qemu' : 'lxc';
            $px->post("/nodes/$item->{node}/$type/$item->{id}/status/stop");
            print "✓ Stopped $item->{type} $item->{id}\n";
        }
    }
```
**Lines 304-313**: Stop option - same logic but calls stop endpoint.

```perl
    elsif ($c eq '3') {
        for my $item (grep { $_->{status} ne 'running' } @$items) {
```
**Lines 315-316**: Start all stopped option.
**`ne 'running'`**: String not-equal comparison.
**`grep { ... }`**: Filters to only stopped items.

```perl
            my $type = $item->{type} eq 'VM' ? 'qemu' : 'lxc';
            $px->post("/nodes/$item->{node}/$type/$item->{id}/status/start");
            print "✓ Started $item->{type} $item->{id}\n";
        }
    }
```
**Lines 317-320**: Starts each stopped item.

```perl
    elsif ($c eq '5') {
        return 0;
    }
```
**Lines 322-324**: Exit option returns 0 (false).

```perl
    return 1;
```
**Line 326**: Returns 1 (true) for all other options.

```perl
}
```
**Line 327**: Closes menu subroutine.

### Lines 329-334: Main Program

```perl
print "\nConnecting to Proxmox...\n";
```
**Line 330**: Prints status message.

```perl
my $px = Proxmox->new($HOST, $USER, $PASSWORD);
```
**Line 331**: Creates Proxmox object and authenticates.
**`Proxmox->new(...)`**: Calls new method as class method.

```perl
while (1) {
```
**Line 332**: Infinite loop.
**`1`**: Always true in Perl.

```perl
    my $items = show($px);
    last unless menu($px, $items);
}
```
**Lines 333-334**: Displays dashboard and menu, exits if menu returns false.
**`last`**: Exits loop (like `break`).
**Postfix `unless`**: Exits if menu returns false.

---

## Key Differences Summary

### Variable Declaration
- **Python**: No declaration keyword needed
- **Perl**: `my` keyword required in strict mode

### Sigils (Variable Prefixes)
- **Python**: No sigils - same name everywhere
- **Perl**: `$scalar`, `@array`, `%hash`, different access syntax

### String Operations
- **Python**: `+` for concatenation, f-strings for interpolation
- **Perl**: `.` for concatenation, automatic interpolation in double quotes

### References
- **Python**: Everything is a reference by default
- **Perl**: Explicit reference creation with `\`, dereferencing with `->`, `@{}`, `%{}`

### Object System
- **Python**: Built-in class system with `self` parameter
- **Perl**: Manual blessing, `$self` convention

### Error Handling
- **Python**: `try`/`except` blocks
- **Perl**: `eval` blocks, checks `$@` for errors

### Comparison Operators
- **Python**: Same operators for numbers and strings (`==`, `!=`, `<`, etc.)
- **Perl**: Different operators - numeric (`==`, `!=`, `<=>`) vs string (`eq`, `ne`, `cmp`)

### Boolean Context
- **Python**: Explicit True/False, specific fal# Proxmox Dashboard Scripts - Complete Line-by-Line Explanation

## Python Script - Line by Line

### Line 1: Shebang
```python
#!/usr/bin/env python3
```
**Purpose**: Tells the operating system to use Python 3 to execute this script.
**How it works**: When you make the script executable (`chmod +x`), the system reads this first line to know which interpreter to use. `/usr/bin/env python3` finds Python 3 in your PATH.

### Lines 2-5: Import Statements
```python
import requests
import urllib3
import sys
import getpass
```
**Line 2 - `import requests`**: Imports the requests library for making HTTP calls to the Proxmox API.
**Line 3 - `import urllib3`**: Imports urllib3 for disabling SSL certificate warnings.
**Line 4 - `import sys`**: Imports system-specific functions (command line arguments, exit).
**Line 5 - `import getpass`**: Imports the getpass module for secure password input (hides typing).

### Line 6: Disable SSL Warnings
```python
urllib3.disable_warnings()
```
**Purpose**: Suppresses warning messages about unverified HTTPS requests.
**Why needed**: Proxmox often uses self-signed SSL certificates which would normally trigger warnings.

### Lines 8-18: Get Credentials
```python
if len(sys.argv) == 4:
```
**Line 8**: Checks if exactly 4 command-line arguments were provided (script name + 3 parameters).
**`sys.argv`**: A list containing command-line arguments. `sys.argv[0]` is the script name.
**`len()`**: Returns the number of items in the list.

```python
    HOST = sys.argv[1]
    USER = sys.argv[2]
    PASSWORD = sys.argv[3]
```
**Lines 9-11**: If arguments were provided, assign them to variables.
**`sys.argv[1]`**: First argument (host).
**`sys.argv[2]`**: Second argument (username).
**`sys.argv[3]`**: Third argument (password).

```python
else:
    print("Proxmox VM/Container Dashboard")
    print("-" * 50)
```
**Line 12**: If no command-line arguments, run this block instead.
**Line 13**: Prints the title of the program.
**Line 14**: Prints 50 dashes as a separator. The `*` operator repeats strings.

```python
    HOST = input("Proxmox host (e.g., 192.168.1.100): ").strip()
    USER = input("Username (e.g., root@pam): ").strip()
    PASSWORD = getpass.getpass("Password: ")
```
**Line 15**: Prompts user for host, reads input, `.strip()` removes leading/trailing whitespace.
**Line 16**: Prompts for username with example format.
**Line 17**: Prompts for password using `getpass` which hides the input (no echo to screen).

### Lines 19-21: Validate Credentials
```python
if not HOST or not USER or not PASSWORD:
    print("Error: Host, username, and password are required.")
    sys.exit(1)
```
**Line 19**: Checks if any variable is empty/None. `not` makes it True if the value is falsy.
**Line 20**: Prints error message if validation fails.
**Line 21**: Exits the program with error code 1 (non-zero indicates error).

### Lines 23-44: Proxmox Class Definition
```python
class Proxmox:
```
**Line 23**: Defines a new class named "Proxmox" to encapsulate API interactions.
**Classes**: Blueprints for creating objects with methods and properties.

```python
    def __init__(self, host, user, password):
```
**Line 24**: Constructor method - automatically called when creating a new Proxmox object.
**`self`**: Reference to the instance being created (like `this` in other languages).
**`__init__`**: Special method name that Python recognizes as the constructor.

```python
        self.base = f"https://{host}:8006/api2/json"
        print(f"Attempting to connect to: {self.base}")
        print(f"Username: {user}")
```
**Line 25**: Creates base URL for API calls. `f"..."` is an f-string allowing `{variable}` insertion.
**Line 26**: Prints the URL being used for debugging.
**Line 27**: Prints the username for verification.

```python
        r = requests.post(f"{self.base}/access/ticket", 
                         data={'username': user, 'password': password}, 
                         verify=False)
```
**Lines 28-30**: Makes POST request to authenticate.
**`requests.post()`**: Sends HTTP POST request.
**`data={...}`**: Dictionary of form data to send (username and password).
**`verify=False`**: Disables SSL certificate verification.

```python
        if r.status_code != 200:
```
**Line 31**: Checks if response status is not 200 (OK).
**`status_code`**: HTTP response code (200=success, 401=unauthorized, 404=not found, etc.).

```python
            print(f"Authentication failed: {r.status_code}")
            print(f"Response: {r.text}")
            print("\nPlease verify:")
            print("1. Username includes realm (e.g., root@pam)")
            print("2. Password is correct")
            print("3. Host is accessible on port 8006")
            sys.exit(1)
```
**Lines 32-38**: Error handling for failed authentication.
**`r.text`**: The response body as a string.
**`\n`**: Newline character for blank line.
**`sys.exit(1)`**: Exit program with error code.

```python
        d = r.json()['data']
```
**Line 39**: Parses JSON response and extracts the 'data' field.
**`.json()`**: Automatically converts JSON string to Python dictionary.
**`['data']`**: Accesses the 'data' key in the dictionary.

```python
        self.cookies = {'PVEAuthCookie': d['ticket']}
        self.headers = {'CSRFPreventionToken': d['CSRFPreventionToken']}
        print("✓ Authentication successful!")
```
**Line 40**: Stores authentication cookie as instance variable.
**Line 41**: Stores CSRF token for POST requests.
**Line 42**: Prints success message.

### Lines 44-48: GET Request Method
```python
    def get(self, path):
        return requests.get(f"{self.base}{path}", cookies=self.cookies, verify=False).json()['data']
```
**Line 44**: Defines a method to make GET requests.
**Line 45**: Makes GET request with stored cookies, parses JSON, returns data field.
**Method chaining**: `.get().json()['data']` chains multiple operations in one line.

### Lines 47-49: POST Request Method
```python
    def post(self, path):
        return requests.post(f"{self.base}{path}", headers=self.headers, cookies=self.cookies, verify=False)
```
**Line 47**: Defines method for POST requests (start/stop VMs).
**Line 48**: Makes POST request with both headers (CSRF token) and cookies.

### Lines 51-59: Format Bytes Function
```python
def fmt(b):
```
**Line 51**: Defines function to convert bytes to human-readable format.

```python
    if not b or b == 'N/A': return 'N/A'
```
**Line 52**: Returns 'N/A' if value is None, 0, empty string, or already 'N/A'.
**`not b`**: Evaluates to True if b is falsy (None, 0, False, empty string).

```python
    b = float(b)
```
**Line 53**: Converts value to floating-point number.
**Why**: Ensures we can do division even if the input is an integer or string.

```python
    for u in ['B','KB','MB','GB','TB']:
        if b < 1024: return f"{b:.1f}{u}"
        b /= 1024
```
**Lines 54-56**: Loops through units, dividing by 1024 each time.
**`b < 1024`**: If value is less than 1024, use this unit.
**`{b:.1f}`**: Format with 1 decimal place (.1f = 1 decimal float).
**`b /= 1024`**: Shorthand for `b = b / 1024`.

### Lines 58-66: Show Function (Start)
```python
def show(px):
    items = []
```
**Line 58**: Defines function to display dashboard. `px` is the Proxmox object.
**Line 59**: Creates empty list to store all VM/container information.

```python
    for node in px.get('/nodes'):
        n = node['node']
```
**Lines 61-62**: Gets all nodes and loops through them.
**`px.get('/nodes')`**: Calls the get method to retrieve nodes list.
**`node['node']`**: Extracts the node name from the node dictionary.

### Lines 64-149: Process VMs
```python
        for vm in px.get(f'/nodes/{n}/qemu'):
```
**Line 64**: Gets all QEMU VMs on this node and loops through them.
**`f'/nodes/{n}/qemu'`**: Constructs API path with node name inserted.

```python
            cfg = px.get(f'/nodes/{n}/qemu/{vm["vmid"]}/config')
            stat = px.get(f'/nodes/{n}/qemu/{vm["vmid"]}/status/current')
```
**Lines 65-66**: Fetches VM configuration and current status.
**`vm["vmid"]`**: VM ID number from the vm dictionary.

```python
            balloon = int(cfg.get('balloon', 0)) * 1024 * 1024 if cfg.get('balloon') else 0
            maxmem = int(cfg.get('memory', 0)) * 1024 * 1024 if cfg.get('memory') else 0
```
**Lines 69-70**: Gets memory values and converts MB to bytes.
**`.get('balloon', 0)`**: Gets 'balloon' key, returns 0 if not found.
**`if cfg.get('balloon') else 0`**: If balloon exists, do the conversion, otherwise use 0.
**`int()`**: Converts to integer (some configs return strings).
**`* 1024 * 1024`**: Converts megabytes to bytes.

```python
            cores = cfg.get('cores', 'N/A')
            sockets = cfg.get('sockets', 'N/A')
            cpu_type = cfg.get('cpu', 'N/A')
```
**Lines 73-75**: Extracts CPU information with 'N/A' as default.

```python
            total_disk = 0
            for key in sorted(cfg.keys()):
```
**Lines 78-79**: Initializes disk size and loops through sorted config keys.
**`cfg.keys()`**: Returns all keys in the config dictionary.
**`sorted()`**: Sorts keys alphabetically.

```python
                if key.startswith(('scsi0', 'sata0', 'ide0', 'virtio0')):
```
**Line 80**: Checks if key name starts with any of these disk controller names.
**`.startswith(tuple)`**: Can check multiple prefixes at once when passed a tuple.

```python
                    value = str(cfg[key])
                    if ':' in value:
```
**Lines 81-82**: Converts value to string and checks if it contains a colon.
**Why**: Disk configs look like `"storage:vm-100-disk-0,size=32G"`.

```python
                        parts = value.split(',')
                        for part in parts:
```
**Lines 83-84**: Splits on commas and loops through parts.
**`.split(',')`**: Creates list by splitting string at each comma.

```python
                            if 'size=' in part:
                                size_str = part.split('size=')[1].strip()
```
**Lines 85-86**: Finds the size specification.
**`part.split('size=')[1]`**: Splits on 'size=', takes second part (after 'size=').
**`.strip()`**: Removes leading/trailing whitespace.

```python
                                if size_str.endswith('G'):
                                    total_disk = float(size_str[:-1]) * 1024 * 1024 * 1024
```
**Lines 87-88**: If size ends with 'G', convert gigabytes to bytes.
**`size_str[:-1]`**: String slice that takes everything except last character.
**`[:-1]`**: Slice notation meaning "from start to one before end".

```python
                                elif size_str.endswith('M'):
                                    total_disk = float(size_str[:-1]) * 1024 * 1024
                                elif size_str.endswith('T'):
                                    total_disk = float(size_str[:-1]) * 1024 * 1024 * 1024 * 1024
                                break
```
**Lines 89-92**: Handle megabytes and terabytes, then exit loop.
**`elif`**: "else if" - only checked if previous conditions were false.
**`break`**: Exits the innermost loop immediately.

```python
                    if total_disk > 0:
                        break
```
**Lines 93-94**: If we found a disk, exit the outer loop too.

```python
            disk_free = 'N/A'
            disk_free_pct = 'N/A'
            total_filesystem = 'N/A'
```
**Lines 97-99**: Initialize disk usage variables with default 'N/A' values.

```python
            if vm['status'] == 'running':
```
**Line 101**: Only get filesystem info if VM is running.
**Why**: Can't query guest agent when VM is stopped.

```python
                try:
```
**Line 102**: Starts error-catching block.
**`try`**: Executes code and catches any errors without crashing.

```python
                    agent_data = px.get(f'/nodes/{n}/qemu/{vm["vmid"]}/agent/get-fsinfo')
```
**Line 103**: Queries QEMU guest agent for filesystem information.

```python
                    if agent_data and 'result' in agent_data:
```
**Line 104**: Validates that we got data with a 'result' key.
**`and`**: Both conditions must be true.
**`'result' in agent_data`**: Checks if dictionary has this key.

```python
                        total_fs = 0
                        avail_fs = 0
```
**Lines 105-106**: Initialize accumulators for totaling all filesystems.

```python
                        for fs in agent_data['result']:
```
**Line 109**: Loops through each filesystem in the result.

```python
                            mp = fs.get('mountpoint', fs.get('target', ''))
                            fs_type = fs.get('type', '')
```
**Lines 110-111**: Extracts mountpoint and filesystem type.
**Nested `.get()`**: If 'mountpoint' doesn't exist, try 'target', if that fails use ''.

```python
                            if fs_type in ['iso9660', 'udf', 'tmpfs', 'devtmpfs']:
                                continue
```
**Lines 114-115**: Skips CD-ROMs and RAM-based filesystems.
**`in [...]`**: Checks if value is in the list.
**`continue`**: Skips rest of loop and goes to next iteration.

```python
                            if mp in ['/', '/boot', '/home', '/var', '/tmp', '/usr']:
```
**Line 118**: Only processes standard system mount points.

```python
                                total = fs.get('total-bytes', 0)
                                used = fs.get('used-bytes', 0)
```
**Lines 119-120**: Gets total and used bytes for this filesystem.

```python
                                if total > 0 and used >= 0:
                                    total_fs += total
                                    avail_fs += (total - used)
```
**Lines 121-123**: If valid data, add to running totals.
**`+=`**: Add to existing value (shorthand for `total_fs = total_fs + total`).

```python
                        if total_fs > 0 and avail_fs > 0:
                            total_filesystem = fmt(total_fs)
                            disk_free = fmt(avail_fs)
                            disk_free_pct = (avail_fs / total_fs * 100)
```
**Lines 125-128**: If we have valid totals, format and calculate percentage.
**`avail_fs / total_fs * 100`**: Calculates percentage.

```python
                except:
                    pass
```
**Lines 129-130**: Catches any errors and ignores them.
**`pass`**: Does nothing - empty statement required by Python syntax.

```python
            items.append({
                'id': vm['vmid'], 'name': vm['name'], 'type': 'VM',
                'status': vm['status'], 'node': n,
                'cores': cores,
                'sockets': sockets,
                'cpu_type': cpu_type,
                'mem': f"{fmt(balloon)} - {fmt(maxmem)}",
                'total_disk': fmt(total_disk) if total_disk > 0 else 'N/A',
                'total_filesystem': total_filesystem,
                'free_disk': disk_free,
                'free': disk_free_pct
            })
```
**Lines 132-143**: Creates dictionary with all VM info and adds to items list.
**`.append()`**: Adds item to end of list.
**`{...}`**: Creates a dictionary (key-value pairs).
**Ternary operator**: `value if condition else other_value`.

### Lines 145-195: Process Containers
```python
        for ct in px.get(f'/nodes/{n}/lxc'):
```
**Line 146**: Gets all LXC containers and loops through them.

```python
            cfg = px.get(f'/nodes/{n}/lxc/{ct["vmid"]}/config')
            stat = px.get(f'/nodes/{n}/lxc/{ct["vmid"]}/status/current')
```
**Lines 147-148**: Fetches container config and status.

```python
            memory = int(cfg.get('memory', 0)) * 1024 * 1024 if cfg.get('memory') else 0
            swap = int(cfg.get('swap', 0)) * 1024 * 1024 if cfg.get('swap') else 0
```
**Lines 151-152**: Gets memory and swap, converts MB to bytes.

```python
            cores = cfg.get('cores', 'N/A')
            sockets = 'N/A'  # Containers don't have sockets
            cpu_type = 'N/A'  # Containers don't have CPU type
```
**Lines 155-157**: Gets cores, but containers don't have sockets or CPU types.

```python
            total_disk = 0
            rootfs = cfg.get('rootfs', '')
```
**Lines 160-161**: Initializes disk variable and gets rootfs configuration.

```python
            if 'size=' in str(rootfs):
```
**Line 162**: Checks if rootfs config contains size specification.
**`str(rootfs)`**: Ensures it's a string before checking.

```python
                size_str = str(rootfs).split('size=')[1].split(',')[0].strip()
```
**Line 163**: Extracts size string from config.
**Chained operations**: `.split().split().strip()` performs multiple operations in sequence.

```python
                if size_str.endswith('G'):
                    total_disk = float(size_str[:-1]) * 1024 * 1024 * 1024
                elif size_str.endswith('M'):
                    total_disk = float(size_str[:-1]) * 1024 * 1024
                elif size_str.endswith('T'):
                    total_disk = float(size_str[:-1]) * 1024 * 1024 * 1024 * 1024
```
**Lines 164-169**: Converts size to bytes based on unit.

```python
            disk_free = 'N/A'
            disk_free_pct = 'N/A'
            total_filesystem = 'N/A'
```
**Lines 172-174**: Initialize disk usage variables.

```python
            if ct['status'] == 'running':
```
**Line 176**: Only get disk usage for running containers.

```python
                disk_used = stat.get('disk', 0)
                disk_max = stat.get('maxdisk', 0)
```
**Lines 177-178**: Gets disk usage from status (no agent needed for containers).

```python
                if disk_max > 0:
                    free_bytes = disk_max - disk_used
                    total_filesystem = fmt(disk_max)
                    disk_free = fmt(free_bytes)
                    disk_free_pct = (free_bytes / disk_max * 100)
```
**Lines 179-183**: Calculates free space and percentage.

```python
            items.append({
                'id': ct['vmid'], 'name': ct['name'], 'type': 'CT',
                'status': ct['status'], 'node': n,
                'cores': cores,
                'sockets': sockets,
                'cpu_type': cpu_type,
                'mem': f"{fmt(memory)} - {fmt(swap)}",
                'total_disk': fmt(total_disk) if total_disk > 0 else 'N/A',
                'total_filesystem': total_filesystem,
                'free_disk': disk_free,
                'free': disk_free_pct
            })
```
**Lines 185-195**: Creates dictionary with container info and adds to list.

### Lines 197-209: Display Items
```python
    items.sort(key=lambda x: x['id'])
```
**Line 197**: Sorts items list by ID.
**`lambda x: x['id']`**: Anonymous function that returns the 'id' key for each item.
**`lambda`**: Creates small unnamed function on the fly.

```python
    print("\n" + "="*170)
```
**Line 199**: Prints newline plus 170 equal signs.

```python
    print(f"{'ID':<6} {'Type':<4} {'Status':<10} {'Name':<20} {'Node':<12} {'Cores':<6} {'Sockets':<8} {'CPU Type':<15} {'Memory':<20} {'Total Disk':<12} {'Total FS':<12} {'Free Disk':<12} {'Free%':<8}")
```
**Line 200**: Prints table header row.
**`{'ID':<6}`**: Left-aligned in 6-character field.
**`:<6`**: Left align in 6 chars, `:>6` would right align, `:^6` would center.

```python
    print("-"*170)
```
**Line 201**: Prints 170 dashes as separator.

```python
    for i in items:
```
**Line 202**: Loops through all items (VMs and containers).

```python
        free_display = f"{i['free']:.1f}%" if isinstance(i['free'], (int, float)) else i['free']
```
**Line 203**: Formats free percentage or shows 'N/A'.
**`isinstance(i['free'], (int, float))`**: Checks if value is an int or float.
**`:.1f`**: Format float with 1 decimal place.

```python
        print(f"{i['id']:<6} {i['type']:<4} {i['status']:<10} {i['name']:<20} {i['node']:<12} {i['cores']:<6} {i['sockets']:<8} {i['cpu_type']:<15} {i['mem']:<20} {i['total_disk']:<12} {i['total_filesystem']:<12} {i['free_disk']:<12} {free_display:<8}")
```
**Line 204**: Prints each row with proper formatting.

```python
    print("="*170)
    return items
```
**Lines 205-206**: Prints footer separator and returns items list.

### Lines 208-248: Menu Function
```python
def menu(px, items):
```
**Line 208**: Defines menu function that handles user interaction.

```python
    print("\n1. Start VM/CT  2. Stop VM/CT  3. Start all stopped  4. Refresh  5. Exit")
    c = input("Choice: ").strip()
```
**Lines 209-210**: Displays menu and reads user choice.
**`.strip()`**: Removes whitespace from input.

```python
    if c == '1':
```
**Line 212**: Checks if user chose option 1.

```python
        vid = input("ID: ").strip()
```
**Line 213**: Prompts for VM/container ID.

```python
        i = next((x for x in items if str(x['id'])==vid), None)
```
**Line 214**: Finds item with matching ID.
**`next(generator, default)`**: Gets first item from generator expression.
**`(x for x in items if ...)`**: Generator expression (memory-efficient).
**`str(x['id'])`**: Converts ID to string for comparison.

```python
        if i:
```
**Line 215**: Proceeds only if item was found.

```python
            px.post(f"/nodes/{i['node']}/{'qemu' if i['type']=='VM' else 'lxc'}/{i['id']}/status/start")
```
**Line 216**: Calls API to start the VM/container.
**Inline conditional**: `'qemu' if condition else 'lxc'` selects API path.

```python
            print(f"✓ Started {i['type']} {i['id']}")
```
**Line 217**: Prints confirmation with checkmark.

```python
    elif c == '2':
        vid = input("ID: ").strip()
        i = next((x for x in items if str(x['id'])==vid), None)
        if i:
            px.post(f"/nodes/{i['node']}/{'qemu' if i['type']=='VM' else 'lxc'}/{i['id']}/status/stop")
            print(f"✓ Stopped {i['type']} {i['id']}")
```
**Lines 219-224**: Same logic as start but calls stop endpoint.

```python
    elif c == '3':
```
**Line 226**: Option to start all stopped VMs/containers.

```python
        for i in [x for x in items if x['status']!='running']:
```
**Line 227**: Filters items to only non-running ones.
**List comprehension**: `[x for x in items if condition]` creates new filtered list.

```python
            px.post(f"/nodes/{i['node']}/{'qemu' if i['type']=='VM' else 'lxc'}/{i['id']}/status/start")
            print(f"✓ Started {i['type']} {i['id']}")
```
**Lines 228-229**: Starts each stopped item.

```python
    elif c == '5':
        return False
```
**Lines 231-232**: Exit option returns False to signal end of loop.

```python
    return True
```
**Line 234**: Returns True for all other options to continue loop.

### Lines 236-244: Main Program
```python
px = Proxmox(HOST, USER, PASSWORD)
print("\nConnecting to Proxmox...")
```
**Lines 236-237**: Creates Proxmox object (authenticates) and prints status.

```python
try:
    while True:
        if not menu(px, show(px)): break
```
**Lines 238-240**: Main loop wrapped in error handler.
**`while True:`**: Infinite loop that runs until broken.
**`if not menu(...): break`**: If menu returns False, exit loop.

```python
except KeyboardInterrupt:
    print("\n\nExiting...")
```
**Lines 241-242**: Catches Ctrl+C and exits gracefully.
**`KeyboardInterrupt`**: Exception raised when user presses Ctrl+C.

```python
except Exception as e:
    print(f"\nError: {e}")
    sys.exit(1)
```
**Lines 243-245**: Catches all other errors and prints them.
**`as e`**: Assigns the exception object to variable `e`.

---

## Perl Script - Line by Line

### Line 1: Shebang
```perl
#!/usr/bin/env perl
```
**Purpose**: Tells the OS to use Perl interpreter.
**How it works**: Same as Python - system uses this to find the Perl executable.

### Lines 2-7: Use Statements (Module Imports)
```perl
use strict;
```
**Line 2**: Enables strict mode - requires variable declarations.
**Effect**: Helps catch typos and enforces good practices.

```perl
use warnings;
```
**Line 3**: Enables warning messages for problematic code.

```perl
use LWP::UserAgent;
```
**Line 4**: Imports HTTP client library.
**LWP**: Library for WWW in Perl.

```perl
use JSON;
```
**Line 5**: Imports JSON parsing/encoding library.

```perl
use HTTP::Request;
```
**Line 6**: Imports module for creating HTTP request objects.

```perl
use Term::ReadKey;
```
**Line 7**: Imports module for hiding password input.

### Lines 9-39: Get Credentials
```perl
my ($HOST, $USER, $PASSWORD);
```
**Line 10**: Declares three variables.
**`my`**: Creates lexically-scoped variable (limited to current block).
**Perl sigils**: `$` prefix indicates scalar (single value) variable.

```perl
if (@ARGV == 3) {
```
**Line 12**: Checks if exactly 3 command-line arguments provided.
**`@ARGV`**: Array containing command-line arguments.
**No `$` prefix**: Arrays use `@` prefix in Perl.
**In scalar context**: `@ARGV == 3` evaluates array size.

```perl
    ($HOST, $USER, $PASSWORD) = @ARGV;
```
**Line 13**: Assigns array elements to variables.
**List assignment**: Distributes array values to multiple variables.

```perl
} else {
    print "Proxmox VM/Container Dashboard\n";
    print "-" x 50 . "\n";
```
**Lines 14-16**: If no arguments, print header.
**`x` operator**: Repeats string (like `*` in Python).
**`.` operator**: String concatenation in Perl.
**`\n`**: Newline character must be included explicitly.

```perl
    print "Proxmox host (e.g., 192.168.1.100): ";
    $HOST = <STDIN>;
    chomp $HOST;
```
**Lines 17-19**: Prompts for host and reads input.
**`<STDIN>`**: Reads line from standard input.
**`chomp`**: Removes trailing newline character.

```perl
    print "Username (e.g., root\@pam): ";
    $USER = <STDIN>;
    chomp $USER;
```
**Lines 21-23**: Prompts for username.
**`\@`**: Backslash escapes the @ symbol (otherwise it's a variable sigil).

```perl
    print "Password: ";
    ReadMode('noecho');
    $PASSWORD = <STDIN>;
    ReadMode('restore');
    chomp $PASSWORD;
    print "\n";
```
**Lines 25-30**: Reads password with hidden input.
**`ReadMode('noecho')`**: Turns off echo
