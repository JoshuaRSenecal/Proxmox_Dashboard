#!/usr/bin/env python3
# Proxmox Dashboard - Live Data Feed with Node Temperature Monitoring
# Version 2.4 - Fixed SSL Hostname Verification and Credential Change Bug

import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
import requests
from requests.adapters import HTTPAdapter
from urllib3.poolmanager import PoolManager
import urllib3
import ssl
import json
import base64
import os
import threading
import time
import queue
import logging
from datetime import datetime, timedelta
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.expanduser('~/.proxmox_dashboard.log'))
    ]
)
logger = logging.getLogger('ProxmoxDashboard')

# Secure log file permissions (owner read/write only)
LOG_FILE = os.path.expanduser('~/.proxmox_dashboard.log')
if os.path.exists(LOG_FILE):
    os.chmod(LOG_FILE, 0o600)

# Configuration
SALT = b'proxmox_dashboard_salt_v1'
CREDENTIALS_FILE = os.path.expanduser('~/.proxmox_credentials.enc')
PROXMOX_CA_CERT = os.path.expanduser('~/proxmox-ca.pem')
AUDIT_LOG_FILE = os.path.expanduser('~/.proxmox_dashboard_audit.log')
REFRESH_INTERVAL = 3  # seconds - Live data feed (near-constant updates)
MAX_RETRIES = 3
RETRY_DELAY = 2

# SSL Configuration - MANDATORY
if not os.path.exists(PROXMOX_CA_CERT):
    error_msg = f"""
SSL CERTIFICATE REQUIRED

The Proxmox CA certificate is required for secure connections.

Certificate not found at: {PROXMOX_CA_CERT}

To obtain the certificate:
  1. SSH into your Proxmox server
  2. Run: scp root@YOUR_PROXMOX_IP:/etc/pve/pve-root-ca.pem {PROXMOX_CA_CERT}
  
Or manually copy /etc/pve/pve-root-ca.pem from Proxmox to {PROXMOX_CA_CERT}

SSL verification is MANDATORY for security.
Dashboard cannot start without the CA certificate.
"""
    print(error_msg)
    logger.error("SSL Certificate not found - cannot start")
    logger.error(f"Expected location: {PROXMOX_CA_CERT}")
    exit(1)

logger.info(f"SSL Verification: Enabled (using {PROXMOX_CA_CERT})")


class AuditLogger:
    """Audit logger for tracking all critical operations"""
    
    @staticmethod
    def log(action, target, result, details=None):
        try:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_entry = f"{timestamp} | {action:20} | {target:20} | {result:10}"
            if details:
                log_entry += f" | {details}"
            
            with open(AUDIT_LOG_FILE, 'a') as f:
                f.write(log_entry + '\n')
            
            # Secure audit log permissions (owner read/write only)
            if os.path.exists(AUDIT_LOG_FILE):
                os.chmod(AUDIT_LOG_FILE, 0o600)
        except Exception as e:
            logger.error(f"Failed to write audit log: {e}")
    
    @staticmethod
    def log_authentication(host, user, success):
        result = "SUCCESS" if success else "FAILED"
        AuditLogger.log("AUTH", f"{user}@{host}", result)
    
    @staticmethod
    def log_vm_action(action, vmid, vm_type, vm_name, success, error=None):
        result = "SUCCESS" if success else "FAILED"
        target = f"{vm_type} {vmid} ({vm_name})"
        details = f"Error: {error}" if error else None
        AuditLogger.log(action, target, result, details)


class SSLAdapter(HTTPAdapter):
    """Custom HTTPAdapter that verifies both CA cert AND hostname"""
    
    def init_poolmanager(self, *args, **kwargs):
        # Create SSL context that verifies BOTH certificate AND hostname
        context = ssl.create_default_context(cafile=PROXMOX_CA_CERT)
        context.check_hostname = True   # FIXED: Enable hostname verification
        context.verify_mode = ssl.CERT_REQUIRED  # Verify certificate
        
        kwargs['ssl_context'] = context
        return super().init_poolmanager(*args, **kwargs)


class ProxmoxAPI:
    """Proxmox API Client - API Token Authentication Only"""
    
    def __init__(self, host, token_id, token_secret):
        self.base = f"https://{host}:8006/api2/json"
        self.host = host
        
        # SSL verification with CA cert AND hostname checking enabled
        self.verify = PROXMOX_CA_CERT
        self.ssl_status = "Verified"
        
        # Create session with custom SSL adapter
        self.session = requests.Session()
        self.session.mount('https://', SSLAdapter())
        
        # API Token authentication
        self.headers = {'Authorization': f'PVEAPIToken={token_id}={token_secret}'}
        
        # Test authentication
        try:
            self._api_request('get', '/version')
            AuditLogger.log_authentication(host, token_id, True)
            logger.info(f"Successfully authenticated with token: {token_id}")
        except requests.exceptions.HTTPError as e:
            # Authentication or HTTP error - preserve original error message
            AuditLogger.log_authentication(host, token_id, False)
            logger.error(f"API authentication failed: {str(e)}")
            raise
        except Exception as e:
            # Other errors (connection, timeout, etc.)
            AuditLogger.log_authentication(host, token_id, False)
            logger.error(f"API connection failed: {str(e)}")
            raise
    
    def _api_request(self, method, path, retries=MAX_RETRIES, **kwargs):
        """Make API request with retry logic - Token authentication only"""
        for attempt in range(retries):
            try:
                if method == 'get':
                    r = self.session.get(
                        f"{self.base}{path}",
                        headers=self.headers,
                        verify=self.verify,
                        timeout=10,
                        **kwargs
                    )
                elif method == 'post':
                    r = self.session.post(
                        f"{self.base}{path}",
                        headers=self.headers,
                        verify=self.verify,
                        timeout=10,
                        **kwargs
                    )
                
                if r.status_code in [200, 201]:
                    return r
                elif r.status_code == 401:
                    # Authentication failure - don't retry, fail immediately
                    r.raise_for_status()
                elif r.status_code >= 500 and attempt < retries - 1:
                    # Server error - retry with backoff
                    delay = RETRY_DELAY * (2 ** attempt)
                    time.sleep(delay)
                    continue
                else:
                    # Other errors - fail immediately
                    r.raise_for_status()
            
            except requests.exceptions.HTTPError:
                # HTTP errors (401, 403, 404, etc.) - never retry, re-raise immediately
                raise
            except requests.exceptions.ConnectionError as e:
                if attempt == retries - 1:
                    raise
                time.sleep(RETRY_DELAY * (2 ** attempt))
            except requests.exceptions.Timeout as e:
                if attempt == retries - 1:
                    raise
                time.sleep(RETRY_DELAY * (2 ** attempt))
            except Exception as e:
                # Unknown error - fail immediately
                raise
        
        raise Exception(f"API request failed after {retries} attempts")
    
    def get(self, path):
        r = self._api_request('get', path)
        try:
            response_data = r.json()
            if 'data' in response_data:
                return response_data['data']
            else:
                return response_data
        except (ValueError, KeyError, TypeError) as e:
            raise Exception(f"Invalid API response from {path}: {str(e)}")
    
    def post(self, path, data=None):
        kwargs = {'data': data} if data else {}
        return self._api_request('post', path, **kwargs)


class CredentialManager:
    """Manages encrypted credential storage - supports both passwords and API tokens"""
    
    @staticmethod
    def get_key_from_password(password):
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=SALT,
            iterations=100000,
        )
        return base64.urlsafe_b64encode(kdf.derive(password.encode()))
    
    @staticmethod
    def save_credentials(host, master_password, token_id, token_secret):
        """Save API token credentials (token authentication only)"""
        try:
            credentials = {
                'host': host,
                'auth_type': 'token',
                'token_id': token_id,
                'token_secret': token_secret
            }
            
            key = CredentialManager.get_key_from_password(master_password)
            cipher = Fernet(key)
            encrypted_data = cipher.encrypt(json.dumps(credentials).encode())
            
            with open(CREDENTIALS_FILE, 'wb') as f:
                f.write(encrypted_data)
            os.chmod(CREDENTIALS_FILE, 0o600)
        except IOError as e:
            raise Exception(f"Failed to save credentials file: {str(e)}")
        except Exception as e:
            raise Exception(f"Failed to encrypt credentials: {str(e)}")
    
    @staticmethod
    def load_credentials(master_password):
        if not os.path.exists(CREDENTIALS_FILE):
            return None
        
        try:
            with open(CREDENTIALS_FILE, 'rb') as f:
                encrypted_data = f.read()
            
            key = CredentialManager.get_key_from_password(master_password)
            cipher = Fernet(key)
            decrypted_data = cipher.decrypt(encrypted_data)
            return json.loads(decrypted_data.decode())
        except IOError as e:
            raise Exception(f"Failed to read credentials file: {str(e)}")
        except Exception as e:
            # Most likely wrong password or corrupted file
            raise Exception("Invalid master password or corrupted credentials file")


def extract_hostname_from_certificate(cert_path):
    """Extract Common Name from SSL certificate"""
    try:
        import subprocess
        result = subprocess.run(
            ['openssl', 'x509', '-in', cert_path, '-noout', '-subject'],
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode == 0:
            # Parse subject line: "subject=CN = pve"
            for part in result.stdout.split(','):
                if 'CN' in part or 'CN=' in part:
                    hostname = part.split('=')[-1].strip()
                    return hostname
    except Exception as e:
        logger.error(f"Failed to extract hostname from certificate: {e}")
    return None


class TokenCreationGuide(tk.Toplevel):
    """Guide dialog for creating API tokens in Proxmox"""
    
    def __init__(self, parent):
        super().__init__(parent)
        self.title("Create Proxmox API Token")
        self.geometry("700x650")
        self.resizable(True, True)
        
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - 350
        y = (self.winfo_screenheight() // 2) - 325
        self.geometry(f"700x650+{x}+{y}")
        
        self.create_widgets()
        self.protocol("WM_DELETE_WINDOW", self.on_close)
        self.grab_set()
    
    def create_widgets(self):
        # Title
        title_frame = tk.Frame(self, bg="#3498db", height=60)
        title_frame.pack(fill=tk.X)
        title_frame.pack_propagate(False)
        
        title_label = tk.Label(
            title_frame,
            text="Step 1: Create API Token in Proxmox",
            font=("Arial", 16, "bold"),
            bg="#3498db",
            fg="white"
        )
        title_label.pack(pady=15)
        
        # Main content with scrollbar
        main_frame = tk.Frame(self, bg="white")
        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Create canvas and scrollbar
        canvas = tk.Canvas(main_frame, bg="white", highlightthickness=0)
        scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="white")
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Instructions content
        instructions = [
            ("What is an API Token?", "bold", "#2c3e50"),
            ("An API token is a secure way to connect to Proxmox without using your password.\n", "normal", "#34495e"),
            
            ("How to Create Token:", "bold", "#2c3e50"),
            ("1. Open Proxmox web interface", "bold", "#27ae60"),
            ("   Go to: https://YOUR_PROXMOX_IP:8006\n", "normal", "#7f8c8d"),
            
            ("2. Navigate to API Tokens", "bold", "#27ae60"),
            ("   Click: Datacenter → Permissions → API Tokens\n", "normal", "#7f8c8d"),
            
            ("3. Click 'Add' button", "bold", "#27ae60"),
            ("   (Top of the API Tokens page)\n", "normal", "#7f8c8d"),
            
            ("4. Fill in the form:", "bold", "#27ae60"),
            ("   • User: root@pam", "normal", "#7f8c8d"),
            ("   • Token ID: dashboard (or any name you want)", "normal", "#7f8c8d"),
            ("   • Privilege Separation: UNCHECK THIS BOX", "normal", "#e74c3c"),
            ("   • Expire: Never", "normal", "#7f8c8d"),
            ("   • Comment: Dashboard access (optional)\n", "normal", "#7f8c8d"),
            
            ("5. Click 'Add' button", "bold", "#27ae60"),
            ("   The token will be created.\n", "normal", "#7f8c8d"),
            
            ("6. COPY THE SECRET!", "bold", "#e74c3c"),
            ("   A popup or message will show the token secret.", "normal", "#e74c3c"),
            ("   COPY IT IMMEDIATELY - it's shown only once!\n", "normal", "#e74c3c"),
            
            ("Alternative: Command Line (Recommended)", "bold", "#2c3e50"),
            ("If you have SSH access, this is more reliable:\n", "normal", "#34495e"),
            
            ("ssh root@YOUR_PROXMOX_IP", "normal", "#16a085"),
            ("pveum user token add root@pam dashboard --privsep 0\n", "normal", "#16a085"),
            
            ("The secret will appear in the output immediately.\n", "normal", "#7f8c8d"),
            
            ("What You'll Need for Next Step:", "bold", "#2c3e50"),
            ("• Token ID: root@pam!dashboard", "normal", "#34495e"),
            ("• Token Secret: (the long string you copied)\n", "normal", "#34495e"),
        ]
        
        for text, weight, color in instructions:
            label = tk.Label(
                scrollable_frame,
                text=text,
                font=("Arial", 10, weight),
                bg="white",
                fg=color,
                justify=tk.LEFT,
                wraplength=620,
                anchor="w"
            )
            label.pack(anchor="w", pady=2)
        
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Button frame
        btn_frame = tk.Frame(self, bg="white")
        btn_frame.pack(fill=tk.X, padx=20, pady=20)
        
        tk.Button(
            btn_frame,
            text="I've Created the Token - Continue",
            command=self.on_continue,
            bg="#27ae60",
            fg="white",
            font=("Arial", 12, "bold"),
            width=30,
            height=2,
            cursor="hand2"
        ).pack(pady=5)
        
        tk.Button(
            btn_frame,
            text="Cancel",
            command=self.on_close,
            bg="#95a5a6",
            fg="white",
            font=("Arial", 10),
            width=30,
            cursor="hand2"
        ).pack(pady=5)
    
    def on_continue(self):
        self.destroy()
    
    def on_close(self):
        self.destroy()


class CredentialsDialog(tk.Toplevel):
    """Dialog for entering API token credentials - Token Authentication Only"""
    
    def __init__(self, parent, is_setup=False):
        super().__init__(parent)
        self.title("Setup Credentials" if is_setup else "Enter Credentials")
        self.geometry("500x470")
        self.resizable(True, True)
        self.result = None
        self.is_setup = is_setup
        
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - 250
        y = (self.winfo_screenheight() // 2) - 235
        self.geometry(f"500x470+{x}+{y}")
        
        self.create_widgets()
        self.protocol("WM_DELETE_WINDOW", self.on_cancel)
        self.grab_set()
    
    def create_widgets(self):
        # Title
        title_frame = tk.Frame(self, bg="#2c3e50", height=60)
        title_frame.pack(fill=tk.X)
        title_frame.pack_propagate(False)
        
        title_label = tk.Label(
            title_frame,
            text="Proxmox Dashboard Setup" if self.is_setup else "Unlock Dashboard",
            font=("Arial", 16, "bold"),
            bg="#2c3e50",
            fg="white"
        )
        title_label.pack(pady=15)
        
        # Form frame
        form_frame = tk.Frame(self, bg="white")
        form_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Host
        tk.Label(form_frame, text="Proxmox Host:", font=("Arial", 10), bg="white").grid(row=0, column=0, sticky="w", pady=5)
        self.host_entry = tk.Entry(form_frame, font=("Arial", 10), width=35)
        self.host_entry.grid(row=0, column=1, pady=5, columnspan=2)
        self.host_entry.insert(0, "pve")
        
        # Auth type label
        tk.Label(form_frame, text="Authentication: API Token", font=("Arial", 10, "bold"), bg="white", fg="#27ae60").grid(row=1, column=0, sticky="w", pady=10, columnspan=3)
        
        # Token fields
        tk.Label(form_frame, text="Token ID:", font=("Arial", 10), bg="white").grid(row=2, column=0, sticky="w", pady=5)
        self.token_id_entry = tk.Entry(form_frame, font=("Arial", 10), width=35)
        self.token_id_entry.grid(row=2, column=1, pady=5, columnspan=2)
        self.token_id_entry.insert(0, "root@pam!")
        
        tk.Label(form_frame, text="Token Secret:", font=("Arial", 10), bg="white").grid(row=3, column=0, sticky="w", pady=5)
        self.token_secret_entry = tk.Entry(form_frame, font=("Arial", 10), width=35, show="*")
        self.token_secret_entry.grid(row=3, column=1, pady=5, columnspan=2)
        
        tk.Label(
            form_frame,
            text="Create token: Datacenter → Permissions → API Tokens → Add",
            font=("Arial", 8),
            bg="white",
            fg="#7f8c8d"
        ).grid(row=4, column=0, columnspan=3, sticky="w", pady=2)
        
        # Master password
        tk.Label(form_frame, text="Master Password:", font=("Arial", 10, "bold"), bg="white").grid(row=5, column=0, sticky="w", pady=(15, 5))
        self.master_entry = tk.Entry(form_frame, font=("Arial", 10), width=35, show="*")
        self.master_entry.grid(row=5, column=1, pady=(15, 5), columnspan=2)
        
        tk.Label(
            form_frame,
            text="(Used to encrypt credentials locally)",
            font=("Arial", 8),
            bg="white",
            fg="#7f8c8d"
        ).grid(row=6, column=1, sticky="w", columnspan=2)
        
        if self.is_setup:
            tk.Label(form_frame, text="Confirm Master:", font=("Arial", 10), bg="white").grid(row=7, column=0, sticky="w", pady=5)
            self.master_confirm = tk.Entry(form_frame, font=("Arial", 10), width=35, show="*")
            self.master_confirm.grid(row=7, column=1, pady=5, columnspan=2)
        
        # Buttons
        btn_frame = tk.Frame(form_frame, bg="white")
        btn_frame.grid(row=8, column=0, columnspan=3, pady=15)
        
        tk.Button(
            btn_frame,
            text="Save & Connect" if self.is_setup else "Connect",
            command=self.on_ok,
            bg="#27ae60",
            fg="white",
            font=("Arial", 10, "bold"),
            width=15,
            cursor="hand2"
        ).pack(side=tk.LEFT, padx=5)
        
        tk.Button(
            btn_frame,
            text="Cancel",
            command=self.on_cancel,
            bg="#95a5a6",
            fg="white",
            font=("Arial", 10),
            width=15,
            cursor="hand2"
        ).pack(side=tk.LEFT, padx=5)
    
    def on_ok(self):
        host = self.host_entry.get().strip()
        master = self.master_entry.get()
        
        if not host or not master:
            messagebox.showerror("Error", "Host and master password are required!", parent=self)
            return
        
        if self.is_setup:
            confirm = self.master_confirm.get()
            if master != confirm:
                messagebox.showerror("Error", "Master passwords don't match!", parent=self)
                return
        
        token_id = self.token_id_entry.get().strip()
        token_secret = self.token_secret_entry.get()
        
        if not token_id or not token_secret:
            messagebox.showerror("Error", "Token ID and Token Secret are required!", parent=self)
            return
        
        # Always return token authentication
        self.result = ('token', host, None, None, token_id, token_secret, master)
        
        self.destroy()
    
    def on_cancel(self):
        self.result = None
        self.destroy()


class ProxmoxDashboard:
    """Main Dashboard Application - Enhanced with Full Metrics and Node Temperature Monitoring"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("Proxmox Dashboard - Live Feed")
        self.root.geometry("1600x900")
        self.root.resizable(True, True)
        
        self.root.update_idletasks()
        x = (self.root.winfo_screenwidth() // 2) - 800
        y = (self.root.winfo_screenheight() // 2) - 450
        self.root.geometry(f"1600x900+{x}+{y}")
        
        self.api = None
        self.auto_refresh = True
        self.refresh_thread = None
        self.health_check_thread = None
        self.vm_data = []
        self.filtered_vm_data = []
        self.search_query = ""
        self.is_loading = False
        self.task_queue = queue.Queue()
        self.connection_healthy = False
        self.node_count = 0
        
        # Node temperature storage (NEW - from smaller script)
        self.node_temp_labels = {}
        self.node_temp_api_available = {}
        self.node_addresses = {}  # Maps node names to IP addresses for temperature API
        
        self.setup_styles()
        self.create_widgets()
        
        # Add cleanup handler for window close
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        if not self.authenticate():
            self.root.destroy()
            return
        
        # Start task processor FIRST (before any async operations)
        self.start_task_processor()
        
        # Check temperature API availability on nodes (runs async, non-blocking)
        self.check_temperature_api_status()
        
        # Start auto-refresh and health check
        self.start_auto_refresh()
        self.start_health_check()
    
    def setup_styles(self):
        style = ttk.Style()
        style.theme_use('clam')
        
        style.configure("Treeview",
                       background="#ecf0f1",
                       foreground="black",
                       rowheight=30,
                       fieldbackground="#ecf0f1",
                       font=("Arial", 9))
        style.map('Treeview', background=[('selected', '#3498db')])
        
        style.configure("Treeview.Heading",
                       background="#34495e",
                       foreground="white",
                       font=("Arial", 9, "bold"))
    
    def create_led_indicator(self, parent, color="green", size=12):
        """Create a simple LED indicator using Canvas"""
        canvas = tk.Canvas(
            parent,
            width=size,
            height=size,
            bg="#2c3e50",
            highlightthickness=0
        )
        padding = 2
        canvas.led = canvas.create_oval(
            padding, padding,
            size - padding, size - padding,
            fill=color,
            outline=color
        )
        return canvas
    
    def update_led_color(self, canvas, color):
        """Update LED indicator color"""
        canvas.itemconfig(canvas.led, fill=color, outline=color)
    
    def create_status_badge(self, parent, text, status):
        """Create a colored status badge"""
        colors = {
            "running": {"bg": "#27ae60", "fg": "white"},
            "stopped": {"bg": "#e74c3c", "fg": "white"},
            "paused": {"bg": "#f39c12", "fg": "white"},
            "unknown": {"bg": "#95a5a6", "fg": "white"}
        }
        
        style = colors.get(status.lower(), colors["unknown"])
        
        label = tk.Label(
            parent,
            text=text.upper(),
            bg=style["bg"],
            fg=style["fg"],
            font=("Arial", 8, "bold"),
            padx=8,
            pady=3,
            relief=tk.FLAT
        )
        return label
    
    def get_temp_color(self, temp):
        """Get color for temperature"""
        if temp is None:
            return "#95a5a6"  # Gray for N/A
        elif temp < 50:
            return "#27ae60"  # Green - Cool
        elif temp < 70:
            return "#3498db"  # Blue - Normal
        elif temp < 85:
            return "#f39c12"  # Orange - Warm
        else:
            return "#e74c3c"  # Red - Hot
    
    # ========================================================================
    # NODE TEMPERATURE API MONITORING (NEW - MODIFIED WITH DEBUG LOGGING)
    # ========================================================================
    
    def check_temperature_api_status(self):
        """
        Check which nodes have temperature API available.
        This runs in a background thread to avoid blocking the UI.
        Connects directly to port 8899 on each node.
        """
        if not self.api:
            return
        
        def check_async():
            try:
                nodes = self.api.get('/nodes')
                
                # For single-node setups, use the API host
                # For clusters, try to get node IPs from /cluster/status
                try:
                    cluster_status = self.api.get('/cluster/status')
                    for item in cluster_status:
                        if item.get('type') == 'node' and item.get('ip'):
                            self.node_addresses[item['name']] = item['ip']
                except Exception:
                    pass  # Single-node setup or cluster API unavailable
                
                # Default any missing nodes to API host
                for node in nodes:
                    node_name = node['node']
                    if node_name not in self.node_addresses:
                        self.node_addresses[node_name] = self.api.host
                
                # Check all nodes in parallel using ThreadPoolExecutor
                from concurrent.futures import ThreadPoolExecutor, as_completed
                
                def check_node(node_name):
                    try:
                        result = self._get_node_temperature_direct(node_name, timeout=1.5)
                        return node_name, (result and result.get('status') == 'ok')
                    except Exception:
                        return node_name, False
                
                with ThreadPoolExecutor(max_workers=min(len(nodes), 5)) as executor:
                    futures = {executor.submit(check_node, node['node']): node['node'] for node in nodes}
                    
                    for future in as_completed(futures, timeout=5):
                        try:
                            node_name, available = future.result()
                            self.node_temp_api_available[node_name] = available
                            if available:
                                logger.info(f"Temperature API available on {node_name} ({self.node_addresses.get(node_name)}:8899)")
                            else:
                                logger.debug(f"Temperature API not available on {node_name}")
                        except Exception as e:
                            node_name = futures[future]
                            self.node_temp_api_available[node_name] = False
                
                available_count = sum(1 for v in self.node_temp_api_available.values() if v)
                
                if available_count == 0:
                    logger.info("Temperature API not installed on any nodes (this is optional)")
                else:
                    logger.info(f"Temperature API available on {available_count}/{len(nodes)} nodes")
            
            except Exception as e:
                logger.error(f"Failed to check temperature API status: {e}")
        
        # Run in background thread
        thread = threading.Thread(target=check_async, daemon=True)
        thread.start()
    
    def _get_node_temperature_direct(self, node_name, timeout=2):
        """
        Get temperature directly from node's port 8899.
        Returns None if service not available or timeout.
        """
        try:
            node_ip = self.node_addresses.get(node_name, self.api.host)
            url = f"http://{node_ip}:8899/temperature"
            response = requests.get(url, timeout=timeout)
            
            if response.status_code == 200:
                data = response.json()
                return data.get('data', {})
            return None
        except (requests.Timeout, requests.ConnectionError, requests.RequestException):
            return None
        except Exception:
            return None
    
    def get_all_node_temperatures(self):
        """
        Get temperature from all nodes via Proxmox API.
        Uses short timeout, skips unavailable nodes, runs checks in parallel.
        
        Returns dict of {node_name: {temp, source, status}}
        """
        if not self.api:
            return {}
        
        node_temps = {}
        
        try:
            nodes = self.api.get('/nodes')
        except Exception as e:
            logger.error(f"Failed to get node list: {e}")
            return {}
        
        # Separate nodes into available and unavailable
        nodes_to_check = []
        for node in nodes:
            node_name = node['node']
            if node_name in self.node_temp_api_available and not self.node_temp_api_available[node_name]:
                node_temps[node_name] = {
                    'temp': None,
                    'source': 'unavailable',
                    'status': 'not_installed'
                }
            else:
                nodes_to_check.append(node_name)
        
        # Query available nodes in parallel
        if nodes_to_check:
            from concurrent.futures import ThreadPoolExecutor, as_completed
            
            def fetch_temp(node_name):
                try:
                    result = self._get_node_temperature_direct(node_name, timeout=1.5)
                    if result and result.get('status') == 'ok':
                        return node_name, {
                            'temp': result.get('temperature'),
                            'source': result.get('source', 'unknown'),
                            'hwmon': result.get('hwmon', 'unknown'),
                            'status': 'ok'
                        }, True
                    return node_name, {
                        'temp': None,
                        'source': 'error',
                        'status': result.get('status', 'unknown_error') if result else 'no_response'
                    }, False
                except Exception:
                    return node_name, {
                        'temp': None,
                        'source': 'unavailable',
                        'status': 'exception'
                    }, False
            
            with ThreadPoolExecutor(max_workers=min(len(nodes_to_check), 5)) as executor:
                futures = {executor.submit(fetch_temp, n): n for n in nodes_to_check}
                
                for future in as_completed(futures, timeout=5):
                    try:
                        node_name, temp_data, available = future.result()
                        node_temps[node_name] = temp_data
                        self.node_temp_api_available[node_name] = available
                    except Exception:
                        node_name = futures[future]
                        node_temps[node_name] = {
                            'temp': None,
                            'source': 'unavailable',
                            'status': 'timeout'
                        }
                        self.node_temp_api_available[node_name] = False
        
        return node_temps
    
    def update_node_temperatures(self):
        """Update all node temperature displays in background thread"""
        if not self.api:
            return
        
        def update_async():
            node_temps = self.get_all_node_temperatures()
            # Schedule UI updates on main thread
            self.root.after(0, lambda: self._update_temp_ui(node_temps))
        
        # Run in background to not block UI
        thread = threading.Thread(target=update_async, daemon=True)
        thread.start()
    
    def _update_temp_ui(self, node_temps):
        """Update temperature UI elements (must run on main thread)"""
        for node_name, temp_info in node_temps.items():
            # Create label if doesn't exist
            if node_name not in self.node_temp_labels:
                label = tk.Label(
                    self.node_temp_frame,
                    font=("Arial", 9, "bold"),
                    bg="#2c3e50"
                )
                label.pack(side=tk.LEFT, padx=8)
                self.node_temp_labels[node_name] = label
            
            # Update display
            label = self.node_temp_labels[node_name]
            temp = temp_info.get('temp')
            
            if temp is not None:
                display_text = f"{node_name}: {temp}°C"
                temp_color = self.get_temp_color(temp)
                label.config(text=display_text, fg=temp_color)
                
                # Add tooltip
                source = temp_info.get('source', 'unknown')
                hwmon = temp_info.get('hwmon', 'unknown')
                node_ip = self.node_addresses.get(node_name, 'unknown')
                tooltip = f"IP: {node_ip}:8899\nSource: {source}\nHwmon: {hwmon}"
                self._bind_tooltip(label, tooltip)
            else:
                label.config(text=f"{node_name}: N/A", fg="#95a5a6")
                status = temp_info.get('status', 'unknown')
                node_ip = self.node_addresses.get(node_name, 'unknown')
                if status in ('no_api_endpoint', 'not_installed'):
                    tooltip = f"IP: {node_ip}:8899\nTemperature API not installed\nRun install-proxmox-temp-api.sh on this node"
                else:
                    tooltip = f"IP: {node_ip}:8899\nTemperature unavailable\nStatus: {status}"
                self._bind_tooltip(label, tooltip)
    
    def _bind_tooltip(self, widget, text):
        """Bind tooltip to widget"""
        def on_enter(event):
            tooltip = tk.Toplevel()
            tooltip.wm_overrideredirect(True)
            tooltip.wm_geometry(f"+{event.x_root+10}+{event.y_root+10}")
            
            label = tk.Label(
                tooltip,
                text=text,
                background="#34495e",
                foreground="#ecf0f1",
                relief=tk.SOLID,
                borderwidth=1,
                font=("Arial", 8),
                justify=tk.LEFT,
                padx=5,
                pady=3
            )
            label.pack()
            
            widget._tooltip = tooltip
        
        def on_leave(event):
            if hasattr(widget, '_tooltip'):
                widget._tooltip.destroy()
                del widget._tooltip
        
        # Remove old bindings
        widget.unbind("<Enter>")
        widget.unbind("<Leave>")
        
        # Add new bindings
        widget.bind("<Enter>", on_enter)
        widget.bind("<Leave>", on_leave)
    
    # ========================================================================
    # END NODE TEMPERATURE API MONITORING
    # ========================================================================
    
    def create_widgets(self):
        # Top bar
        top_frame = tk.Frame(self.root, bg="#2c3e50", height=140)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)
        
        # Left section: Title
        title_label = tk.Label(
            top_frame,
            text="Proxmox VM/Container Dashboard",
            font=("Arial", 18, "bold"),
            bg="#2c3e50",
            fg="white"
        )
        title_label.pack(side=tk.LEFT, padx=20, pady=50)
        
        # Right section: Status indicators (pack first to anchor right side)
        self.status_frame = tk.Frame(top_frame, bg="#2c3e50")
        self.status_frame.pack(side=tk.RIGHT, padx=20, pady=10)
        
        # Center section: VM Summary (fills remaining space and centers content)
        vm_summary_container = tk.Frame(top_frame, bg="#2c3e50")
        vm_summary_container.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Inner frame for VM summary (centered within container)
        vm_summary_frame = tk.Frame(vm_summary_container, bg="#2c3e50")
        vm_summary_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # VMs/CTs: label
        summary_title = tk.Label(
            vm_summary_frame,
            text="VMs/CTs:",
            font=("Arial", 12, "bold"),
            bg="#2c3e50",
            fg="#ecf0f1"
        )
        summary_title.pack(pady=(0, 5))
        
        # Running count with green indicator
        running_summary_frame = tk.Frame(vm_summary_frame, bg="#2c3e50")
        running_summary_frame.pack(pady=2)
        
        self.running_led = self.create_led_indicator(running_summary_frame, "#27ae60", size=8)
        self.running_led.pack(side=tk.LEFT, padx=(0, 5))
        
        self.running_count_label = tk.Label(
            running_summary_frame,
            text="Running: 0",
            font=("Arial", 10),
            bg="#2c3e50",
            fg="#27ae60"
        )
        self.running_count_label.pack(side=tk.LEFT)
        
        # Stopped count with red indicator
        stopped_summary_frame = tk.Frame(vm_summary_frame, bg="#2c3e50")
        stopped_summary_frame.pack(pady=2)
        
        self.stopped_led = self.create_led_indicator(stopped_summary_frame, "#e74c3c", size=8)
        self.stopped_led.pack(side=tk.LEFT, padx=(0, 5))
        
        self.stopped_count_label = tk.Label(
            stopped_summary_frame,
            text="Stopped: 0",
            font=("Arial", 10),
            bg="#2c3e50",
            fg="#e74c3c"
        )
        self.stopped_count_label.pack(side=tk.LEFT)
        
        # Row 0: Connection and LIVE status
        connection_frame = tk.Frame(self.status_frame, bg="#2c3e50")
        connection_frame.grid(row=0, column=0, sticky="w", padx=5, pady=3)
        
        self.connection_led = self.create_led_indicator(connection_frame, "#27ae60")
        self.connection_led.pack(side=tk.LEFT, padx=(0, 5))
        
        self.connection_label = tk.Label(
            connection_frame,
            text="Connected",
            font=("Arial", 10, "bold"),
            bg="#2c3e50",
            fg="#27ae60"
        )
        self.connection_label.pack(side=tk.LEFT)
        
        live_frame = tk.Frame(self.status_frame, bg="#2c3e50")
        live_frame.grid(row=0, column=1, sticky="w", padx=15, pady=3)
        
        self.live_led = self.create_led_indicator(live_frame, "#27ae60")
        self.live_led.pack(side=tk.LEFT, padx=(0, 5))
        
        self.live_indicator = tk.Label(
            live_frame,
            text="LIVE",
            font=("Arial", 10, "bold"),
            bg="#2c3e50",
            fg="#27ae60"
        )
        self.live_indicator.pack(side=tk.LEFT)
        
        # Row 1: SSL and Nodes
        ssl_frame = tk.Frame(self.status_frame, bg="#2c3e50")
        ssl_frame.grid(row=1, column=0, sticky="w", padx=5, pady=3)
        
        self.ssl_label = tk.Label(
            ssl_frame,
            text="SSL: Checking...",
            font=("Arial", 10),
            bg="#2c3e50",
            fg="white"
        )
        self.ssl_label.pack()
        
        nodes_frame = tk.Frame(self.status_frame, bg="#2c3e50")
        nodes_frame.grid(row=1, column=1, sticky="w", padx=15, pady=3)
        
        self.node_label = tk.Label(
            nodes_frame,
            text="Nodes: 0",
            font=("Arial", 10),
            bg="#2c3e50",
            fg="white"
        )
        self.node_label.pack()
        
        # Row 2: Last update
        update_frame = tk.Frame(self.status_frame, bg="#2c3e50")
        update_frame.grid(row=2, column=0, sticky="w", padx=5, pady=3, columnspan=2)
        
        self.last_update_label = tk.Label(
            update_frame,
            text="Updated: --",
            font=("Arial", 9),
            bg="#2c3e50",
            fg="#bdc3c7"
        )
        self.last_update_label.pack()
        
        # NEW: Node Temperature Frame (below the top bar)
        self.node_temp_container = tk.Frame(self.root, bg="#34495e", height=35)
        self.node_temp_container.pack(fill=tk.X)
        self.node_temp_container.pack_propagate(False)
        
        self.node_temp_frame = tk.Frame(self.node_temp_container, bg="#34495e")
        self.node_temp_frame.pack(side=tk.LEFT, padx=10, pady=5)
        
        tk.Label(
            self.node_temp_frame,
            text="Node Temps:",
            font=("Arial", 9, "bold"),
            bg="#34495e",
            fg="#bdc3c7"
        ).pack(side=tk.LEFT, padx=(0, 10))
        
        # Control panel
        control_frame = tk.Frame(self.root, bg="#ecf0f1", height=80)
        control_frame.pack(fill=tk.X)
        control_frame.pack_propagate(False)
        
        btn_container = tk.Frame(control_frame, bg="#ecf0f1")
        btn_container.pack(pady=15)
        
        self.start_btn = tk.Button(
            btn_container,
            text="Start",
            command=self.start_selected,
            bg="#27ae60",
            fg="white",
            font=("Arial", 11, "bold"),
            width=12,
            height=2,
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        )
        self.start_btn.pack(side=tk.LEFT, padx=5)
        
        self.stop_btn = tk.Button(
            btn_container,
            text="Stop",
            command=self.stop_selected,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 11, "bold"),
            width=12,
            height=2,
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        )
        self.stop_btn.pack(side=tk.LEFT, padx=5)
        
        tk.Button(
            btn_container,
            text="Refresh",
            command=self.refresh_data_async,
            bg="#3498db",
            fg="white",
            font=("Arial", 11, "bold"),
            width=12,
            height=2,
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        ).pack(side=tk.LEFT, padx=5)
        
        tk.Button(
            btn_container,
            text="Start All",
            command=self.start_all_stopped,
            bg="#16a085",
            fg="white",
            font=("Arial", 11, "bold"),
            width=12,
            height=2,
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        ).pack(side=tk.LEFT, padx=5)
        
        tk.Button(
            btn_container,
            text="Change Credentials",
            command=self.change_credentials,
            bg="#9b59b6",
            fg="white",
            font=("Arial", 10, "bold"),
            width=15,
            height=2,
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        ).pack(side=tk.LEFT, padx=5)
        
        # Live feed controls
        live_controls = tk.Frame(btn_container, bg="#ecf0f1")
        live_controls.pack(side=tk.LEFT, padx=15)
        
        self.auto_refresh_var = tk.BooleanVar(value=True)
        self.pause_resume_btn = tk.Button(
            live_controls,
            text="Pause Live",
            command=self.toggle_auto_refresh,
            bg="#e67e22",
            fg="white",
            font=("Arial", 10, "bold"),
            width=12,
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        )
        self.pause_resume_btn.pack(side=tk.LEFT, padx=5)
        
        # Refresh rate selector
        rate_frame = tk.Frame(live_controls, bg="#ecf0f1")
        rate_frame.pack(side=tk.LEFT, padx=10)
        
        tk.Label(
            rate_frame,
            text="Update every:",
            font=("Arial", 9),
            bg="#ecf0f1"
        ).pack(side=tk.LEFT)
        
        self.refresh_rate_var = tk.IntVar(value=REFRESH_INTERVAL)
        rate_options = [("2s", 2), ("3s", 3), ("5s", 5), ("10s", 10), ("30s", 30)]
        
        for text, value in rate_options:
            rb = tk.Radiobutton(
                rate_frame,
                text=text,
                variable=self.refresh_rate_var,
                value=value,
                command=self.update_refresh_rate,
                font=("Arial", 9),
                bg="#ecf0f1",
                selectcolor="#3498db"
            )
            rb.pack(side=tk.LEFT, padx=2)
        
        # Search bar
        search_frame = tk.Frame(self.root, bg="#ecf0f1", height=40)
        search_frame.pack(fill=tk.X)
        search_frame.pack_propagate(False)
        
        tk.Label(
            search_frame,
            text="Search:",
            font=("Arial", 10),
            bg="#ecf0f1"
        ).pack(side=tk.LEFT, padx=10)
        
        self.search_entry = tk.Entry(search_frame, font=("Arial", 10), width=30)
        self.search_entry.pack(side=tk.LEFT, padx=5)
        self.search_entry.bind('<KeyRelease>', self.filter_vms)
        
        tk.Label(
            search_frame,
            text="Filter by ID, Name, Type, Status, Node",
            font=("Arial", 9),
            bg="#ecf0f1",
            fg="#7f8c8d"
        ).pack(side=tk.LEFT, padx=10)
        
        # Table with scrollbars
        table_container = tk.Frame(self.root)
        table_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Create scrollbars
        vsb = ttk.Scrollbar(table_container, orient="vertical")
        hsb = ttk.Scrollbar(table_container, orient="horizontal")
        
        # Basic columns
        columns = (
            "ID", "Type", "Status", "Name", "Node", 
            "Cores", "Sockets", "CPU", "Memory", "Disk", "Free Disk", "Free%"
        )
        
        self.tree = ttk.Treeview(
            table_container,
            columns=columns,
            show="tree headings",
            yscrollcommand=vsb.set,
            xscrollcommand=hsb.set,
            selectmode="browse",
            height=12
        )
        
        # Connect scrollbars to tree
        vsb.config(command=self.tree.yview)
        hsb.config(command=self.tree.xview)
        
        self.tree.column("#0", width=0, stretch=tk.NO)
        
        # Column widths (increased for better visibility and earlier scrollbar activation)
        column_widths = {
            "ID": 80, "Type": 80, "Status": 110, "Name": 300, "Node": 150,
            "Cores": 100, "Sockets": 110, "CPU": 180, "Memory": 250,
            "Disk": 150, "Free Disk": 150, "Free%": 110
        }
        
        for col in columns:
            width = column_widths.get(col, 80)
            self.tree.column(col, width=width, anchor="center")
            self.tree.heading(col, text=col, anchor="center")
        
        # Configure colored tags for status highlighting
        self.tree.tag_configure("running", background="#d5f4e6", foreground="#27ae60")
        self.tree.tag_configure("stopped", background="#fadbd8", foreground="#e74c3c")
        self.tree.tag_configure("paused", background="#fef5e7", foreground="#f39c12")
        self.tree.tag_configure("unknown", background="#ecf0f1", foreground="#95a5a6")
        
        # Use grid layout for proper scrollbar positioning
        self.tree.grid(row=0, column=0, sticky="nsew")
        vsb.grid(row=0, column=1, sticky="ns")
        hsb.grid(row=1, column=0, sticky="ew")
        
        # Configure grid weights so tree expands
        table_container.grid_rowconfigure(0, weight=1)
        table_container.grid_columnconfigure(0, weight=1)
        
        self.tree.bind("<<TreeviewSelect>>", self.on_select)
        
        # Status bar
        status_bar = tk.Frame(self.root, bg="#34495e", height=30)
        status_bar.pack(fill=tk.X)
        status_bar.pack_propagate(False)
        
        self.status_label = tk.Label(
            status_bar,
            text="Ready",
            font=("Arial", 9),
            bg="#34495e",
            fg="white",
            anchor="w"
        )
        self.status_label.pack(side=tk.LEFT, padx=10, fill=tk.X, expand=True)
    
    def authenticate(self):
        """Handle authentication - API Token Only"""
        
        if os.path.exists(CREDENTIALS_FILE):
            while True:
                master_password = simpledialog.askstring(
                    "Master Password",
                    "Enter your master password:",
                    show='*',
                    parent=self.root
                )
                
                if master_password is None:
                    return False
                
                # Try to decrypt credentials
                try:
                    creds = CredentialManager.load_credentials(master_password)
                except Exception as decrypt_error:
                    logger.error(f"Failed to decrypt credentials: {str(decrypt_error)}")
                    messagebox.showerror(
                        "Decryption Error", 
                        f"Failed to decrypt credentials:\n{str(decrypt_error)}\n\n"
                        "Please check your master password."
                    )
                    continue  # Ask for password again
                
                if not creds:
                    messagebox.showerror("Error", "No credentials found in file.")
                    continue
                
                # Credentials decrypted successfully, now try to authenticate
                try:
                    self.api = ProxmoxAPI(
                        creds['host'],
                        token_id=creds['token_id'],
                        token_secret=creds['token_secret']
                    )
                    
                    self.status_label.config(text=f"Connected to {creds['host']}")
                    self.ssl_label.config(text=f"SSL: {self.api.ssl_status}")
                    self.connection_healthy = True
                    logger.info(f"Successfully authenticated to {creds['host']}")
                    return True
                
                except Exception as auth_error:
                    # Authentication failed - token might be revoked or invalid
                    logger.error(f"Authentication failed with stored credentials: {str(auth_error)}")
                    
                    # Ask user what to do
                    response = messagebox.askyesno(
                        "Authentication Failed",
                        f"Failed to authenticate with stored credentials:\n\n{str(auth_error)}\n\n"
                        "The API token may have been revoked or is invalid.\n\n"
                        "Would you like to delete the old credentials and set up new ones?",
                        icon='warning'
                    )
                    
                    if response:
                        # Delete old credentials and go to setup
                        try:
                            os.remove(CREDENTIALS_FILE)
                            logger.info("Deleted invalid credentials file")
                        except Exception as e:
                            logger.error(f"Failed to delete credentials file: {e}")
                        
                        messagebox.showinfo(
                            "Credentials Deleted",
                            "Old credentials have been deleted.\n\n"
                            "You will now be guided through setting up new credentials."
                        )
                        break  # Exit the while loop and go to setup flow
                    else:
                        # User chose not to delete, ask for password again
                        continue
        
        # No credentials file exists OR user deleted it - show setup flow
        messagebox.showinfo(
            "Setup Required", 
            "No credentials found.\n\n"
            "You'll need to create an API token in Proxmox first.\n\n"
            "The next screen will show you how."
        )
        guide = TokenCreationGuide(self.root)
        self.root.wait_window(guide)
        
        # Now show credentials entry
        dialog = CredentialsDialog(self.root, is_setup=True)
        self.root.wait_window(dialog)
        
        if dialog.result:
            auth_type, host, user, password, token_id, token_secret, master = dialog.result
            try:
                # Try to authenticate with new credentials
                self.api = ProxmoxAPI(host, token_id=token_id, token_secret=token_secret)
                CredentialManager.save_credentials(host, master, token_id, token_secret)
                
                messagebox.showinfo("Success", "Credentials saved successfully!")
                self.status_label.config(text=f"Connected to {host}")
                self.ssl_label.config(text=f"SSL: {self.api.ssl_status}")
                self.connection_healthy = True
                logger.info(f"Successfully set up connection to {host}")
                return True
            except Exception as e:
                logger.error(f"Connection setup failed: {str(e)}")
                messagebox.showerror("Error", f"Connection failed:\n{str(e)}")
                return False
        
        return False
    
    def start_task_processor(self):
        """Process async tasks"""
        def process_tasks():
            while True:
                try:
                    task = self.task_queue.get(timeout=1)
                    if task:
                        func, args, callback = task
                        try:
                            result = func(*args)
                            if callback:
                                self.root.after(0, lambda r=result: callback(r, None))
                        except Exception as e:
                            if callback:
                                self.root.after(0, lambda er=e: callback(None, er))
                except queue.Empty:
                    continue
                except Exception as e:
                    logger.error(f"Task processor error: {e}")
                    break
        
        task_thread = threading.Thread(target=process_tasks, daemon=True)
        task_thread.start()
    
    def run_async(self, func, args=(), callback=None):
        """Run function asynchronously"""
        self.task_queue.put((func, args, callback))
    
    def show_loading(self, message="Loading..."):
        """Show loading indicator"""
        self.is_loading = True
        self.status_label.config(text=f"[Loading] {message}")
        self.root.config(cursor="watch")
    
    def hide_loading(self):
        """Hide loading indicator"""
        self.is_loading = False
        self.root.config(cursor="")
    
    def start_health_check(self):
        """Start connection health check"""
        def health_check_loop():
            while True:
                time.sleep(60)
                try:
                    if self.api:
                        self.api.get('/version')
                        self.connection_healthy = True
                        self.root.after(0, lambda: [
                            self.connection_label.config(text="Connected", fg="#27ae60"),
                            self.update_led_color(self.connection_led, "#27ae60")
                        ])
                except Exception:
                    self.connection_healthy = False
                    self.root.after(0, lambda: [
                        self.connection_label.config(text="Disconnected", fg="#e74c3c"),
                        self.update_led_color(self.connection_led, "#e74c3c")
                    ])
                    self.root.after(0, self.attempt_reconnect)
        
        self.health_check_thread = threading.Thread(target=health_check_loop, daemon=True)
        self.health_check_thread.start()
    
    def attempt_reconnect(self):
        """Attempt reconnection"""
        if self.is_loading:
            return
        
        response = messagebox.askyesno(
            "Connection Lost",
            "Connection to Proxmox was lost. Attempt to reconnect?"
        )
        
        if response:
            self.show_loading("Reconnecting...")
            
            def try_reconnect():
                try:
                    self.api.get('/version')
                    return True
                except Exception:
                    return False
            
            def reconnect_callback(success, error):
                self.hide_loading()
                if success:
                    messagebox.showinfo("Success", "Reconnected successfully!")
                    self.refresh_data_async()
                else:
                    messagebox.showerror("Error", "Reconnection failed. Please restart the application.")
            
            self.run_async(try_reconnect, callback=reconnect_callback)
    
    def filter_vms(self, event=None):
        """Filter VMs based on search query"""
        query = self.search_entry.get().lower()
        
        # Save current selection (VM ID) before clearing
        selected_vm_id = None
        selected_items = self.tree.selection()
        if selected_items:
            try:
                selected_values = self.tree.item(selected_items[0])['values']
                if selected_values:
                    selected_vm_id = selected_values[0]  # VM ID is first column
            except (IndexError, KeyError):
                pass
        
        # Faster bulk delete
        self.tree.delete(*self.tree.get_children())
        
        # Count statuses for summary
        running_count = 0
        stopped_count = 0
        
        self.filtered_vm_data = []
        item_to_select = None
        
        for vm in self.vm_data:
            if (query in str(vm.get('id', '')).lower() or
                query in vm.get('name', '').lower() or
                query in vm.get('type', '').lower() or
                query in vm.get('status', '').lower() or
                query in vm.get('node', '').lower()):
                self.filtered_vm_data.append(vm)
                
                # Determine status tag
                status = vm['status'].lower()
                if status == 'running':
                    tags = ('running',)
                    running_count += 1
                elif status == 'stopped':
                    tags = ('stopped',)
                    stopped_count += 1
                elif status == 'paused':
                    tags = ('paused',)
                else:
                    tags = ('unknown',)
                
                item = self.tree.insert('', 'end', values=(
                    vm['id'], vm['type'], vm['status'], vm['name'], vm['node'],
                    vm.get('cores', 'N/A'), vm.get('sockets', 'N/A'), vm.get('cpu', 'N/A'),
                    vm.get('memory', 'N/A'), vm.get('disk', 'N/A'),
                    vm.get('free_disk', 'N/A'), vm.get('free_pct', 'N/A')
                ), tags=tags)
                
                # Track the item to reselect
                if selected_vm_id is not None and vm['id'] == selected_vm_id:
                    item_to_select = item
        
        # Restore selection if found
        if item_to_select:
            self.tree.selection_set(item_to_select)
            self.tree.see(item_to_select)  # Ensure visible
        
        # Update summary counts
        self.running_count_label.config(text=f"Running: {running_count}")
        self.stopped_count_label.config(text=f"Stopped: {stopped_count}")
        
        if query:
            self.status_label.config(
                text=f"Showing {len(self.filtered_vm_data)} of {len(self.vm_data)} VMs/CTs"
            )
        else:
            self.status_label.config(text=f"Ready - {len(self.vm_data)} VMs/CTs across {self.node_count} node(s)")
    
    def format_bytes(self, bytes_val):
        """Format bytes to human readable (binary units: GiB, MiB, etc)"""
        if not bytes_val or bytes_val == 'N/A':
            return 'N/A'
        try:
            bytes_val = float(bytes_val)
            for unit in ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB']:
                if bytes_val < 1024 or unit == 'PiB':
                    return f"{bytes_val:.1f}{unit}"
                bytes_val /= 1024
        except (ValueError, TypeError):
            return 'N/A'
    
    def fetch_single_vm_data(self, node, vm, vm_type):
        """Fetch basic data for a single VM/CT"""
        try:
            n = node['node']
            endpoint = 'qemu' if vm_type == 'VM' else 'lxc'
            vmid = vm['vmid']
            
            # Get config only
            cfg = self.api.get(f'/nodes/{n}/{endpoint}/{vmid}/config')
            
            # Basic info
            cores = cfg.get('cores', 'N/A')
            
            # Memory - STATIC CONFIG VALUES ONLY (not real-time)
            if vm_type == 'VM':
                # For VMs: Show minmem-maxmem (from balloon configuration)
                memory_val = cfg.get('memory', 0)
                if 'balloon' in cfg:
                    minmem = int(cfg.get('balloon', memory_val))
                    maxmem = int(cfg.get('memory', memory_val))
                    if minmem > 0 and maxmem > 0:
                        minmem_str = self.format_bytes(minmem * 1024 * 1024)
                        maxmem_str = self.format_bytes(maxmem * 1024 * 1024)
                        memory = f"{minmem_str}-{maxmem_str}"
                    else:
                        memory = self.format_bytes(memory_val * 1024 * 1024) if memory_val else 'N/A'
                else:
                    memory = self.format_bytes(memory_val * 1024 * 1024) if memory_val else 'N/A'
            else:  # CT
                memory_mb = int(cfg.get('memory', 0))
                swap_mb = int(cfg.get('swap', 0))
                if memory_mb > 0:
                    mem_str = self.format_bytes(memory_mb * 1024 * 1024)
                    if swap_mb > 0:
                        swap_str = self.format_bytes(swap_mb * 1024 * 1024)
                        memory = f"{mem_str}-{swap_str}"
                    else:
                        memory = mem_str
                else:
                    memory = 'N/A'
            
            # Disk size
            total_disk = 'N/A'
            if vm_type == 'VM':
                for key in sorted(cfg.keys()):
                    if key.startswith(('scsi0', 'sata0', 'ide0', 'virtio0')):
                        value = str(cfg[key])
                        if 'size=' in value:
                            size_str = value.split('size=')[1].split(',')[0].strip()
                            if size_str.endswith('G'):
                                total_disk = f"{size_str[:-1]}GiB"
                            break
            else:  # CT
                rootfs = cfg.get('rootfs', '')
                if 'size=' in str(rootfs):
                    size_str = str(rootfs).split('size=')[1].split(',')[0].strip()
                    if size_str.endswith('G'):
                        total_disk = f"{size_str[:-1]}GiB"
            
            # Free disk and Free% - REAL-TIME DISK VALUES (only if running)
            free_disk = 'N/A'
            free_pct = 'N/A'
            if vm['status'] == 'running':
                try:
                    if vm_type == 'VM':
                        try:
                            fsinfo = self.api.get(f'/nodes/{n}/qemu/{vmid}/agent/get-fsinfo')
                            
                            if 'result' in fsinfo and fsinfo['result']:
                                filesystems = fsinfo['result']
                                
                                excluded_types = ['iso9660', 'udf', 'tmpfs', 'devtmpfs']
                                included_mountpoints = ['/', '/boot', '/home', '/var', '/tmp', '/usr']
                                
                                total_bytes_sum = 0
                                used_bytes_sum = 0
                                
                                for fs in filesystems:
                                    fs_type = fs.get('type', '').lower()
                                    mountpoint = fs.get('mountpoint', '')
                                    
                                    if fs_type in excluded_types:
                                        continue
                                    
                                    if mountpoint not in included_mountpoints:
                                        continue
                                    
                                    if 'total-bytes' in fs and 'used-bytes' in fs:
                                        fs_total = fs.get('total-bytes', 0)
                                        fs_used = fs.get('used-bytes', 0)
                                        
                                        if fs_total > 0:
                                            total_bytes_sum += fs_total
                                            used_bytes_sum += fs_used
                                
                                if total_bytes_sum > 0:
                                    free_bytes = total_bytes_sum - used_bytes_sum
                                    if free_bytes >= 0:
                                        free_disk = self.format_bytes(free_bytes)
                                        free_pct = f"{(free_bytes / total_bytes_sum * 100):.1f}%"
                        
                        except Exception as e:
                            logger.debug(f"Guest agent not available for VM {vmid}, using status method: {e}")
                            stat = self.api.get(f'/nodes/{n}/qemu/{vmid}/status/current')
                            disk_used = stat.get('disk', 0)
                            disk_max = stat.get('maxdisk', 0)
                            
                            if disk_max > 0 and disk_used >= 0:
                                free_bytes = disk_max - disk_used
                                if free_bytes >= 0:
                                    free_disk = self.format_bytes(free_bytes)
                                    free_pct = f"{(free_bytes / disk_max * 100):.1f}%"
                    
                    else:  # CT
                        stat = self.api.get(f'/nodes/{n}/lxc/{vmid}/status/current')
                        disk_used = stat.get('disk', 0)
                        disk_max = stat.get('maxdisk', 0)
                        
                        if disk_max > 0 and disk_used >= 0:
                            free_bytes = disk_max - disk_used
                            if free_bytes >= 0:
                                free_disk = self.format_bytes(free_bytes)
                                free_pct = f"{(free_bytes / disk_max * 100):.1f}%"
                
                except Exception as e:
                    logger.debug(f"Error getting disk data for {vm_type} {vmid}: {e}")
                    pass
            
            # Additional CPU info
            sockets = cfg.get('sockets', 'N/A') if vm_type == 'VM' else 'N/A'
            cpu_type = cfg.get('cpu', 'N/A') if vm_type == 'VM' else 'N/A'
            
            vm_info = {
                'id': vmid,
                'type': vm_type,
                'status': vm['status'],
                'name': vm['name'],
                'node': n,
                'cores': cores,
                'sockets': sockets,
                'cpu': cpu_type,
                'memory': memory,
                'disk': total_disk,
                'free_disk': free_disk,
                'free_pct': free_pct
            }
            
            return vm_info
            
        except Exception as e:
            logger.error(f"Error getting {vm_type} {vm['vmid']}: {e}")
            return None
    
    def refresh_data_async(self):
        """Refresh data asynchronously with parallel processing"""
        if self.is_loading:
            return
        
        self.show_loading("Fetching data from Proxmox...")
        
        def fetch_data():
            return self._fetch_vm_data_parallel()
        
        def update_ui(result, error):
            self.hide_loading()
            if error:
                self.status_label.config(text=f"Error: {str(error)}")
                self.connection_label.config(text="Disconnected", fg="#e74c3c")
                self.update_led_color(self.connection_led, "#e74c3c")
                messagebox.showerror("Error", f"Failed to refresh:\n{str(error)}")
            else:
                self.vm_data = result
                self.filter_vms()
                now = datetime.now().strftime("%H:%M:%S")
                
                if self.auto_refresh:
                    refresh_rate = self.refresh_rate_var.get()
                    self.last_update_label.config(text=f"LIVE - Updated: {now} (every {refresh_rate}s)")
                else:
                    self.last_update_label.config(text=f"Updated: {now} (paused)")
                
                self.connection_label.config(text="Connected", fg="#27ae60")
                self.update_led_color(self.connection_led, "#27ae60")
                
                # Update node temperatures (NEW)
                self.update_node_temperatures()
        
        self.run_async(fetch_data, callback=update_ui)
    
    def _fetch_vm_data_parallel(self):
        """Fetch VM data using simple serial processing"""
        vm_data = []
        nodes = self.api.get('/nodes')
        self.node_count = len(nodes)
        
        # Update node count in UI
        self.root.after(0, lambda: self.node_label.config(text=f"Nodes: {self.node_count}"))
        
        # Count total VMs/CTs first for progress
        total_count = 0
        for node in nodes:
            n = node['node']
            try:
                vms = self.api.get(f'/nodes/{n}/qemu')
                total_count += len(vms)
            except Exception as e:
                logger.error(f"Error counting VMs from node {n}: {e}")
            
            try:
                cts = self.api.get(f'/nodes/{n}/lxc')
                total_count += len(cts)
            except Exception as e:
                logger.error(f"Error counting CTs from node {n}: {e}")
        
        # Process each VM/CT sequentially
        current = 0
        for node in nodes:
            n = node['node']
            
            # Get and process VMs
            try:
                vms = self.api.get(f'/nodes/{n}/qemu')
                for vm in vms:
                    current += 1
                    
                    try:
                        vm_info = self.fetch_single_vm_data(node, vm, 'VM')
                        if vm_info:
                            vm_data.append(vm_info)
                    except Exception as e:
                        logger.error(f"Error getting VM {vm['vmid']}: {e}")
            except Exception as e:
                logger.error(f"Error getting VMs from node {n}: {e}")
            
            # Get and process Containers
            try:
                cts = self.api.get(f'/nodes/{n}/lxc')
                for ct in cts:
                    current += 1
                    
                    try:
                        ct_info = self.fetch_single_vm_data(node, ct, 'CT')
                        if ct_info:
                            vm_data.append(ct_info)
                    except Exception as e:
                        logger.error(f"Error getting CT {ct['vmid']}: {e}")
            except Exception as e:
                logger.error(f"Error getting CTs from node {n}: {e}")
        
        vm_data.sort(key=lambda x: x['id'])
        return vm_data
    
    def on_select(self, event):
        """Handle tree selection"""
        selection = self.tree.selection()
        if not selection:
            return
        
        item = self.tree.item(selection[0])
        values = item['values']
        
        if not values or len(values) < 12:
            return
        
        status = values[2]
        
        if status == 'running':
            self.stop_btn.config(bg="#27ae60", state=tk.NORMAL)
            self.start_btn.config(bg="#e74c3c", state=tk.DISABLED)
        else:
            self.start_btn.config(bg="#27ae60", state=tk.NORMAL)
            self.stop_btn.config(bg="#e74c3c", state=tk.DISABLED)
    
    def get_selected_vm(self):
        """Get selected VM/CT"""
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a VM/CT")
            return None
        
        item = self.tree.item(selection[0])
        values = item['values']
        
        if not values or len(values) < 1:
            messagebox.showerror("Error", "Invalid selection")
            return None
        
        vmid = values[0]
        
        for vm in self.vm_data:
            if vm.get('id') == vmid:
                return vm
        return None
    
    def start_selected(self):
        """Start selected VM/CT"""
        vm = self.get_selected_vm()
        if not vm:
            return
        
        self.show_loading(f"Starting {vm['type']} {vm['id']}...")
        
        def start_vm():
            try:
                endpoint = 'qemu' if vm['type'] == 'VM' else 'lxc'
                self.api.post(f"/nodes/{vm['node']}/{endpoint}/{vm['id']}/status/start")
                AuditLogger.log_vm_action("START", vm['id'], vm['type'], vm['name'], True)
                return True
            except Exception as e:
                AuditLogger.log_vm_action("START", vm['id'], vm['type'], vm['name'], False, str(e))
                raise
        
        def start_callback(success, error):
            self.hide_loading()
            if error:
                messagebox.showerror("Error", f"Failed to start:\n{str(error)}")
            else:
                self.status_label.config(text=f"Started {vm['type']} {vm['id']} ({vm['name']})")
                self.root.after(2000, self.refresh_data_async)
        
        self.run_async(start_vm, callback=start_callback)
    
    def stop_selected(self):
        """Stop selected VM/CT"""
        vm = self.get_selected_vm()
        if not vm:
            return
        
        if not messagebox.askyesno("Confirm", f"Stop {vm['type']} {vm['id']} ({vm['name']})?"):
            return
        
        self.show_loading(f"Stopping {vm['type']} {vm['id']}...")
        
        def stop_vm():
            try:
                endpoint = 'qemu' if vm['type'] == 'VM' else 'lxc'
                self.api.post(f"/nodes/{vm['node']}/{endpoint}/{vm['id']}/status/stop")
                AuditLogger.log_vm_action("STOP", vm['id'], vm['type'], vm['name'], True)
                return True
            except Exception as e:
                AuditLogger.log_vm_action("STOP", vm['id'], vm['type'], vm['name'], False, str(e))
                raise
        
        def stop_callback(success, error):
            self.hide_loading()
            if error:
                messagebox.showerror("Error", f"Failed to stop:\n{str(error)}")
            else:
                self.status_label.config(text=f"Stopped {vm['type']} {vm['id']} ({vm['name']})")
                self.root.after(2000, self.refresh_data_async)
        
        self.run_async(stop_vm, callback=stop_callback)
    
    def change_credentials(self):
        """Allow user to change stored credentials"""
        response = messagebox.askyesno(
            "Change Credentials",
            "This will delete your current credentials and guide you through setting up new ones.\n\n"
            "Continue?",
            icon='warning'
        )
        
        if not response:
            return
        
        # Delete old credentials
        try:
            if os.path.exists(CREDENTIALS_FILE):
                os.remove(CREDENTIALS_FILE)
                logger.info("User requested credential change - deleted old credentials")
        except Exception as e:
            logger.error(f"Failed to delete credentials file: {e}")
            messagebox.showerror("Error", f"Failed to delete credentials:\n{str(e)}")
            return
        
        # Close current API connection
        self.api = None
        self.connection_healthy = False
        
        # Show setup flow
        messagebox.showinfo(
            "Setup New Credentials",
            "You'll need to create a new API token in Proxmox.\n\n"
            "The next screen will show you how."
        )
        
        guide = TokenCreationGuide(self.root)
        self.root.wait_window(guide)
        
        # Show credentials entry
        dialog = CredentialsDialog(self.root, is_setup=True)
        self.root.wait_window(dialog)
        
        if dialog.result:
            auth_type, host, user, password, token_id, token_secret, master = dialog.result
            try:
                # Try to authenticate with new credentials
                self.api = ProxmoxAPI(host, token_id=token_id, token_secret=token_secret)
                CredentialManager.save_credentials(host, master, token_id, token_secret)
                
                messagebox.showinfo("Success", "New credentials saved successfully!\n\nThe dashboard will now refresh.")
                self.status_label.config(text=f"Connected to {host}")
                self.ssl_label.config(text=f"SSL: {self.api.ssl_status}")
                self.connection_healthy = True
                logger.info(f"Successfully changed credentials to {host}")
                
                # Refresh dashboard
                self.refresh_data()
            except Exception as e:
                logger.error(f"Connection setup failed: {str(e)}")
                messagebox.showerror("Error", f"Connection failed:\n{str(e)}\n\nPlease try again.")
                self.connection_healthy = False
        else:
            messagebox.showwarning(
                "Cancelled",
                "Credential change cancelled.\n\n"
                "Your old credentials were already deleted.\n"
                "You'll need to restart the dashboard and set up credentials to continue."
            )
            self.root.quit()

    def start_all_stopped(self):
        """Start all stopped VMs/CTs"""
        stopped = [vm for vm in self.vm_data if vm['status'] != 'running']
        
        if not stopped:
            messagebox.showinfo("Info", "All VMs/CTs are already running")
            return
        
        if not messagebox.askyesno("Confirm", f"Start {len(stopped)} stopped VMs/CTs?"):
            return
        
        self.show_loading(f"Starting {len(stopped)} VMs/CTs...")
        
        def start_all():
            results = []
            for vm in stopped:
                try:
                    endpoint = 'qemu' if vm['type'] == 'VM' else 'lxc'
                    self.api.post(f"/nodes/{vm['node']}/{endpoint}/{vm['id']}/status/start")
                    AuditLogger.log_vm_action("START_ALL", vm['id'], vm['type'], vm['name'], True)
                    results.append((vm['id'], True))
                except Exception as e:
                    AuditLogger.log_vm_action("START_ALL", vm['id'], vm['type'], vm['name'], False, str(e))
                    results.append((vm['id'], False))
            return results
        
        def start_all_callback(results, error):
            self.hide_loading()
            if error:
                messagebox.showerror("Error", f"Failed to start all:\n{str(error)}")
            else:
                success_count = sum(1 for _, success in results if success)
                self.status_label.config(text=f"Started {success_count}/{len(stopped)} VMs/CTs")
                self.root.after(3000, self.refresh_data_async)
        
        self.run_async(start_all, callback=start_all_callback)
    
    def toggle_auto_refresh(self):
        """Toggle live feed"""
        self.auto_refresh = not self.auto_refresh
        self.auto_refresh_var.set(self.auto_refresh)
        
        if self.auto_refresh:
            self.pause_resume_btn.config(
                text="Pause Live",
                bg="#e67e22"
            )
            self.live_indicator.config(
                text="LIVE",
                fg="#27ae60"
            )
            self.update_led_color(self.live_led, "#27ae60")
            self.status_label.config(text="Live feed enabled")
            logger.info("Live feed enabled")
        else:
            self.pause_resume_btn.config(
                text="Resume Live",
                bg="#27ae60"
            )
            self.live_indicator.config(
                text="PAUSED",
                fg="#95a5a6"
            )
            self.update_led_color(self.live_led, "#95a5a6")
            self.status_label.config(text="Live feed paused")
            logger.info("Live feed paused")
    
    def update_refresh_rate(self):
        """Update the refresh rate"""
        new_rate = self.refresh_rate_var.get()
        logger.info(f"Refresh rate changed to {new_rate} seconds")
        self.status_label.config(text=f"Update interval set to {new_rate}s")
    
    def start_auto_refresh(self):
        """Start live feed auto-refresh thread"""
        self.refresh_data_async()
        
        def auto_refresh_loop():
            while True:
                refresh_interval = self.refresh_rate_var.get()
                time.sleep(refresh_interval)
                
                if self.auto_refresh:
                    try:
                        self.root.after(0, self.refresh_data_async)
                    except Exception:
                        break
        
        self.refresh_thread = threading.Thread(target=auto_refresh_loop, daemon=True)
        self.refresh_thread.start()
        logger.info(f"Live feed started with {REFRESH_INTERVAL}s refresh rate")
    
    def on_closing(self):
        """Handle window close event - cleanup resources"""
        self.auto_refresh = False
        time.sleep(0.5)
        self.root.destroy()
    
    def safe_ui_update(self, callback):
        """Safely update UI from background thread"""
        try:
            if self.root.winfo_exists():
                callback()
        except tk.TclError:
            pass


def main():
    root = tk.Tk()
    app = ProxmoxDashboard(root)
    root.mainloop()


if __name__ == '__main__':
    main()
