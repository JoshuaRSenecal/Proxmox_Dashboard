#!/usr/bin/env python3

import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
import requests
import json
import base64
import os
import threading
import time
import queue
import logging
from datetime import datetime, timedelta
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2
import psutil

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.expanduser('~/.proxmox_dashboard.log')),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('ProxmoxDashboard')

# Secure log file permissions (owner read/write only)
LOG_FILE = os.path.expanduser('~/.proxmox_dashboard.log')
if os.path.exists(LOG_FILE):
    os.chmod(LOG_FILE, 0o600)

# Configuration
SALT = b'proxmox_dashboard_salt_v1'
CREDENTIALS_FILE = os.path.expanduser('~/.proxmox_credentials.enc')
PROXMOX_CA_CERT = os.path.expanduser('~/proxmox-ca.pem')
AUDIT_LOG_FILE = os.path.expanduser('~/.proxmox_dashboard_audit.log')
REFRESH_INTERVAL = 3  # seconds - Live data feed (near-constant updates)
MAX_RETRIES = 3
RETRY_DELAY = 2

# SSL Configuration - MANDATORY
if not os.path.exists(PROXMOX_CA_CERT):
    error_msg = f"""
SSL CERTIFICATE REQUIRED

The Proxmox CA certificate is required for secure connections.

Certificate not found at: {PROXMOX_CA_CERT}

To obtain the certificate:
  1. SSH into your Proxmox server
  2. Run: scp root@YOUR_PROXMOX_IP:/etc/pve/pve-root-ca.pem {PROXMOX_CA_CERT}
  
Or manually copy /etc/pve/pve-root-ca.pem from Proxmox to {PROXMOX_CA_CERT}

SSL verification is MANDATORY for security.
Dashboard cannot start without the CA certificate.
"""
    print(error_msg)
    logger.error("SSL Certificate not found - cannot start")
    logger.error(f"Expected location: {PROXMOX_CA_CERT}")
    exit(1)

logger.info(f"SSL Verification: Enabled (using {PROXMOX_CA_CERT})")

class AuditLogger:
    """Audit logger for tracking all critical operations"""
    
    @staticmethod
    def log(action, target, result, details=None):
        try:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_entry = f"{timestamp} | {action:20} | {target:20} | {result:10}"
            if details:
                log_entry += f" | {details}"
            
            with open(AUDIT_LOG_FILE, 'a') as f:
                f.write(log_entry + '\n')
            
            # Secure audit log permissions (owner read/write only)
            if os.path.exists(AUDIT_LOG_FILE):
                os.chmod(AUDIT_LOG_FILE, 0o600)
        except Exception as e:
            logger.error(f"Failed to write audit log: {e}")
    
    @staticmethod
    def log_authentication(host, user, success):
        result = "SUCCESS" if success else "FAILED"
        AuditLogger.log("AUTH", f"{user}@{host}", result)
    
    @staticmethod
    def log_vm_action(action, vmid, vm_type, vm_name, success, error=None):
        result = "SUCCESS" if success else "FAILED"
        target = f"{vm_type} {vmid} ({vm_name})"
        details = f"Error: {error}" if error else None
        AuditLogger.log(action, target, result, details)

class ProxmoxAPI:
    """Proxmox API Client - API Token Authentication Only"""
    
    def __init__(self, host, token_id, token_secret):
        self.base = f"https://{host}:8006/api2/json"
        self.host = host
        
        # SSL verification is MANDATORY
        self.verify = PROXMOX_CA_CERT
        self.ssl_status = "Verified"
        
        # API Token authentication
        self.headers = {'Authorization': f'PVEAPIToken={token_id}={token_secret}'}
        
        # Test authentication
        try:
            self._api_request('get', '/version')
            AuditLogger.log_authentication(host, token_id, True)
            logger.info(f"Successfully authenticated with token: {token_id}")
        except Exception as e:
            AuditLogger.log_authentication(host, token_id, False)
            logger.error(f"API token authentication failed: {str(e)}")
            raise Exception(f"API token authentication failed: {str(e)}")
    
    def _api_request(self, method, path, retries=MAX_RETRIES, **kwargs):
        """Make API request with retry logic - Token authentication only"""
        for attempt in range(retries):
            try:
                if method == 'get':
                    r = requests.get(
                        f"{self.base}{path}",
                        headers=self.headers,
                        verify=self.verify,
                        timeout=10,
                        **kwargs
                    )
                elif method == 'post':
                    r = requests.post(
                        f"{self.base}{path}",
                        headers=self.headers,
                        verify=self.verify,
                        timeout=10,
                        **kwargs
                    )
                
                if r.status_code in [200, 201]:
                    return r
                elif r.status_code >= 500 and attempt < retries - 1:
                    delay = RETRY_DELAY * (2 ** attempt)
                    time.sleep(delay)
                    continue
                else:
                    r.raise_for_status()
                    
            except requests.ConnectionError:
                if attempt == retries - 1:
                    raise Exception(f"Connection failed after {retries} attempts")
                time.sleep(RETRY_DELAY * (2 ** attempt))
            except requests.Timeout:
                if attempt == retries - 1:
                    raise Exception(f"Request timeout after {retries} attempts")
                time.sleep(RETRY_DELAY * (2 ** attempt))
            except Exception as e:
                if attempt == retries - 1:
                    raise
                time.sleep(RETRY_DELAY * (2 ** attempt))
        
        raise Exception(f"API request failed after {retries} attempts")
    
    def get(self, path):
        r = self._api_request('get', path)
        try:
            response_data = r.json()
            if 'data' in response_data:
                return response_data['data']
            else:
                return response_data
        except (ValueError, KeyError, TypeError) as e:
            raise Exception(f"Invalid API response from {path}: {str(e)}")
    
    def post(self, path, data=None):
        kwargs = {'data': data} if data else {}
        return self._api_request('post', path, **kwargs)

class CredentialManager:
    """Manages encrypted credential storage - supports both passwords and API tokens"""
    
    @staticmethod
    def get_key_from_password(password):
        kdf = PBKDF2(
            algorithm=hashes.SHA256(),
            length=32,
            salt=SALT,
            iterations=100000,
        )
        return base64.urlsafe_b64encode(kdf.derive(password.encode()))
    
    @staticmethod
    def save_credentials(host, master_password, token_id, token_secret):
        """Save API token credentials (token authentication only)"""
        try:
            credentials = {
                'host': host,
                'auth_type': 'token',
                'token_id': token_id,
                'token_secret': token_secret
            }
            
            key = CredentialManager.get_key_from_password(master_password)
            cipher = Fernet(key)
            encrypted_data = cipher.encrypt(json.dumps(credentials).encode())
            
            with open(CREDENTIALS_FILE, 'wb') as f:
                f.write(encrypted_data)
            os.chmod(CREDENTIALS_FILE, 0o600)
        except IOError as e:
            raise Exception(f"Failed to save credentials file: {str(e)}")
        except Exception as e:
            raise Exception(f"Failed to encrypt credentials: {str(e)}")
    
    @staticmethod
    def load_credentials(master_password):
        if not os.path.exists(CREDENTIALS_FILE):
            return None
        
        try:
            with open(CREDENTIALS_FILE, 'rb') as f:
                encrypted_data = f.read()
            
            key = CredentialManager.get_key_from_password(master_password)
            cipher = Fernet(key)
            decrypted_data = cipher.decrypt(encrypted_data)
            return json.loads(decrypted_data.decode())
        except IOError as e:
            raise Exception(f"Failed to read credentials file: {str(e)}")
        except Exception as e:
            # Most likely wrong password or corrupted file
            raise Exception("Invalid master password or corrupted credentials file")

class CredentialsDialog(tk.Toplevel):
    """Dialog for entering API token credentials - Token Authentication Only"""
    
    def __init__(self, parent, is_setup=False):
        super().__init__(parent)
        self.title("Setup Credentials" if is_setup else "Enter Credentials")
        self.geometry("500x380")
        self.resizable(False, False)
        self.result = None
        self.is_setup = is_setup
        
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - 250
        y = (self.winfo_screenheight() // 2) - 190
        self.geometry(f"500x380+{x}+{y}")
        
        self.create_widgets()
        self.protocol("WM_DELETE_WINDOW", self.on_cancel)
        self.grab_set()
    
    def create_widgets(self):
        # Title
        title_frame = tk.Frame(self, bg="#2c3e50", height=60)
        title_frame.pack(fill=tk.X)
        title_frame.pack_propagate(False)
        
        title_label = tk.Label(
            title_frame,
            text="Proxmox Dashboard Setup" if self.is_setup else "Unlock Dashboard",
            font=("Arial", 16, "bold"),
            bg="#2c3e50",
            fg="white"
        )
        title_label.pack(pady=15)
        
        # Form frame
        form_frame = tk.Frame(self, bg="white")
        form_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Host
        tk.Label(form_frame, text="Proxmox Host:", font=("Arial", 10), bg="white").grid(row=0, column=0, sticky="w", pady=5)
        self.host_entry = tk.Entry(form_frame, font=("Arial", 10), width=35)
        self.host_entry.grid(row=0, column=1, pady=5, columnspan=2)
        self.host_entry.insert(0, "192.168.1.100")
        
        # Auth type label
        tk.Label(form_frame, text="Authentication: API Token", font=("Arial", 10, "bold"), bg="white", fg="#27ae60").grid(row=1, column=0, sticky="w", pady=10, columnspan=3)
        
        # Token fields
        tk.Label(form_frame, text="Token ID:", font=("Arial", 10), bg="white").grid(row=2, column=0, sticky="w", pady=5)
        self.token_id_entry = tk.Entry(form_frame, font=("Arial", 10), width=35)
        self.token_id_entry.grid(row=2, column=1, pady=5, columnspan=2)
        self.token_id_entry.insert(0, "root@pam!")
        
        tk.Label(form_frame, text="Token Secret:", font=("Arial", 10), bg="white").grid(row=3, column=0, sticky="w", pady=5)
        self.token_secret_entry = tk.Entry(form_frame, font=("Arial", 10), width=35, show="*")
        self.token_secret_entry.grid(row=3, column=1, pady=5, columnspan=2)
        
        tk.Label(
            form_frame,
            text="Create token: Datacenter → Permissions → API Tokens → Add",
            font=("Arial", 8),
            bg="white",
            fg="#7f8c8d"
        ).grid(row=4, column=0, columnspan=3, sticky="w", pady=2)
        
        # Master password
        tk.Label(form_frame, text="Master Password:", font=("Arial", 10, "bold"), bg="white").grid(row=5, column=0, sticky="w", pady=(15, 5))
        self.master_entry = tk.Entry(form_frame, font=("Arial", 10), width=35, show="*")
        self.master_entry.grid(row=5, column=1, pady=(15, 5), columnspan=2)
        
        tk.Label(
            form_frame,
            text="(Used to encrypt credentials locally)",
            font=("Arial", 8),
            bg="white",
            fg="#7f8c8d"
        ).grid(row=6, column=1, sticky="w", columnspan=2)
        
        if self.is_setup:
            tk.Label(form_frame, text="Confirm Master:", font=("Arial", 10), bg="white").grid(row=7, column=0, sticky="w", pady=5)
            self.master_confirm = tk.Entry(form_frame, font=("Arial", 10), width=35, show="*")
            self.master_confirm.grid(row=7, column=1, pady=5, columnspan=2)
        
        # Buttons
        btn_frame = tk.Frame(form_frame, bg="white")
        btn_frame.grid(row=8, column=0, columnspan=3, pady=15)
        
        tk.Button(
            btn_frame,
            text="Save & Connect" if self.is_setup else "Connect",
            command=self.on_ok,
            bg="#27ae60",
            fg="white",
            font=("Arial", 10, "bold"),
            width=15,
            cursor="hand2"
        ).pack(side=tk.LEFT, padx=5)
        
        tk.Button(
            btn_frame,
            text="Cancel",
            command=self.on_cancel,
            bg="#95a5a6",
            fg="white",
            font=("Arial", 10),
            width=15,
            cursor="hand2"
        ).pack(side=tk.LEFT, padx=5)
    
    def on_ok(self):
        host = self.host_entry.get().strip()
        master = self.master_entry.get()
        
        if not host or not master:
            messagebox.showerror("Error", "Host and master password are required!")
            return
        
        if self.is_setup:
            confirm = self.master_confirm.get()
            if master != confirm:
                messagebox.showerror("Error", "Master passwords don't match!")
                return
        
        token_id = self.token_id_entry.get().strip()
        token_secret = self.token_secret_entry.get()
        
        if not token_id or not token_secret:
            messagebox.showerror("Error", "Token ID and Token Secret are required!")
            return
        
        # Always return token authentication
        self.result = ('token', host, None, None, token_id, token_secret, master)
        
        self.destroy()
    
    def on_cancel(self):
        self.result = None
        self.destroy()

class ProxmoxDashboard:
    """Main Dashboard Application - Enhanced with Full Metrics"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("Proxmox Dashboard - Live Feed")
        self.root.geometry("1600x900")
        
        self.root.update_idletasks()
        x = (self.root.winfo_screenwidth() // 2) - 800
        y = (self.root.winfo_screenheight() // 2) - 450
        self.root.geometry(f"1600x900+{x}+{y}")
        
        self.api = None
        self.auto_refresh = True
        self.refresh_thread = None
        self.health_check_thread = None
        self.vm_data = []
        self.filtered_vm_data = []
        self.search_query = ""
        self.is_loading = False
        self.task_queue = queue.Queue()
        self.connection_healthy = False
        self.node_count = 0
        
        self.setup_styles()
        self.create_widgets()
        
        # Add cleanup handler for window close
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        if not self.authenticate():
            self.root.destroy()
            return
        
        self.start_auto_refresh()
        self.start_health_check()
        self.start_task_processor()
    
    def setup_styles(self):
        style = ttk.Style()
        style.theme_use('clam')
        
        style.configure("Treeview",
                       background="#ecf0f1",
                       foreground="black",
                       rowheight=30,
                       fieldbackground="#ecf0f1",
                       font=("Arial", 9))
        style.map('Treeview', background=[('selected', '#3498db')])
        
        style.configure("Treeview.Heading",
                       background="#34495e",
                       foreground="white",
                       font=("Arial", 9, "bold"))
    
    def create_led_indicator(self, parent, color="green", size=12):
        """Create a simple LED indicator using Canvas"""
        canvas = tk.Canvas(
            parent,
            width=size,
            height=size,
            bg="#2c3e50",
            highlightthickness=0
        )
        padding = 2
        canvas.led = canvas.create_oval(
            padding, padding,
            size - padding, size - padding,
            fill=color,
            outline=color
        )
        return canvas
    
    def update_led_color(self, canvas, color):
        """Update LED indicator color"""
        canvas.itemconfig(canvas.led, fill=color, outline=color)
    
    def create_status_badge(self, parent, text, status):
        """Create a colored status badge"""
        colors = {
            "running": {"bg": "#27ae60", "fg": "white"},
            "stopped": {"bg": "#e74c3c", "fg": "white"},
            "paused": {"bg": "#f39c12", "fg": "white"},
            "unknown": {"bg": "#95a5a6", "fg": "white"}
        }
        
        style = colors.get(status.lower(), colors["unknown"])
        
        label = tk.Label(
            parent,
            text=text.upper(),
            bg=style["bg"],
            fg=style["fg"],
            font=("Arial", 8, "bold"),
            padx=8,
            pady=3,
            relief=tk.FLAT
        )
        return label
    
    def get_host_temperature(self):
        """Get host laptop/PC temperature"""
        try:
            # Try to get temperature sensors
            temps = psutil.sensors_temperatures()
            
            if not temps:
                return None, "No sensors"
            
            # Priority order for temperature zones
            priority_zones = [
                'coretemp',      # Intel CPU
                'k10temp',       # AMD CPU
                'cpu_thermal',   # ARM/Raspberry Pi
                'acpitz',        # ACPI thermal zone
            ]
            
            # Try priority zones first
            for zone in priority_zones:
                if zone in temps and temps[zone]:
                    # Get average of all sensors in this zone
                    readings = [s.current for s in temps[zone] if s.current]
                    if readings:
                        avg_temp = sum(readings) / len(readings)
                        return round(avg_temp, 1), zone
            
            # Fallback: use first available zone
            for zone_name, sensors in temps.items():
                if sensors:
                    readings = [s.current for s in sensors if s.current]
                    if readings:
                        avg_temp = sum(readings) / len(readings)
                        return round(avg_temp, 1), zone_name
            
            return None, "No readings"
            
        except AttributeError:
            # sensors_temperatures not available on this platform
            return None, "Not supported"
        except Exception as e:
            logger.debug(f"Temperature read error: {e}")
            return None, "Error"
    
    def format_temperature(self, temp, zone):
        """Format temperature for display"""
        if temp is None:
            return "N/A"
        
        # Color based on temperature
        if temp < 50:
            return f"{temp}°C"
        elif temp < 70:
            return f"{temp}°C"
        elif temp < 85:
            return f"{temp}°C"
        else:
            return f"{temp}°C"
    
    def get_temp_color(self, temp):
        """Get color for temperature"""
        if temp is None:
            return "#95a5a6"  # Gray for N/A
        elif temp < 50:
            return "#27ae60"  # Green - Cool
        elif temp < 70:
            return "#3498db"  # Blue - Normal
        elif temp < 85:
            return "#f39c12"  # Orange - Warm
        else:
            return "#e74c3c"  # Red - Hot
    
    def create_widgets(self):
        # Top bar
        top_frame = tk.Frame(self.root, bg="#2c3e50", height=70)
        top_frame.pack(fill=tk.X)
        top_frame.pack_propagate(False)
        
        title_label = tk.Label(
            top_frame,
            text="Proxmox VM/Container Dashboard",
            font=("Arial", 18, "bold"),
            bg="#2c3e50",
            fg="white"
        )
        title_label.pack(side=tk.LEFT, padx=20, pady=15)
        
        # Status indicators
        self.status_frame = tk.Frame(top_frame, bg="#2c3e50")
        self.status_frame.pack(side=tk.RIGHT, padx=20)
        
        # Connection status with LED
        connection_frame = tk.Frame(self.status_frame, bg="#2c3e50")
        connection_frame.pack(pady=2)
        
        self.connection_led = self.create_led_indicator(connection_frame, "#27ae60")
        self.connection_led.pack(side=tk.LEFT, padx=(0, 5))
        
        self.connection_label = tk.Label(
            connection_frame,
            text="Connected",
            font=("Arial", 10),
            bg="#2c3e50",
            fg="#27ae60"
        )
        self.connection_label.pack(side=tk.LEFT)
        
        self.node_label = tk.Label(
            self.status_frame,
            text="Nodes: 0",
            font=("Arial", 10),
            bg="#2c3e50",
            fg="white"
        )
        self.node_label.pack()
        
        self.ssl_label = tk.Label(
            self.status_frame,
            text="SSL: Checking...",
            font=("Arial", 10),
            bg="#2c3e50",
            fg="white"
        )
        self.ssl_label.pack()
        
        # Host temperature indicator
        temp_frame = tk.Frame(self.status_frame, bg="#2c3e50")
        temp_frame.pack(pady=2)
        
        tk.Label(
            temp_frame,
            text="Host Temp:",
            font=("Arial", 9),
            bg="#2c3e50",
            fg="#bdc3c7"
        ).pack(side=tk.LEFT, padx=(0, 5))
        
        self.temp_label = tk.Label(
            temp_frame,
            text="--",
            font=("Arial", 9, "bold"),
            bg="#2c3e50",
            fg="#95a5a6"
        )
        self.temp_label.pack(side=tk.LEFT)
        
        # Live feed indicator with LED
        live_frame = tk.Frame(self.status_frame, bg="#2c3e50")
        live_frame.pack(pady=2)
        
        self.live_led = self.create_led_indicator(live_frame, "#27ae60")
        self.live_led.pack(side=tk.LEFT, padx=(0, 5))
        
        self.live_indicator = tk.Label(
            live_frame,
            text="LIVE",
            font=("Arial", 10, "bold"),
            bg="#2c3e50",
            fg="#27ae60"
        )
        self.live_indicator.pack(side=tk.LEFT)
        
        self.last_update_label = tk.Label(
            self.status_frame,
            text="Last update: --",
            font=("Arial", 9),
            bg="#2c3e50",
            fg="#bdc3c7"
        )
        self.last_update_label.pack()
        
        # VM Summary Panel with visual indicators
        summary_frame = tk.Frame(self.status_frame, bg="#2c3e50")
        summary_frame.pack(pady=(10, 0))
        
        tk.Label(
            summary_frame,
            text="VMs/CTs:",
            font=("Arial", 9, "bold"),
            bg="#2c3e50",
            fg="#bdc3c7"
        ).pack()
        
        # Running count with green indicator
        running_frame = tk.Frame(summary_frame, bg="#2c3e50")
        running_frame.pack(pady=2)
        
        self.running_led = self.create_led_indicator(running_frame, "#27ae60", size=8)
        self.running_led.pack(side=tk.LEFT, padx=(0, 5))
        
        self.running_count_label = tk.Label(
            running_frame,
            text="Running: 0",
            font=("Arial", 9),
            bg="#2c3e50",
            fg="#27ae60"
        )
        self.running_count_label.pack(side=tk.LEFT)
        
        # Stopped count with red indicator
        stopped_frame = tk.Frame(summary_frame, bg="#2c3e50")
        stopped_frame.pack(pady=2)
        
        self.stopped_led = self.create_led_indicator(stopped_frame, "#e74c3c", size=8)
        self.stopped_led.pack(side=tk.LEFT, padx=(0, 5))
        
        self.stopped_count_label = tk.Label(
            stopped_frame,
            text="Stopped: 0",
            font=("Arial", 9),
            bg="#2c3e50",
            fg="#e74c3c"
        )
        self.stopped_count_label.pack(side=tk.LEFT)
        
        # Control panel
        control_frame = tk.Frame(self.root, bg="#ecf0f1", height=80)
        control_frame.pack(fill=tk.X)
        control_frame.pack_propagate(False)
        
        btn_container = tk.Frame(control_frame, bg="#ecf0f1")
        btn_container.pack(pady=15)
        
        self.start_btn = tk.Button(
            btn_container,
            text="Start",
            command=self.start_selected,
            bg="#27ae60",
            fg="white",
            font=("Arial", 11, "bold"),
            width=12,
            height=2,
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        )
        self.start_btn.pack(side=tk.LEFT, padx=5)
        
        self.stop_btn = tk.Button(
            btn_container,
            text="Stop",
            command=self.stop_selected,
            bg="#e74c3c",
            fg="white",
            font=("Arial", 11, "bold"),
            width=12,
            height=2,
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        )
        self.stop_btn.pack(side=tk.LEFT, padx=5)
        
        tk.Button(
            btn_container,
            text="Refresh",
            command=self.refresh_data_async,
            bg="#3498db",
            fg="white",
            font=("Arial", 11, "bold"),
            width=12,
            height=2,
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        ).pack(side=tk.LEFT, padx=5)
        
        tk.Button(
            btn_container,
            text="Start All",
            command=self.start_all_stopped,
            bg="#16a085",
            fg="white",
            font=("Arial", 11, "bold"),
            width=12,
            height=2,
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        ).pack(side=tk.LEFT, padx=5)
        
        # Live feed controls
        live_controls = tk.Frame(btn_container, bg="#ecf0f1")
        live_controls.pack(side=tk.LEFT, padx=15)
        
        self.auto_refresh_var = tk.BooleanVar(value=True)
        self.pause_resume_btn = tk.Button(
            live_controls,
            text="Pause Live",
            command=self.toggle_auto_refresh,
            bg="#e67e22",
            fg="white",
            font=("Arial", 10, "bold"),
            width=12,
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        )
        self.pause_resume_btn.pack(side=tk.LEFT, padx=5)
        
        # Refresh rate selector
        rate_frame = tk.Frame(live_controls, bg="#ecf0f1")
        rate_frame.pack(side=tk.LEFT, padx=10)
        
        tk.Label(
            rate_frame,
            text="Update every:",
            font=("Arial", 9),
            bg="#ecf0f1"
        ).pack(side=tk.LEFT)
        
        self.refresh_rate_var = tk.IntVar(value=REFRESH_INTERVAL)
        rate_options = [("2s", 2), ("3s", 3), ("5s", 5), ("10s", 10), ("30s", 30)]
        
        for text, value in rate_options:
            rb = tk.Radiobutton(
                rate_frame,
                text=text,
                variable=self.refresh_rate_var,
                value=value,
                command=self.update_refresh_rate,
                font=("Arial", 9),
                bg="#ecf0f1",
                selectcolor="#3498db"
            )
            rb.pack(side=tk.LEFT, padx=2)
        
        # Search bar
        search_frame = tk.Frame(self.root, bg="#ecf0f1", height=40)
        search_frame.pack(fill=tk.X)
        search_frame.pack_propagate(False)
        
        tk.Label(
            search_frame,
            text="Search:",
            font=("Arial", 10),
            bg="#ecf0f1"
        ).pack(side=tk.LEFT, padx=10)
        
        self.search_entry = tk.Entry(search_frame, font=("Arial", 10), width=30)
        self.search_entry.pack(side=tk.LEFT, padx=5)
        self.search_entry.bind('<KeyRelease>', self.filter_vms)
        
        tk.Label(
            search_frame,
            text="Filter by ID, Name, Type, Status, Node, or IP",
            font=("Arial", 9),
            bg="#ecf0f1",
            fg="#7f8c8d"
        ).pack(side=tk.LEFT, padx=10)
        
        # Progress bar
        self.progress_frame = tk.Frame(self.root, bg="#ecf0f1", height=30)
        self.progress_frame.pack(fill=tk.X)
        self.progress_frame.pack_propagate(False)
        
        self.progress_bar = ttk.Progressbar(
            self.progress_frame,
            mode='indeterminate',
            length=300
        )
        self.progress_bar.pack(side=tk.LEFT, padx=10, pady=5)
        
        self.progress_label = tk.Label(
            self.progress_frame,
            text="",
            font=("Arial", 9),
            bg="#ecf0f1",
            fg="#7f8c8d"
        )
        self.progress_label.pack(side=tk.LEFT, padx=5)
        
        # Table with horizontal scrollbar
        table_container = tk.Frame(self.root)
        table_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Create canvas and scrollbar for horizontal scrolling
        canvas = tk.Canvas(table_container, bg="#ecf0f1")
        hsb = ttk.Scrollbar(table_container, orient="horizontal", command=canvas.xview)
        vsb = ttk.Scrollbar(table_container, orient="vertical")
        
        table_frame = tk.Frame(canvas)
        
        # Configure canvas
        canvas.configure(xscrollcommand=hsb.set)
        
        # Basic columns
        columns = (
            "ID", "Type", "Status", "Name", "Node", 
            "Cores", "Sockets", "CPU", "Memory", "Disk", "Free Disk", "Free%"
        )
        
        self.tree = ttk.Treeview(
            table_frame,
            columns=columns,
            show="tree headings",
            yscrollcommand=vsb.set,
            selectmode="browse",
            height=20
        )
        
        vsb.config(command=self.tree.yview)
        
        self.tree.column("#0", width=0, stretch=tk.NO)
        
        # Column widths
        column_widths = {
            "ID": 60, "Type": 60, "Status": 80, "Name": 180, "Node": 100,
            "Cores": 70, "Sockets": 80, "CPU": 120, "Memory": 180,
            "Disk": 100, "Free Disk": 100, "Free%": 80
        }
        
        for col in columns:
            width = column_widths.get(col, 80)
            self.tree.column(col, width=width, anchor="center")
            self.tree.heading(col, text=col, anchor="center")
        
        self.tree.pack(fill=tk.BOTH, expand=True)
        
        # Configure colored tags for status highlighting
        self.tree.tag_configure("running", background="#d5f4e6", foreground="#27ae60")
        self.tree.tag_configure("stopped", background="#fadbd8", foreground="#e74c3c")
        self.tree.tag_configure("paused", background="#fef5e7", foreground="#f39c12")
        self.tree.tag_configure("unknown", background="#ecf0f1", foreground="#95a5a6")
        
        # Pack scrollbars and canvas
        hsb.pack(side=tk.BOTTOM, fill=tk.X)
        vsb.pack(side=tk.RIGHT, fill=tk.Y)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Create window in canvas
        canvas_window = canvas.create_window((0, 0), window=table_frame, anchor="nw")
        
        # Configure scroll region
        def configure_scroll_region(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
        
        table_frame.bind("<Configure>", configure_scroll_region)
        
        self.tree.bind("<<TreeviewSelect>>", self.on_select)
        
        # Status bar
        status_bar = tk.Frame(self.root, bg="#34495e", height=30)
        status_bar.pack(fill=tk.X)
        status_bar.pack_propagate(False)
        
        self.status_label = tk.Label(
            status_bar,
            text="Ready",
            font=("Arial", 9),
            bg="#34495e",
            fg="white",
            anchor="w"
        )
        self.status_label.pack(side=tk.LEFT, padx=10, fill=tk.X, expand=True)
    
    def authenticate(self):
        """Handle authentication - API Token Only"""
        
        if os.path.exists(CREDENTIALS_FILE):
            while True:
                master_password = simpledialog.askstring(
                    "Master Password",
                    "Enter your master password:",
                    show='*',
                    parent=self.root
                )
                
                if master_password is None:
                    return False
                
                try:
                    creds = CredentialManager.load_credentials(master_password)
                    if creds:
                        # Only token authentication supported
                        self.api = ProxmoxAPI(
                            creds['host'],
                            token_id=creds['token_id'],
                            token_secret=creds['token_secret']
                        )
                        
                        self.status_label.config(text=f"Connected to {creds['host']}")
                        self.ssl_label.config(text=f"SSL: {self.api.ssl_status}")
                        self.connection_healthy = True
                        logger.info(f"Successfully authenticated to {creds['host']}")
                        return True
                except Exception as e:
                    logger.error(f"Authentication failed: {str(e)}")
                    messagebox.showerror("Error", f"Failed to decrypt or connect:\n{str(e)}")
        
        messagebox.showinfo("Setup", "No credentials found. Let's set up your connection with an API token.")
        dialog = CredentialsDialog(self.root, is_setup=True)
        self.root.wait_window(dialog)
        
        if dialog.result:
            auth_type, host, user, password, token_id, token_secret, master = dialog.result
            try:
                # Only token authentication
                self.api = ProxmoxAPI(host, token_id=token_id, token_secret=token_secret)
                CredentialManager.save_credentials(host, master, token_id, token_secret)
                
                messagebox.showinfo("Success", "Credentials saved successfully!")
                self.status_label.config(text=f"Connected to {host}")
                self.ssl_label.config(text=f"SSL: {self.api.ssl_status}")
                self.connection_healthy = True
                logger.info(f"Successfully set up connection to {host}")
                return True
            except Exception as e:
                logger.error(f"Connection setup failed: {str(e)}")
                messagebox.showerror("Error", f"Connection failed:\n{str(e)}")
                return False
        
        return False
    
    def start_task_processor(self):
        """Process async tasks"""
        def process_tasks():
            while True:
                try:
                    task = self.task_queue.get(timeout=1)
                    if task:
                        func, args, callback = task
                        try:
                            result = func(*args)
                            if callback:
                                self.root.after(0, lambda r=result: callback(r, None))
                        except Exception as e:
                            if callback:
                                self.root.after(0, lambda er=e: callback(None, er))
                except queue.Empty:
                    continue
                except Exception as e:
                    logger.error(f"Task processor error: {e}")
                    break
        
        task_thread = threading.Thread(target=process_tasks, daemon=True)
        task_thread.start()
    
    def run_async(self, func, args=(), callback=None):
        """Run function asynchronously"""
        self.task_queue.put((func, args, callback))
    
    def show_loading(self, message="Loading..."):
        """Show loading indicator"""
        self.is_loading = True
        self.progress_label.config(text=message)
        self.progress_bar.start()
        self.status_label.config(text=f"[Loading] {message}")
        self.root.config(cursor="watch")
    
    def hide_loading(self):
        """Hide loading indicator"""
        self.is_loading = False
        self.progress_bar.stop()
        self.progress_label.config(text="")
        self.root.config(cursor="")
    
    def start_health_check(self):
        """Start connection health check"""
        def health_check_loop():
            while True:
                time.sleep(60)
                try:
                    if self.api:
                        self.api.get('/version')
                        self.connection_healthy = True
                        self.root.after(0, lambda: [
                            self.connection_label.config(text="Connected", fg="#27ae60"),
                            self.update_led_color(self.connection_led, "#27ae60")
                        ])
                except Exception:
                    self.connection_healthy = False
                    self.root.after(0, lambda: [
                        self.connection_label.config(text="Disconnected", fg="#e74c3c"),
                        self.update_led_color(self.connection_led, "#e74c3c")
                    ])
                    self.root.after(0, self.attempt_reconnect)
        
        self.health_check_thread = threading.Thread(target=health_check_loop, daemon=True)
        self.health_check_thread.start()
    
    def attempt_reconnect(self):
        """Attempt reconnection"""
        if self.is_loading:
            return
        
        response = messagebox.askyesno(
            "Connection Lost",
            "Connection to Proxmox was lost. Attempt to reconnect?"
        )
        
        if response:
            self.show_loading("Reconnecting...")
            
            def try_reconnect():
                try:
                    self.api.get('/version')
                    return True
                except Exception:
                    return False
            
            def reconnect_callback(success, error):
                self.hide_loading()
                if success:
                    messagebox.showinfo("Success", "Reconnected successfully!")
                    self.refresh_data_async()
                else:
                    messagebox.showerror("Error", "Reconnection failed. Please restart the application.")
            
            self.run_async(try_reconnect, callback=reconnect_callback)
    
    def filter_vms(self, event=None):
        """Filter VMs based on search query"""
        query = self.search_entry.get().lower()
        
        # Faster bulk delete
        self.tree.delete(*self.tree.get_children())
        
        # Count statuses for summary
        running_count = 0
        stopped_count = 0
        
        self.filtered_vm_data = []
        for vm in self.vm_data:
            if (query in str(vm.get('id', '')).lower() or
                query in vm.get('name', '').lower() or
                query in vm.get('type', '').lower() or
                query in vm.get('status', '').lower() or
                query in vm.get('node', '').lower()):
                self.filtered_vm_data.append(vm)
                
                # Determine status tag
                status = vm['status'].lower()
                if status == 'running':
                    tags = ('running',)
                    running_count += 1
                elif status == 'stopped':
                    tags = ('stopped',)
                    stopped_count += 1
                elif status == 'paused':
                    tags = ('paused',)
                else:
                    tags = ('unknown',)
                
                self.tree.insert('', 'end', values=(
                    vm['id'], vm['type'], vm['status'], vm['name'], vm['node'],
                    vm.get('cores', 'N/A'), vm.get('sockets', 'N/A'), vm.get('cpu', 'N/A'),
                    vm.get('memory', 'N/A'), vm.get('disk', 'N/A'),
                    vm.get('free_disk', 'N/A'), vm.get('free_pct', 'N/A')
                ), tags=tags)
        
        # Update summary counts
        self.running_count_label.config(text=f"Running: {running_count}")
        self.stopped_count_label.config(text=f"Stopped: {stopped_count}")
        
        if query:
            self.status_label.config(
                text=f"Showing {len(self.filtered_vm_data)} of {len(self.vm_data)} VMs/CTs"
            )
        else:
            self.status_label.config(text=f"Ready - {len(self.vm_data)} VMs/CTs across {self.node_count} node(s)")
    
    def format_bytes(self, bytes_val):
        """Format bytes to human readable"""
        if not bytes_val or bytes_val == 'N/A':
            return 'N/A'
        try:
            bytes_val = float(bytes_val)
            for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
                if bytes_val < 1024:
                    return f"{bytes_val:.1f}{unit}"
                bytes_val /= 1024
            return f"{bytes_val:.1f}PB"
        except Exception:
            return 'N/A'
    
    def fetch_single_vm_data(self, node, vm, vm_type):
        """Fetch basic data for a single VM/CT"""
        try:
            n = node['node']
            endpoint = 'qemu' if vm_type == 'VM' else 'lxc'
            vmid = vm['vmid']
            
            # Get config only
            cfg = self.api.get(f'/nodes/{n}/{endpoint}/{vmid}/config')
            
            # Basic info
            cores = cfg.get('cores', 'N/A')
            memory_mb = int(cfg.get('memory', 0))
            memory = self.format_bytes(memory_mb * 1024 * 1024) if memory_mb else 'N/A'
            
            # Disk size
            total_disk = 'N/A'
            if vm_type == 'VM':
                for key in sorted(cfg.keys()):
                    if key.startswith(('scsi0', 'sata0', 'ide0', 'virtio0')):
                        value = str(cfg[key])
                        if 'size=' in value:
                            size_str = value.split('size=')[1].split(',')[0].strip()
                            if size_str.endswith('G'):
                                total_disk = f"{size_str[:-1]}GB"
                            break
            else:  # CT
                rootfs = cfg.get('rootfs', '')
                if 'size=' in str(rootfs):
                    size_str = str(rootfs).split('size=')[1].split(',')[0].strip()
                    if size_str.endswith('G'):
                        total_disk = f"{size_str[:-1]}GB"
            
            # Free disk - only if running
            free_disk = 'N/A'
            free_pct = 'N/A'
            if vm['status'] == 'running':
                try:
                    stat = self.api.get(f'/nodes/{n}/{endpoint}/{vmid}/status/current')
                    disk_used = stat.get('disk', 0)
                    disk_max = stat.get('maxdisk', 0)
                    if disk_max > 0:
                        free_bytes = disk_max - disk_used
                        free_disk = self.format_bytes(free_bytes)
                        free_pct = f"{(free_bytes / disk_max * 100):.1f}%"
                except Exception:
                    pass
            
            # Additional CPU info
            sockets = cfg.get('sockets', 'N/A') if vm_type == 'VM' else 'N/A'
            cpu_type = cfg.get('cpu', 'N/A') if vm_type == 'VM' else 'N/A'
            
            vm_info = {
                'id': vmid,
                'type': vm_type,
                'status': vm['status'],
                'name': vm['name'],
                'node': n,
                'cores': cores,
                'sockets': sockets,
                'cpu': cpu_type,
                'memory': memory,
                'disk': total_disk,
                'free_disk': free_disk,
                'free_pct': free_pct
            }
            
            return vm_info
            
        except Exception as e:
            logger.error(f"Error getting {vm_type} {vm['vmid']}: {e}")
            return None
    
    def refresh_data_async(self):
        """Refresh data asynchronously with parallel processing"""
        if self.is_loading:
            return
        
        self.show_loading("Fetching data from Proxmox...")
        
        def fetch_data():
            return self._fetch_vm_data_parallel()
        
        def update_ui(result, error):
            self.hide_loading()
            if error:
                self.status_label.config(text=f"Error: {str(error)}")
                self.connection_label.config(text="Disconnected", fg="#e74c3c")
                # Update LED to red
                self.update_led_color(self.connection_led, "#e74c3c")
                messagebox.showerror("Error", f"Failed to refresh:\n{str(error)}")
            else:
                self.vm_data = result
                self.filter_vms()
                now = datetime.now().strftime("%H:%M:%S")
                
                # Show live status if enabled
                if self.auto_refresh:
                    refresh_rate = self.refresh_rate_var.get()
                    self.last_update_label.config(text=f"LIVE - Updated: {now} (every {refresh_rate}s)")
                else:
                    self.last_update_label.config(text=f"Updated: {now} (paused)")
                
                self.connection_label.config(text="Connected", fg="#27ae60")
                # Update LED to green
                self.update_led_color(self.connection_led, "#27ae60")
                
                # Update host temperature
                temp, zone = self.get_host_temperature()
                temp_text = self.format_temperature(temp, zone)
                temp_color = self.get_temp_color(temp)
                self.temp_label.config(text=temp_text, fg=temp_color)
        
        self.run_async(fetch_data, callback=update_ui)
    
    def _fetch_vm_data_parallel(self):
        """Fetch VM data using simple serial processing"""
        vm_data = []
        nodes = self.api.get('/nodes')
        self.node_count = len(nodes)
        
        # Update node count in UI
        self.root.after(0, lambda: self.node_label.config(text=f"Nodes: {self.node_count}"))
        
        # Count total VMs/CTs first for progress
        total_count = 0
        for node in nodes:
            n = node['node']
            try:
                vms = self.api.get(f'/nodes/{n}/qemu')
                total_count += len(vms)
            except Exception as e:
                logger.error(f"Error counting VMs from node {n}: {e}")
            
            try:
                cts = self.api.get(f'/nodes/{n}/lxc')
                total_count += len(cts)
            except Exception as e:
                logger.error(f"Error counting CTs from node {n}: {e}")
        
        # Process each VM/CT sequentially
        current = 0
        for node in nodes:
            n = node['node']
            
            # Get and process VMs
            try:
                vms = self.api.get(f'/nodes/{n}/qemu')
                for vm in vms:
                    current += 1
                    self.root.after(0, lambda c=current, t=total_count: self.progress_label.config(
                        text=f"Processing {c}/{t} VMs/CTs..."
                    ))
                    
                    try:
                        vm_info = self.fetch_single_vm_data(node, vm, 'VM')
                        if vm_info:
                            vm_data.append(vm_info)
                    except Exception as e:
                        logger.error(f"Error getting VM {vm['vmid']}: {e}")
            except Exception as e:
                logger.error(f"Error getting VMs from node {n}: {e}")
            
            # Get and process Containers
            try:
                cts = self.api.get(f'/nodes/{n}/lxc')
                for ct in cts:
                    current += 1
                    self.root.after(0, lambda c=current, t=total_count: self.progress_label.config(
                        text=f"Processing {c}/{t} VMs/CTs..."
                    ))
                    
                    try:
                        ct_info = self.fetch_single_vm_data(node, ct, 'CT')
                        if ct_info:
                            vm_data.append(ct_info)
                    except Exception as e:
                        logger.error(f"Error getting CT {ct['vmid']}: {e}")
            except Exception as e:
                logger.error(f"Error getting CTs from node {n}: {e}")
        
        vm_data.sort(key=lambda x: x['id'])
        return vm_data
    
    def on_select(self, event):
        """Handle tree selection"""
        selection = self.tree.selection()
        if not selection:
            return
        
        item = self.tree.item(selection[0])
        values = item['values']
        
        # Check for expected number of columns (12 total)
        if not values or len(values) < 12:
            return
        
        status = values[2]
        
        if status == 'running':
            self.stop_btn.config(bg="#27ae60", state=tk.NORMAL)
            self.start_btn.config(bg="#e74c3c", state=tk.DISABLED)
        else:
            self.start_btn.config(bg="#27ae60", state=tk.NORMAL)
            self.stop_btn.config(bg="#e74c3c", state=tk.DISABLED)
    
    def get_selected_vm(self):
        """Get selected VM/CT"""
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a VM/CT")
            return None
        
        item = self.tree.item(selection[0])
        values = item['values']
        
        if not values or len(values) < 1:
            messagebox.showerror("Error", "Invalid selection")
            return None
        
        vmid = values[0]
        
        for vm in self.vm_data:
            if vm.get('id') == vmid:
                return vm
        return None
    
    def start_selected(self):
        """Start selected VM/CT"""
        vm = self.get_selected_vm()
        if not vm:
            return
        
        self.show_loading(f"Starting {vm['type']} {vm['id']}...")
        
        def start_vm():
            try:
                endpoint = 'qemu' if vm['type'] == 'VM' else 'lxc'
                self.api.post(f"/nodes/{vm['node']}/{endpoint}/{vm['id']}/status/start")
                AuditLogger.log_vm_action("START", vm['id'], vm['type'], vm['name'], True)
                return True
            except Exception as e:
                AuditLogger.log_vm_action("START", vm['id'], vm['type'], vm['name'], False, str(e))
                raise
        
        def start_callback(success, error):
            self.hide_loading()
            if error:
                messagebox.showerror("Error", f"Failed to start:\n{str(error)}")
            else:
                self.status_label.config(text=f"Started {vm['type']} {vm['id']} ({vm['name']})")
                self.root.after(2000, self.refresh_data_async)
        
        self.run_async(start_vm, callback=start_callback)
    
    def stop_selected(self):
        """Stop selected VM/CT"""
        vm = self.get_selected_vm()
        if not vm:
            return
        
        if not messagebox.askyesno("Confirm", f"Stop {vm['type']} {vm['id']} ({vm['name']})?"):
            return
        
        self.show_loading(f"Stopping {vm['type']} {vm['id']}...")
        
        def stop_vm():
            try:
                endpoint = 'qemu' if vm['type'] == 'VM' else 'lxc'
                self.api.post(f"/nodes/{vm['node']}/{endpoint}/{vm['id']}/status/stop")
                AuditLogger.log_vm_action("STOP", vm['id'], vm['type'], vm['name'], True)
                return True
            except Exception as e:
                AuditLogger.log_vm_action("STOP", vm['id'], vm['type'], vm['name'], False, str(e))
                raise
        
        def stop_callback(success, error):
            self.hide_loading()
            if error:
                messagebox.showerror("Error", f"Failed to stop:\n{str(error)}")
            else:
                self.status_label.config(text=f"Stopped {vm['type']} {vm['id']} ({vm['name']})")
                self.root.after(2000, self.refresh_data_async)
        
        self.run_async(stop_vm, callback=stop_callback)
    
    def start_all_stopped(self):
        """Start all stopped VMs/CTs"""
        stopped = [vm for vm in self.vm_data if vm['status'] != 'running']
        
        if not stopped:
            messagebox.showinfo("Info", "All VMs/CTs are already running")
            return
        
        if not messagebox.askyesno("Confirm", f"Start {len(stopped)} stopped VMs/CTs?"):
            return
        
        self.show_loading(f"Starting {len(stopped)} VMs/CTs...")
        
        def start_all():
            results = []
            for vm in stopped:
                try:
                    endpoint = 'qemu' if vm['type'] == 'VM' else 'lxc'
                    self.api.post(f"/nodes/{vm['node']}/{endpoint}/{vm['id']}/status/start")
                    AuditLogger.log_vm_action("START_ALL", vm['id'], vm['type'], vm['name'], True)
                    results.append((vm['id'], True))
                except Exception as e:
                    AuditLogger.log_vm_action("START_ALL", vm['id'], vm['type'], vm['name'], False, str(e))
                    results.append((vm['id'], False))
            return results
        
        def start_all_callback(results, error):
            self.hide_loading()
            if error:
                messagebox.showerror("Error", f"Failed to start all:\n{str(error)}")
            else:
                success_count = sum(1 for _, success in results if success)
                self.status_label.config(text=f"Started {success_count}/{len(stopped)} VMs/CTs")
                self.root.after(3000, self.refresh_data_async)
        
        self.run_async(start_all, callback=start_all_callback)
    
    def toggle_auto_refresh(self):
        """Toggle live feed"""
        self.auto_refresh = not self.auto_refresh
        self.auto_refresh_var.set(self.auto_refresh)
        
        if self.auto_refresh:
            self.pause_resume_btn.config(
                text="Pause Live",
                bg="#e67e22"
            )
            self.live_indicator.config(
                text="LIVE",
                fg="#27ae60"
            )
            # Update LED to green
            self.update_led_color(self.live_led, "#27ae60")
            self.status_label.config(text="Live feed enabled")
            logger.info("Live feed enabled")
        else:
            self.pause_resume_btn.config(
                text="Resume Live",
                bg="#27ae60"
            )
            self.live_indicator.config(
                text="PAUSED",
                fg="#95a5a6"
            )
            # Update LED to gray
            self.update_led_color(self.live_led, "#95a5a6")
            self.status_label.config(text="Live feed paused")
            logger.info("Live feed paused")
    
    def update_refresh_rate(self):
        """Update the refresh rate"""
        new_rate = self.refresh_rate_var.get()
        logger.info(f"Refresh rate changed to {new_rate} seconds")
        self.status_label.config(text=f"Update interval set to {new_rate}s")
        # The new rate will be picked up by the auto-refresh loop
    
    def start_auto_refresh(self):
        """Start live feed auto-refresh thread"""
        self.refresh_data_async()
        
        def auto_refresh_loop():
            while True:
                # Use dynamic refresh rate
                refresh_interval = self.refresh_rate_var.get()
                time.sleep(refresh_interval)
                
                if self.auto_refresh:
                    try:
                        self.root.after(0, self.refresh_data_async)
                    except Exception:
                        break
        
        self.refresh_thread = threading.Thread(target=auto_refresh_loop, daemon=True)
        self.refresh_thread.start()
        logger.info(f"Live feed started with {REFRESH_INTERVAL}s refresh rate")
    
    def on_closing(self):
        """Handle window close event - cleanup resources"""
        # Stop auto-refresh to prevent thread from trying to update UI
        self.auto_refresh = False
        
        # Give threads a moment to finish current operations
        time.sleep(0.5)
        
        # Destroy the window
        self.root.destroy()
    
    def safe_ui_update(self, callback):
        """Safely update UI from background thread"""
        try:
            if self.root.winfo_exists():
                callback()
        except tk.TclError:
            # Window was destroyed, ignore
            pass

def main():
    print(__doc__)
    
    root = tk.Tk()
    app = ProxmoxDashboard(root)
    root.mainloop()

if __name__ == '__main__':
    main()
