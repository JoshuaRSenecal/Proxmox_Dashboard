#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use Tk;
use Tk::HList;
use Tk::DialogBox;
use Tk::Toplevel;
use Tk::Canvas;
use Tk::Scrollbar;
use LWP::UserAgent;
use HTTP::Request;
use JSON;
use MIME::Base64;
use File::Path qw(make_path);
use File::Spec;
use POSIX qw(strftime);
use Time::HiRes qw(sleep time);
use List::Util qw(min);
use Digest::SHA;
use Crypt::PBKDF2;
use Crypt::AuthEnc::GCM;
use Crypt::Random qw(makerandom_octet);
use IO::Socket::SSL;

# Configure logging
our $LOG_FILE = File::Spec->catfile($ENV{HOME}, '.proxmox_dashboard.log');
our $CREDENTIALS_FILE = File::Spec->catfile($ENV{HOME}, '.proxmox_credentials.enc');
our $PROXMOX_CA_CERT = File::Spec->catfile($ENV{HOME}, 'proxmox-ca.pem');
our $AUDIT_LOG_FILE = File::Spec->catfile($ENV{HOME}, '.proxmox_dashboard_audit.log');

# Secure log file permissions (owner read/write only)
if (-e $LOG_FILE) {
    chmod 0600, $LOG_FILE;
}

# Configuration
our $SALT = 'proxmox_dashboard_salt_v1';
our $REFRESH_INTERVAL = 3;  # seconds - Live data feed (near-constant updates)
our $MAX_RETRIES = 3;
our $RETRY_DELAY = 2;

# Initialize logger
our $LOG_FH;
open($LOG_FH, '>>', $LOG_FILE) or die "Cannot open log file: $!";
$LOG_FH->autoflush(1);

sub log_message {
    my ($level, $message) = @_;
    my $timestamp = main::strftime("%Y-%m-%d %H:%M:%S", localtime);
    print $LOG_FH "$timestamp - ProxmoxDashboard - $level - $message\n";
}

# SSL Configuration - MANDATORY
unless (-e $PROXMOX_CA_CERT) {
    my $error_msg = <<"EOF";

SSL CERTIFICATE REQUIRED

The Proxmox CA certificate is required for secure connections.

Certificate not found at: $PROXMOX_CA_CERT

To obtain the certificate:
  1. SSH into your Proxmox server
  2. Run: scp root\@YOUR_PROXMOX_IP:/etc/pve/pve-root-ca.pem $PROXMOX_CA_CERT
  
Or manually copy /etc/pve/pve-root-ca.pem from Proxmox to $PROXMOX_CA_CERT

SSL verification is MANDATORY for security.
Dashboard cannot start without the CA certificate.
EOF
    
    print $error_msg;
    log_message('ERROR', "SSL Certificate not found - cannot start");
    log_message('ERROR', "Expected location: $PROXMOX_CA_CERT");
    exit 1;
}

# Suppress SSL warnings for temperature API (uses self-signed certs via stunnel)
$ENV{PERL_LWP_SSL_VERIFY_HOSTNAME} = 0;

# Detect Tk version
our $TK_VERSION = $Tk::VERSION || 'Unknown';
our $TCL_VERSION = eval { Tk::Tcl_GetVersion() } || 'Unknown';
log_message('INFO', "Perl/Tk Version: $TK_VERSION");
log_message('INFO', "Tcl/Tk Version: $TCL_VERSION");

################################################################################
# AuditLogger Class
################################################################################
package AuditLogger;

sub log_entry {
    my ($action, $target, $result, $details) = @_;
    
    eval {
        my $timestamp = main::strftime("%Y-%m-%d %H:%M:%S", localtime);
        my $log_entry = sprintf("%s | %-20s | %-20s | %-10s", 
                               $timestamp, $action, $target, $result);
        
        if ($details) {
            $log_entry .= " | $details";
        }
        
        open(my $fh, '>>', $main::AUDIT_LOG_FILE) or die "Cannot open audit log: $!";
        print $fh "$log_entry\n";
        close($fh);
        
        # Secure audit log permissions
        if (-e $main::AUDIT_LOG_FILE) {
            chmod 0600, $main::AUDIT_LOG_FILE;
        }
    };
    
    if ($@) {
        main::log_message('ERROR', "Failed to write audit log: $@");
    }
}

sub log_authentication {
    my ($host, $user, $success) = @_;
    my $result = $success ? "SUCCESS" : "FAILED";
    log_entry("AUTH", "$user\@$host", $result);
}

sub log_vm_action {
    my ($action, $vmid, $vm_type, $vm_name, $success, $error) = @_;
    my $result = $success ? "SUCCESS" : "FAILED";
    my $target = "$vm_type $vmid ($vm_name)";
    my $details = $error ? "Error: $error" : undef;
    log_entry($action, $target, $result, $details);
}

################################################################################
# ProxmoxAPI Class
################################################################################
package ProxmoxAPI;

sub new {
    my ($class, $host, $token_id, $token_secret) = @_;
    
    
    my $self = {
        base => "https://$host:8006/api2/json",
        host => $host,
        verify => $main::PROXMOX_CA_CERT,
        ssl_status => "Verified",
        token_id => $token_id,
        token_secret => $token_secret,
    };
    
    bless $self, $class;
    
    
    # Create LWP UserAgent with SSL verification
    $self->{ua} = LWP::UserAgent->new(
        ssl_opts => {
            SSL_ca_file => $main::PROXMOX_CA_CERT,
            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_PEER,
            verify_hostname => 1,
        },
        timeout => 10,
    );
    
    
    # Test authentication
    eval {
        $self->_api_request('GET', '/version');
        AuditLogger::log_authentication($host, $token_id, 1);
    };
    
    if ($@) {
        AuditLogger::log_authentication($host, $token_id, 0);
        main::log_message('ERROR', "API authentication failed: $@");
        die "API authentication failed. Please check:\n" .
            "1. Token ID format: should be 'user\@realm!tokenname' (e.g., 'root\@pam!dashboard')\n" .
            "2. Token secret is correct\n" .
            "3. Proxmox host '$host' is reachable\n" .
            "4. SSL certificate is valid\n" .
            "Error details: $@";
    }
    
    return $self;
}

sub _api_request {
    my ($self, $method, $path, $retries, %params) = @_;
    $retries = $main::MAX_RETRIES unless defined $retries;
    
    # Error handling strategy:
    # - Operational errors (VM stopped, guest agent not running): fail immediately, no retry, no ERROR log
    # - Authentication errors: fail immediately, no retry
    # - Server errors (5xx): retry with exponential backoff
    # - Client errors (4xx): fail immediately, no retry
    # - Network errors: retry with exponential backoff
    
    my $last_error;
    my $result;
    
    for my $attempt (1..$retries) {
        eval {
            my $url = $self->{base} . $path;
            my $req;
            
            
            if ($method eq 'GET') {
                $req = HTTP::Request->new(GET => $url);
            } elsif ($method eq 'POST') {
                $req = HTTP::Request->new(POST => $url);
                if ($params{data}) {
                    $req->content_type('application/x-www-form-urlencoded');
                    $req->content($params{data});
                }
            }
            
            # Add API token authentication header
            my $auth_header = "PVEAPIToken=$self->{token_id}=$self->{token_secret}";
            $req->header('Authorization' => $auth_header);
            
            my $response = $self->{ua}->request($req);
            
            
            if ($response->is_success || $response->code == 201) {
                $result = $response;  # Store result instead of returning
                return;  # Exit eval successfully
            } elsif ($response->code == 401) {
                # Authentication failure - don't retry, fail immediately
                my $error_msg = "Authentication failed: " . $response->status_line;
                if ($response->content) {
                    $error_msg .= " - Response: " . substr($response->content, 0, 200);
                }
                main::log_message('ERROR', $error_msg);
                die $error_msg;
            } elsif ($response->code >= 500) {
                # Check if this is an expected operational error (not a real server error)
                my $content = $response->content || '';
                my $is_operational_error = (
                    $content =~ /guest agent/i ||
                    $content =~ /not running/i ||
                    $content =~ /VM is stopped/i ||
                    $content =~ /CT is stopped/i ||
                    $content =~ /is not running/i ||
                    $path =~ m{/agent/}  # Any guest agent endpoint
                );
                
                if ($is_operational_error) {
                    # This is an expected error (VM stopped, agent not installed, etc.)
                    # Don't retry, just fail with the error
                    my $error_msg = "Operational condition: " . $response->status_line;
                    if ($content) {
                        $error_msg .= " - " . substr($content, 0, 200);
                    }
                    die $error_msg;
                } elsif ($attempt < $retries) {
                    # Real server error - retry with backoff
                    my $delay = $main::RETRY_DELAY * (2 ** ($attempt - 1));
                    sleep($delay);
                    die "Server error, will retry";  # Trigger retry
                } else {
                    # Out of retries
                    my $error_msg = "HTTP error: " . $response->status_line;
                    if ($content) {
                        $error_msg .= " - Response: " . substr($content, 0, 200);
                    }
                    main::log_message('ERROR', $error_msg);
                    die $error_msg;
                }
            } else {
                # Other errors (4xx) - fail immediately
                my $error_msg = "HTTP error: " . $response->status_line;
                if ($response->content) {
                    $error_msg .= " - Response: " . substr($response->content, 0, 200);
                }
                main::log_message('ERROR', $error_msg);
                die $error_msg;
            }
        };
        
        $last_error = $@;
        
        if ($last_error) {
            # Check if this is an operational error (expected conditions)
            if ($last_error =~ /Operational condition:|guest agent|QEMU.*agent/i) {
                # This is expected (VM stopped, agent not running, etc.)
                # Don't retry, just let the error propagate to caller's eval block
                # The first die at line 254 was already caught by our eval
                # We just need to break out of retry loop and re-throw it
                last;  # Exit retry loop
            }
            
            if ($last_error =~ /Authentication failed/) {
                die $last_error;  # Don't retry auth failures
            }
            
            if ($attempt == $retries) {
                main::log_message('ERROR', "All retry attempts exhausted: $last_error");
                die $last_error;
            }
            
            my $delay = $main::RETRY_DELAY * (2 ** ($attempt - 1));
            sleep($delay);
        } else {
            # Success - exit loop
            last;
        }
    }
    
    # After the retry loop, check if we had an error
    if ($last_error) {
        # Re-throw the error for the calling code's eval to catch
        die $last_error;
    }
    
    # If we have a result, return it
    if ($result) {
        return $result;
    }
    
    # Otherwise, something went wrong
    die "API request failed after $retries attempts" . ($last_error ? ": $last_error" : "");
}

sub get {
    my ($self, $path) = @_;
    
    my $response = $self->_api_request('GET', $path);
    
    my $data;
    eval {
        $data = JSON::decode_json($response->content);
        
        if (exists $data->{data}) {
            $data = $data->{data};
        }
    };
    
    if ($@) {
        my $error = $@;
        my $content_preview = substr($response->content, 0, 200);
        main::log_message('ERROR', "Invalid API response from $path: $error");
        main::log_message('ERROR', "Response content preview: $content_preview");
        die "Invalid API response from $path: $error";
    }
    
    # Ensure we return something valid (at minimum an empty hash or array)
    unless (defined $data) {
        return {};
    }
    
    return $data;
}

sub post {
    my ($self, $path, $data) = @_;
    
    my %params;
    $params{data} = $data if $data;
    
    return $self->_api_request('POST', $path, $main::MAX_RETRIES, %params);
}

################################################################################
# CredentialManager Class
################################################################################
package CredentialManager;

use Crypt::PBKDF2;
use Crypt::AuthEnc::GCM qw(gcm_encrypt_authenticate gcm_decrypt_verify);
use MIME::Base64 qw(encode_base64 decode_base64);
use Crypt::Random qw(makerandom_octet);

sub get_key_from_password {
    my ($password) = @_;
    
    # Use PBKDF2 exactly like Python's cryptography library
    # Python: PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=SALT, iterations=100000)
    my $pbkdf2 = Crypt::PBKDF2->new(
        hash_class => 'HMACSHA2',
        hash_args => {
            sha_size => 256,
        },
        iterations => 100000,
        output_len => 32,
    );
    
    # Generate raw key bytes
    my $key = $pbkdf2->PBKDF2($main::SALT, $password);
    
    my $key_len = length($key);
    
    if ($key_len != 32) {
        main::log_message('ERROR', "PBKDF2 generated wrong key length: $key_len");
        die "Key derivation failed - got $key_len bytes instead of 32";
    }
    
    return $key;
}

sub save_credentials {
    my ($host, $master_password, $token_id, $token_secret) = @_;
    
    eval {
        my $credentials = {
            host => $host,
            auth_type => 'token',
            token_id => $token_id,
            token_secret => $token_secret,
        };
        
        my $json = JSON::encode_json($credentials);
        
        my $key = get_key_from_password($master_password);
        
        # Use AES-256-GCM for authenticated encryption (more reliable than CBC)
        # Generate random 12-byte IV
        my $iv = makerandom_octet(Length => 12);
        
        # Encrypt using GCM mode
        my ($ciphertext, $tag) = gcm_encrypt_authenticate('AES', $key, $iv, '', $json);
        
        # Store: IV (12 bytes) + tag (16 bytes) + ciphertext
        my $encrypted = $iv . $tag . $ciphertext;
        
        
        # Write to temporary file first, then rename (atomic operation)
        my $temp_file = $main::CREDENTIALS_FILE . '.tmp';
        
        open(my $fh, '>', $temp_file) or die "Cannot create temp file: $!";
        binmode($fh);
        print $fh $encrypted;
        close($fh);
        
        # Set permissions before rename
        chmod 0600, $temp_file;
        
        # Atomic rename
        rename($temp_file, $main::CREDENTIALS_FILE) or die "Cannot rename file: $!";
        
        # Verify final file exists
        unless (-e $main::CREDENTIALS_FILE) {
            die "Credentials file does not exist after save";
        }
        
    };
    
    if ($@) {
        main::log_message('ERROR', "Error saving credentials: $@");
        die "Failed to save credentials: $@";
    }
}

sub load_credentials {
    my ($master_password) = @_;
    
    unless (-e $main::CREDENTIALS_FILE) {
        return undef;
    }
    
    
    my $creds;
    eval {
        open(my $fh, '<', $main::CREDENTIALS_FILE) or die "Cannot read credentials: $!";
        binmode($fh);
        my $encrypted = do { local $/; <$fh> };
        close($fh);
        
        my $encrypted_len = length($encrypted);
        
        if ($encrypted_len < 28) {  # Minimum: 12 (IV) + 16 (tag) + some data
            die "Credentials file is too small or corrupted";
        }
        
        my $key = get_key_from_password($master_password);
        
        # Extract: IV (12 bytes) + tag (16 bytes) + ciphertext
        my $iv = substr($encrypted, 0, 12);
        my $tag = substr($encrypted, 12, 16);
        my $ciphertext = substr($encrypted, 28);
        
        
        # Decrypt using GCM mode
        my $decrypted = gcm_decrypt_verify('AES', $key, $iv, '', $ciphertext, $tag);
        
        unless (defined $decrypted) {
            die "Decryption failed - wrong password or corrupted data";
        }
        
        
        # Show preview
        my $preview = substr($decrypted, 0, 100);
        $preview =~ s/[^[:print:]]/?/g;
        
        $creds = JSON::decode_json($decrypted);
    };
    
    if ($@) {
        my $error = $@;
        main::log_message('ERROR', "Credential decryption failed: $error");
        
        if ($error =~ /wrong password/i) {
            die "Invalid master password.\n\nIf you forgot your password, delete: $main::CREDENTIALS_FILE\nThen restart and set up new credentials.";
        } elsif ($error =~ /corrupted/i || $error =~ /too small/i) {
            die "Credentials file is corrupted. Please delete: $main::CREDENTIALS_FILE\nThen restart and set up new credentials.";
        } elsif ($error =~ /JSON/i) {
            die "Credentials file contains invalid data. Please delete: $main::CREDENTIALS_FILE\nThen restart and set up new credentials.";
        } else {
            die "Failed to load credentials: $error";
        }
    }
    
    return $creds;
}

sub extract_hostname_from_certificate {
    my ($cert_path) = @_;
    
    eval {
        my $output = `openssl x509 -in $cert_path -noout -subject 2>&1`;
        
        if ($? == 0) {
            # Parse subject line: "subject=CN = pve"
            foreach my $part (split /,/, $output) {
                if ($part =~ /CN\s*=\s*(.+)/) {
                    my $hostname = $1;
                    $hostname =~ s/^\s+|\s+$//g;
                    return $hostname;
                }
            }
        }
    };
    
    if ($@) {
        main::log_message('ERROR', "Failed to extract hostname from certificate: $@");
    }
    
    return undef;
}

################################################################################
# TokenCreationGuide Dialog
################################################################################
package TokenCreationGuide;

sub new {
    my ($class, $parent) = @_;
    
    my $self = {};
    bless $self, $class;
    
    $self->{dialog} = $parent->Toplevel(
        -title => "Create Proxmox API Token",
    );
    
    $self->{dialog}->geometry("700x650");
    $self->{dialog}->resizable(1, 1);
    
    # Center window
    $self->{dialog}->update;
    my $x = int(($self->{dialog}->screenwidth - 700) / 2);
    my $y = int(($self->{dialog}->screenheight - 650) / 2);
    $self->{dialog}->geometry("700x650+$x+$y");
    
    $self->create_widgets();
    
    $self->{dialog}->protocol('WM_DELETE_WINDOW', sub { $self->on_close() });
    $self->{dialog}->grab();
    
    return $self;
}

sub create_widgets {
    my ($self) = @_;
    
    # Title
    my $title_frame = $self->{dialog}->Frame(
        -background => '#3498db',
        -height => 60,
    )->pack(-fill => 'x');
    
    $title_frame->Label(
        -text => "Step 1: Create API Token in Proxmox",
        -font => ['Arial', 16, 'bold'],
        -background => '#3498db',
        -foreground => 'white',
    )->pack(-pady => 15);
    
    # Main content with scrollbar
    my $main_frame = $self->{dialog}->Frame(
        -background => 'white',
    )->pack(-fill => 'both', -expand => 1, -padx => 20, -pady => 20);
    
    my $canvas = $main_frame->Canvas(
        -background => 'white',
        -highlightthickness => 0,
    )->pack(-side => 'left', -fill => 'both', -expand => 1);
    
    my $scrollbar = $main_frame->Scrollbar(
        -orient => 'vertical',
        -command => ['yview', $canvas],
    )->pack(-side => 'right', -fill => 'y');
    
    $canvas->configure(-yscrollcommand => ['set', $scrollbar]);
    
    my $scrollable_frame = $canvas->Frame(-background => 'white');
    $canvas->create('window', 0, 0, -anchor => 'nw', -window => $scrollable_frame);
    
    # Instructions content
    my @instructions = (
        ["What is an API Token?", 'bold', '#2c3e50'],
        ["An API token is a secure way to connect to Proxmox without using your password.\n", 'normal', '#34495e'],
        
        ["How to Create Token:", 'bold', '#2c3e50'],
        ["1. Open Proxmox web interface", 'bold', '#27ae60'],
        ["   Go to: https://YOUR_PROXMOX_IP:8006\n", 'normal', '#7f8c8d'],
        
        ["2. Navigate to API Tokens", 'bold', '#27ae60'],
        ["   Click: Datacenter -> Permissions -> API Tokens\n", 'normal', '#7f8c8d'],
        
        ["3. Click 'Add' button", 'bold', '#27ae60'],
        ["   (Top of the API Tokens page)\n", 'normal', '#7f8c8d'],
        
        ["4. Fill in the form:", 'bold', '#27ae60'],
        ["   • User: root\@pam", 'normal', '#7f8c8d'],
        ["   • Token ID: dashboard (or any name you want)", 'normal', '#7f8c8d'],
        ["   • Privilege Separation: UNCHECK THIS BOX", 'normal', '#e74c3c'],
        ["   • Expire: Never", 'normal', '#7f8c8d'],
        ["   • Comment: Dashboard access (optional)\n", 'normal', '#7f8c8d'],
        
        ["5. Click 'Add' button", 'bold', '#27ae60'],
        ["   The token will be created.\n", 'normal', '#7f8c8d'],
        
        ["6. COPY THE SECRET!", 'bold', '#e74c3c'],
        ["   A popup or message will show the token secret.", 'normal', '#e74c3c'],
        ["   COPY IT IMMEDIATELY - it's shown only once!\n", 'normal', '#e74c3c'],
        
        ["Alternative: Command Line (Recommended)", 'bold', '#2c3e50'],
        ["If you have SSH access, this is more reliable:\n", 'normal', '#34495e'],
        
        ["ssh root\@YOUR_PROXMOX_IP", 'normal', '#16a085'],
        ["pveum user token add root\@pam dashboard --privsep 0\n", 'normal', '#16a085'],
        
        ["The secret will appear in the output immediately.\n", 'normal', '#7f8c8d'],
        
        ["What You'll Need for Next Step:", 'bold', '#2c3e50'],
        ["• Token ID: root\@pam!dashboard", 'normal', '#34495e'],
        ["• Token Secret: (the long string you copied)\n", 'normal', '#34495e'],
    );
    
    foreach my $instr (@instructions) {
        my ($text, $weight, $color) = @$instr;
        
        $scrollable_frame->Label(
            -text => $text,
            -font => ['Arial', 10, $weight],
            -background => 'white',
            -foreground => $color,
            -justify => 'left',
            -wraplength => 620,
            -anchor => 'w',
        )->pack(-anchor => 'w', -pady => 2);
    }
    
    $scrollable_frame->update;
    $canvas->configure(-scrollregion => [$canvas->bbox('all')]);
    
    # Button frame
    my $btn_frame = $self->{dialog}->Frame(
        -background => 'white',
    )->pack(-fill => 'x', -padx => 20, -pady => 20);
    
    $btn_frame->Button(
        -text => "I've Created the Token - Continue",
        -command => sub { $self->on_continue() },
        -background => '#27ae60',
        -foreground => 'white',
        -font => ['Arial', 12, 'bold'],
        -width => 30,
        -height => 2,
        -cursor => 'hand2',
    )->pack(-pady => 5);
    
    $btn_frame->Button(
        -text => "Cancel",
        -command => sub { $self->on_close() },
        -background => '#95a5a6',
        -foreground => 'white',
        -font => ['Arial', 10],
        -width => 30,
        -cursor => 'hand2',
    )->pack(-pady => 5);
}

sub on_continue {
    my ($self) = @_;
    $self->{dialog}->destroy();
}

sub on_close {
    my ($self) = @_;
    $self->{dialog}->destroy();
}

sub wait_window {
    my ($self) = @_;
    $self->{dialog}->waitWindow();
}

################################################################################
# CredentialsDialog Class
################################################################################
package CredentialsDialog;

sub new {
    my ($class, $parent, $is_setup) = @_;
    
    my $self = {
        is_setup => $is_setup,
        result => undef,
    };
    bless $self, $class;
    
    my $title = $is_setup ? "Setup Credentials" : "Enter Credentials";
    
    $self->{dialog} = $parent->Toplevel(
        -title => $title,
    );
    
    $self->{dialog}->geometry("500x470");
    $self->{dialog}->resizable(1, 1);
    
    # Center window
    $self->{dialog}->update;
    my $x = int(($self->{dialog}->screenwidth - 500) / 2);
    my $y = int(($self->{dialog}->screenheight - 470) / 2);
    $self->{dialog}->geometry("500x470+$x+$y");
    
    $self->create_widgets();
    
    $self->{dialog}->protocol('WM_DELETE_WINDOW', sub { $self->on_cancel() });
    $self->{dialog}->grab();
    
    return $self;
}

sub create_widgets {
    my ($self) = @_;
    
    # Title
    my $title_text = $self->{is_setup} ? "Proxmox Dashboard Setup" : "Unlock Dashboard";
    
    my $title_frame = $self->{dialog}->Frame(
        -background => '#2c3e50',
        -height => 60,
    )->pack(-fill => 'x');
    
    $title_frame->Label(
        -text => $title_text,
        -font => ['Arial', 16, 'bold'],
        -background => '#2c3e50',
        -foreground => 'white',
    )->pack(-pady => 15);
    
    # Form frame
    my $form_frame = $self->{dialog}->Frame(
        -background => 'white',
    )->pack(-fill => 'both', -expand => 1, -padx => 20, -pady => 20);
    
    # Host
    $form_frame->Label(
        -text => "Proxmox Host:",
        -font => ['Arial', 10],
        -background => 'white',
    )->grid(-row => 0, -column => 0, -sticky => 'w', -pady => 5);
    
    $self->{host_entry} = $form_frame->Entry(
        -font => ['Arial', 10],
        -width => 35,
    )->grid(-row => 0, -column => 1, -pady => 5, -columnspan => 2);
    $self->{host_entry}->insert(0, 'pve');
    
    # Auth type label
    $form_frame->Label(
        -text => "Authentication: API Token",
        -font => ['Arial', 10, 'bold'],
        -background => 'white',
        -foreground => '#27ae60',
    )->grid(-row => 1, -column => 0, -sticky => 'w', -pady => 10, -columnspan => 3);
    
    # Token fields
    $form_frame->Label(
        -text => "Token ID:",
        -font => ['Arial', 10],
        -background => 'white',
    )->grid(-row => 2, -column => 0, -sticky => 'w', -pady => 5);
    
    $self->{token_id_entry} = $form_frame->Entry(
        -font => ['Arial', 10],
        -width => 35,
    )->grid(-row => 2, -column => 1, -pady => 5, -columnspan => 2);
    $self->{token_id_entry}->insert(0, 'root@pam!');
    
    $form_frame->Label(
        -text => "Token Secret:",
        -font => ['Arial', 10],
        -background => 'white',
    )->grid(-row => 3, -column => 0, -sticky => 'w', -pady => 5);
    
    $self->{token_secret_entry} = $form_frame->Entry(
        -font => ['Arial', 10],
        -width => 35,
        -show => '*',
    )->grid(-row => 3, -column => 1, -pady => 5, -columnspan => 2);
    
    $form_frame->Label(
        -text => "Create token: Datacenter -> Permissions -> API Tokens -> Add",
        -font => ['Arial', 8],
        -background => 'white',
        -foreground => '#7f8c8d',
    )->grid(-row => 4, -column => 0, -columnspan => 3, -sticky => 'w', -pady => 2);
    
    # Master password
    $form_frame->Label(
        -text => "Master Password:",
        -font => ['Arial', 10, 'bold'],
        -background => 'white',
    )->grid(-row => 5, -column => 0, -sticky => 'w', -pady => [15, 5]);
    
    $self->{master_entry} = $form_frame->Entry(
        -font => ['Arial', 10],
        -width => 35,
        -show => '*',
    )->grid(-row => 5, -column => 1, -pady => [15, 5], -columnspan => 2);
    
    $form_frame->Label(
        -text => "(Used to encrypt credentials locally)",
        -font => ['Arial', 8],
        -background => 'white',
        -foreground => '#7f8c8d',
    )->grid(-row => 6, -column => 1, -sticky => 'w', -columnspan => 2);
    
    if ($self->{is_setup}) {
        $form_frame->Label(
            -text => "Confirm Master:",
            -font => ['Arial', 10],
            -background => 'white',
        )->grid(-row => 7, -column => 0, -sticky => 'w', -pady => 5);
        
        $self->{master_confirm} = $form_frame->Entry(
            -font => ['Arial', 10],
            -width => 35,
            -show => '*',
        )->grid(-row => 7, -column => 1, -pady => 5, -columnspan => 2);
    }
    
    # Buttons
    my $btn_frame = $form_frame->Frame(
        -background => 'white',
    )->grid(-row => 8, -column => 0, -columnspan => 3, -pady => 15);
    
    my $ok_text = $self->{is_setup} ? "Save & Connect" : "Connect";
    
    $btn_frame->Button(
        -text => $ok_text,
        -command => sub { $self->on_ok() },
        -background => '#27ae60',
        -foreground => 'white',
        -font => ['Arial', 10, 'bold'],
        -width => 15,
        -cursor => 'hand2',
    )->pack(-side => 'left', -padx => 5);
    
    $btn_frame->Button(
        -text => "Cancel",
        -command => sub { $self->on_cancel() },
        -background => '#95a5a6',
        -foreground => 'white',
        -font => ['Arial', 10],
        -width => 15,
        -cursor => 'hand2',
    )->pack(-side => 'left', -padx => 5);
}

sub on_ok {
    my ($self) = @_;
    
    my $host = $self->{host_entry}->get();
    $host =~ s/^\s+|\s+$//g;
    
    my $master = $self->{master_entry}->get();
    
    unless ($host && $master) {
        $self->{dialog}->messageBox(
            -title => "Error",
            -message => "Host and master password are required!",
            -type => 'OK',
            -icon => 'error',
        );
        return;
    }
    
    if ($self->{is_setup}) {
        my $confirm = $self->{master_confirm}->get();
        unless ($master eq $confirm) {
            $self->{dialog}->messageBox(
                -title => "Error",
                -message => "Master passwords don't match!",
                -type => 'OK',
                -icon => 'error',
            );
            return;
        }
    }
    
    my $token_id = $self->{token_id_entry}->get();
    $token_id =~ s/^\s+|\s+$//g;
    
    my $token_secret = $self->{token_secret_entry}->get();
    
    unless ($token_id && $token_secret) {
        $self->{dialog}->messageBox(
            -title => "Error",
            -message => "Token ID and Token Secret are required!",
            -type => 'OK',
            -icon => 'error',
        );
        return;
    }
    
    # Always return token authentication
    $self->{result} = {
        auth_type => 'token',
        host => $host,
        token_id => $token_id,
        token_secret => $token_secret,
        master => $master,
    };
    
    $self->{dialog}->destroy();
}

sub on_cancel {
    my ($self) = @_;
    $self->{result} = undef;
    $self->{dialog}->destroy();
}

sub wait_window {
    my ($self) = @_;
    $self->{dialog}->waitWindow();
}

################################################################################
# ProxmoxDashboard Main Application
################################################################################
package ProxmoxDashboard;

sub new {
    my ($class, $root) = @_;
    
    my $self = {
        root => $root,
        api => undef,
        auto_refresh => 1,
        vm_data => [],
        filtered_vm_data => [],
        search_query => "",
        is_loading => 0,
        connection_healthy => 0,
        node_count => 0,
        node_temp_labels => {},
        node_temp_api_available => {},
        node_addresses => {},
        node_temps_full_data => {},
        tooltips_enabled => 0,
        window_ready => 0,
        refresh_rate => $main::REFRESH_INTERVAL,
    };
    
    bless $self, $class;
    
    $self->{root}->title("Proxmox Dashboard - Live Feed");
    $self->{root}->geometry("1600x900");
    $self->{root}->resizable(1, 1);
    
    # Center window
    $self->{root}->update;
    my $x = int(($self->{root}->screenwidth - 1600) / 2);
    my $y = int(($self->{root}->screenheight - 900) / 2);
    $self->{root}->geometry("1600x900+$x+$y");
    
    $self->setup_styles();
    $self->create_widgets();
    
    # Mark window as ready
    $self->{window_ready} = 1;
    
    # Add cleanup handler for window close
    $self->{root}->protocol('WM_DELETE_WINDOW', sub { $self->on_closing() });
    
    my $auth_result;
    eval {
        $auth_result = $self->authenticate();
    };
    
    if ($@) {
        main::log_message('CRITICAL', "authenticate() threw exception: $@");
        $self->{root}->destroy();
        return undef;
    }
    
    unless ($auth_result) {
        $self->{root}->destroy();
        return undef;
    }
    
    
    # Start task processor FIRST
    eval {
        $self->start_task_processor();
    };
    if ($@) {
        main::log_message('ERROR', "Failed to start task processor: $@");
        # Non-fatal, continue
    }
    
    # Delay temperature check
    eval {
        $self->{root}->after(2000, sub {
            eval {
                $self->check_temperature_api_status();
            };
            if ($@) {
                main::log_message('ERROR', "Temperature check failed: $@");
            }
        });
    };
    if ($@) {
        main::log_message('ERROR', "Failed to schedule temperature check: $@");
        # Non-fatal, continue
    }
    
    # Start auto-refresh
    eval {
        $self->start_auto_refresh();
    };
    if ($@) {
        main::log_message('CRITICAL', "Failed to start auto-refresh: $@");
        $self->{root}->messageBox(
            -title => "Initialization Error",
            -message => "Failed to start auto-refresh:\n\n$@\n\nThe dashboard may not work correctly.",
            -type => 'OK',
            -icon => 'warning',
        );
        # Continue anyway
    }
    
    # Start health check
    eval {
        $self->start_health_check();
    };
    if ($@) {
        main::log_message('ERROR', "Failed to start health check: $@");
        # Non-fatal, continue
    }
    
    
    return $self;
}

sub setup_styles {
    my ($self) = @_;
    
    # Tk doesn't have the same style system as ttk, but we'll configure widgets directly
}

sub create_led_indicator {
    my ($self, $parent, $color, $size) = @_;
    $color = 'green' unless defined $color;
    $size = 12 unless defined $size;
    
    my $canvas = $parent->Canvas(
        -width => $size,
        -height => $size,
        -background => '#2c3e50',
        -highlightthickness => 0,
    );
    
    my $padding = 2;
    my $led = $canvas->createOval(
        $padding, $padding,
        $size - $padding, $size - $padding,
        -fill => $color,
        -outline => $color,
    );
    
    $canvas->{led} = $led;
    
    return $canvas;
}

sub update_led_color {
    my ($self, $canvas, $color) = @_;
    
    if ($canvas && $canvas->{led}) {
        $canvas->itemconfigure($canvas->{led}, -fill => $color, -outline => $color);
    }
}

sub create_status_badge {
    my ($self, $parent, $text, $status) = @_;
    
    my %colors = (
        running => { bg => '#27ae60', fg => 'white' },
        stopped => { bg => '#e74c3c', fg => 'white' },
        paused => { bg => '#f39c12', fg => 'white' },
        unknown => { bg => '#95a5a6', fg => 'white' },
    );
    
    my $style = $colors{lc($status)} // $colors{unknown};
    
    my $label = $parent->Label(
        -text => uc($text),
        -background => $style->{bg},
        -foreground => $style->{fg},
        -font => ['Arial', 8, 'bold'],
        -padx => 8,
        -pady => 3,
        -relief => 'flat',
    );
    
    return $label;
}

sub get_temp_color {
    my ($self, $temp) = @_;
    
    return '#95a5a6' unless defined $temp;  # Gray for N/A
    
    if ($temp < 50) {
        return '#27ae60';  # Green - Cool
    } elsif ($temp < 70) {
        return '#3498db';  # Blue - Normal
    } elsif ($temp < 85) {
        return '#f39c12';  # Orange - Warm
    } else {
        return '#e74c3c';  # Red - Hot
    }
}

sub get_all_node_temperatures {
    my ($self) = @_;
    
    return {} unless $self->{api};
    
    main::log_message('ERROR', "TEMP DEBUG: Starting temperature fetch");
    
    my %node_temps;
    
    eval {
        my $nodes = $self->{api}->get('/nodes');
        
        # Validate that nodes is an array ref
        unless (ref($nodes) eq 'ARRAY') {
            my $type = ref($nodes) || 'scalar';
            main::log_message('ERROR', "TEMP DEBUG: /nodes returned non-array: $type");
            return {};  # Return empty hash
        }
        
        main::log_message('ERROR', "TEMP DEBUG: Got " . scalar(@$nodes) . " nodes");
        
        # Map each node to its own hostname/IP for temperature API requests
        # Each node should check its OWN temperature service, not the primary API host
        foreach my $node (@$nodes) {
            my $node_name = $node->{node};
            # Use the node's actual hostname, NOT the API host
            # This ensures each node queries its own temperature service
            $self->{node_addresses}->{$node_name} = $node_name;
            main::log_message('ERROR', "TEMP DEBUG: Node $node_name will use its own address: $node_name");
        }
        
        # Check each node
        foreach my $node (@$nodes) {
            my $node_name = $node->{node};
            
            main::log_message('ERROR', "TEMP DEBUG: Checking temperature for node: $node_name");
            
            # Always try to fetch temperature - don't skip based on previous failures
            # This ensures we retry if the service becomes available or was temporarily down
            my $result = $self->_get_node_temperature_direct($node_name, 1.5);
            
            main::log_message('ERROR', "TEMP DEBUG: _get_node_temperature_direct returned: " . 
                (defined $result ? "defined hash" : "undef"));
            
            # Check if we got valid temperature data
            # We accept the result if it has ANY sensors at all, regardless of status field
            my $has_valid_data = 0;
            if ($result && ref($result) eq 'HASH') {
                # First priority: check for sensors array
                if ($result->{sensors} && ref($result->{sensors}) eq 'ARRAY' && @{$result->{sensors}} > 0) {
                    main::log_message('ERROR', "TEMP DEBUG: Result has " . scalar(@{$result->{sensors}}) . " sensors - ACCEPTING");
                    $has_valid_data = 1;
                    
                    # Ensure status is set to 'ok' if we have sensors
                    if (!$result->{status} || $result->{status} ne 'ok') {
                        main::log_message('ERROR', "TEMP DEBUG: Forcing status='ok' because sensors present");
                        $result->{status} = 'ok';
                    }
                } else {
                    main::log_message('ERROR', "TEMP DEBUG: Result has no sensors array or it's empty - REJECTING");
                }
            } else {
                main::log_message('ERROR', "TEMP DEBUG: Result is not a hash reference - REJECTING");
            }
            
            if ($has_valid_data) {
                main::log_message('ERROR', "TEMP DEBUG: ✓✓✓ Node $node_name temperature fetch SUCCESS - " . 
                    scalar(@{$result->{sensors}}) . " sensors found");
                $node_temps{$node_name} = $result;
            } else {
                my $status = $result ? ($result->{status} // 'no status field') : 'no result';
                main::log_message('ERROR', "TEMP DEBUG: ✗✗✗ Node $node_name temperature fetch FAILED - status: $status");
                $node_temps{$node_name} = { status => 'error', sensors => [] };
            }
        }
    };
    
    if ($@) {
        main::log_message('ERROR', "TEMP DEBUG: Failed to get node temperatures: $@");
    }
    
    main::log_message('ERROR', "TEMP DEBUG: Returning temperature data for " . scalar(keys %node_temps) . " nodes");
    
    return \%node_temps;
}

sub _get_node_temperature_direct {
    my ($self, $node_name, $timeout) = @_;
    $timeout = 2 unless defined $timeout;
    
    my $result;
    eval {
        my $node_ip = $self->{node_addresses}->{$node_name} || $self->{api}->{host};
        my $url = "https://$node_ip:8898/temperature";
        
        main::log_message('ERROR', "TEMP DEBUG: Fetching from URL: $url");
        
        my $ua = LWP::UserAgent->new(
            ssl_opts => { verify_hostname => 0, SSL_verify_mode => 0 },
            timeout => $timeout,
        );
        
        my $response = $ua->get($url);
        
        main::log_message('ERROR', "TEMP DEBUG: HTTP response code: " . $response->code);
        
        if ($response->is_success) {
            my $content = $response->content;
            main::log_message('ERROR', "TEMP DEBUG: Response content length: " . length($content));
            
            eval {
                my $json_data = JSON::decode_json($content);
                
                if ($json_data && ref($json_data) eq 'HASH') {
                    # Check if sensors are nested inside a "data" object
                    my $data;
                    if ($json_data->{data} && ref($json_data->{data}) eq 'HASH') {
                        main::log_message('ERROR', "TEMP DEBUG: Found nested 'data' object, extracting it");
                        $data = $json_data->{data};
                    } else {
                        main::log_message('ERROR', "TEMP DEBUG: Using top-level JSON object");
                        $data = $json_data;
                    }
                    
                    # Log the actual structure
                    main::log_message('ERROR', "TEMP DEBUG: Data keys present: " . join(", ", sort keys %$data));
                    main::log_message('ERROR', "TEMP DEBUG: status field = " . ($data->{status} // 'MISSING'));
                    
                    # Check if we have sensor data
                    if ($data->{sensors} && ref($data->{sensors}) eq 'ARRAY') {
                        my $sensor_count = scalar(@{$data->{sensors}});
                        main::log_message('ERROR', "TEMP DEBUG: ✓ Found sensors array with $sensor_count sensors");
                        
                        # DUMP FIRST SENSOR
                        if ($sensor_count > 0) {
                            my $first_sensor = $data->{sensors}[0];
                            main::log_message('ERROR', "TEMP DEBUG: First sensor keys: " . join(", ", sort keys %$first_sensor));
                            main::log_message('ERROR', "TEMP DEBUG: First sensor: type=" . ($first_sensor->{type} // 'missing') .
                                ", label=" . ($first_sensor->{label} // 'missing') .
                                ", temperature=" . ($first_sensor->{temperature} // 'missing'));
                        }
                        
                        # If we have sensors, ALWAYS set status to 'ok'
                        if ($sensor_count > 0) {
                            if (!$data->{status} || $data->{status} ne 'ok') {
                                main::log_message('ERROR', "TEMP DEBUG: Setting status='ok' because we have $sensor_count sensors");
                                $data->{status} = 'ok';
                            }
                        }
                    } else {
                        main::log_message('ERROR', "TEMP DEBUG: ✗ No sensors array found or it's not an array");
                        # No sensors - set error status
                        $data->{status} = 'error' unless $data->{status};
                        $data->{sensors} = [];
                    }
                    
                    main::log_message('ERROR', "TEMP DEBUG: Final status after processing = " . ($data->{status} // 'still undef!'));
                    
                    # Reset fail count on success
                    $self->{temp_api_fail_count}->{$node_name} = 0;
                    
                    $result = $data;
                } else {
                    main::log_message('ERROR', "TEMP DEBUG: Temperature API returned non-hash data, type: " . (ref($json_data) || 'scalar'));
                }
            };
            
            if ($@) {
                main::log_message('ERROR', "TEMP DEBUG: JSON decode failed: $@");
            }
        } else {
            # Temperature API not available - this is common and not an error
            my $code = $response->code;
            my $message = $response->message;
            main::log_message('ERROR', "TEMP DEBUG: Temperature API not available - HTTP $code: $message");
            
            # Only log user-facing message periodically (every 10 attempts)
            $self->{temp_api_fail_count}->{$node_name} //= 0;
            $self->{temp_api_fail_count}->{$node_name}++;
            
            if ($self->{temp_api_fail_count}->{$node_name} == 1 || 
                $self->{temp_api_fail_count}->{$node_name} % 10 == 0) {
                main::log_message('ERROR', "Temperature API not available on $node_name:8898 (HTTP $code) - attempt " . 
                    $self->{temp_api_fail_count}->{$node_name});
                if ($self->{temp_api_fail_count}->{$node_name} == 1) {
                    main::log_message('ERROR', "This is normal if you haven't installed a temperature monitoring service");
                    main::log_message('ERROR', "Install lm-sensors and a temperature API service on the Proxmox node to enable temperature monitoring");
                }
            }
        }
    };
    
    if ($@) {
        main::log_message('ERROR', "TEMP DEBUG: Temperature fetch error - $@");
    }
    
    return $result;
}

sub update_node_temperatures {
    my ($self) = @_;
    
    return unless $self->{api};
    
    main::log_message('ERROR', "TEMP DEBUG: update_node_temperatures called");
    
    my $node_temps = $self->get_all_node_temperatures();
    
    main::log_message('ERROR', "TEMP DEBUG: get_all_node_temperatures returned " . 
        scalar(keys %$node_temps) . " nodes");
    
    $self->_update_temp_ui($node_temps);
    
    main::log_message('ERROR', "TEMP DEBUG: _update_temp_ui completed");
}

sub _update_temp_ui {
    my ($self, $node_temps) = @_;
    
    main::log_message('ERROR', "TEMP DEBUG: _update_temp_ui called with " . 
        scalar(keys %$node_temps) . " nodes");
    
    $self->{node_temps_full_data} = $node_temps;
    
    # Clear existing temperature labels
    my @children = $self->{node_temp_frame}->children();
    main::log_message('ERROR', "TEMP DEBUG: Found " . scalar(@children) . " existing widgets in temp frame");
    
    foreach my $widget (@children) {
        if ($widget->can('cget') && eval { $widget->cget('-text') }) {
            $widget->destroy() if $widget->{is_temp_label};
        }
    }
    
    foreach my $node_name (sort keys %$node_temps) {
        my $temp_info = $node_temps->{$node_name};
        my $status = $temp_info->{status} // 'no status';
        my $sensors = $temp_info->{sensors} || [];
        
        main::log_message('ERROR', "TEMP DEBUG: Processing node $node_name - status: $status, sensors: " . scalar(@$sensors));
        
        # PRIORITIZE SENSOR DATA - if we have sensors, use them regardless of status
        if (@$sensors > 0) {
            main::log_message('ERROR', "TEMP DEBUG: Node $node_name has " . scalar(@$sensors) . " sensors - processing them");
            
            # Show only CPU Package or highest core temp
            my $cpu_package;
            my @cpu_cores;
            
            foreach my $sensor (@$sensors) {
                my $sensor_type = $sensor->{type} || 'unknown';
                main::log_message('ERROR', "TEMP DEBUG: Sensor type=$sensor_type, label=" . 
                    ($sensor->{label} // 'none') . ", temp=" . ($sensor->{temperature} // 'none'));
                
                if ($sensor_type eq 'cpu_package') {
                    $cpu_package = $sensor;
                    last;
                } elsif ($sensor_type eq 'cpu_core') {
                    push @cpu_cores, $sensor;
                }
            }
            
            my $display_sensor = $cpu_package;
            if (!$display_sensor && @cpu_cores) {
                $display_sensor = (sort { $b->{temperature} <=> $a->{temperature} } @cpu_cores)[0];
                main::log_message('ERROR', "TEMP DEBUG: Using highest core temp: " . $display_sensor->{temperature});
            }
            
            if ($display_sensor && defined $display_sensor->{temperature}) {
                my $temp = $display_sensor->{temperature};
                my $label_text = $display_sensor->{label} || 'CPU';
                
                main::log_message('ERROR', "TEMP DEBUG: Creating label for $node_name: ${temp}°C");
                
                if (length($label_text) > 20) {
                    $label_text = substr($label_text, 0, 17) . "...";
                }
                
                my $temp_color = $self->get_temp_color($temp);
                
                my $sensor_label = $self->{node_temp_frame}->Label(
                    -text => "$node_name: ${temp}°C",
                    -font => ['Arial', 10, 'bold'],
                    -background => '#34495e',
                    -foreground => $temp_color,
                    -cursor => 'hand2',
                );
                $sensor_label->{is_temp_label} = 1;
                $sensor_label->pack(-side => 'left', -padx => 10);
                
                main::log_message('ERROR', "TEMP DEBUG: Label created and packed for $node_name");
                
                $sensor_label->bind('<Button-1>', sub { $self->show_temperature_details($node_name) });
                
                # Successfully displayed temperature, continue to next node
                next;
            } else {
                main::log_message('ERROR', "TEMP DEBUG: Have sensors but no valid display sensor with temperature");
            }
        }
        
        # If we get here, either no sensors or couldn't extract temperature - show N/A
        main::log_message('ERROR', "TEMP DEBUG: Node $node_name - showing N/A (status=$status, sensors=" . scalar(@$sensors) . ")");
        my $label = $self->{node_temp_frame}->Label(
            -text => "$node_name: N/A",
            -font => ['Arial', 9, 'bold'],
            -background => '#34495e',
            -foreground => '#95a5a6',
        );
        $label->{is_temp_label} = 1;
        $label->pack(-side => 'left', -padx => 8);
    }
}

sub show_temperature_details {
    my ($self, $node_name) = @_;
    
    unless (exists $self->{node_temps_full_data}) {
        $self->{root}->messageBox(
            -title => "Temperature Details",
            -message => "No temperature data available yet.\nPlease wait for data refresh.",
            -type => 'OK',
            -icon => 'info',
        );
        return;
    }
    
    eval {
        my $details_window = $self->{root}->Toplevel(
            -title => "Temperature Details - " . ($node_name || 'All Nodes'),
        );
        
        $details_window->geometry("800x600");
        
        # Center window
        $details_window->update;
        my $x = int(($details_window->screenwidth - 800) / 2);
        my $y = int(($details_window->screenheight - 600) / 2);
        $details_window->geometry("800x600+$x+$y");
        
        # Title
        my $title_frame = $details_window->Frame(
            -background => '#2c3e50',
            -height => 50,
        )->pack(-fill => 'x');
        
        $title_frame->Label(
            -text => "Temperature Sensors - " . ($node_name || 'All Nodes'),
            -font => ['Arial', 14, 'bold'],
            -background => '#2c3e50',
            -foreground => 'white',
        )->pack(-pady => 12);
        
        # Scrollable content
        my $canvas = $details_window->Canvas(
            -background => 'white',
        );
        
        my $scrollbar = $details_window->Scrollbar(
            -orient => 'vertical',
            -command => ['yview', $canvas],
        );
        
        my $scrollable_frame = $canvas->Frame(-background => 'white');
        
        $canvas->create('window', 0, 0, -anchor => 'nw', -window => $scrollable_frame);
        $canvas->configure(-yscrollcommand => ['set', $scrollbar]);
        
        # Filter nodes to display
        my %nodes_to_show;
        if ($node_name) {
            if (exists $self->{node_temps_full_data}->{$node_name}) {
                $nodes_to_show{$node_name} = $self->{node_temps_full_data}->{$node_name};
            }
        } else {
            %nodes_to_show = %{$self->{node_temps_full_data}};
        }
        
        $self->_populate_temperature_details($scrollable_frame, \%nodes_to_show);
        
        $scrollable_frame->update;
        $canvas->configure(-scrollregion => [$canvas->bbox('all')]);
        
        $canvas->pack(-side => 'left', -fill => 'both', -expand => 1);
        $scrollbar->pack(-side => 'right', -fill => 'y');
        
        # Close button
        my $btn_frame = $details_window->Frame(
            -background => 'white',
        )->pack(-fill => 'x', -pady => 10);
        
        $btn_frame->Button(
            -text => "Close",
            -command => sub { $details_window->destroy() },
            -background => '#95a5a6',
            -foreground => 'white',
            -font => ['Arial', 10, 'bold'],
            -width => 15,
            -cursor => 'hand2',
        )->pack();
    };
    
    if ($@) {
        main::log_message('ERROR', "Error creating temperature details window: $@");
        $self->{root}->messageBox(
            -title => "Display Error",
            -message => "Failed to show temperature details.\n\nError: $@",
            -type => 'OK',
            -icon => 'error',
        );
    }
}

sub _populate_temperature_details {
    my ($self, $parent, $nodes_to_show) = @_;
    
    foreach my $nn (sort keys %$nodes_to_show) {
        eval {
            my $temp_info = $nodes_to_show->{$nn};
            
            # Node header
            my $node_frame = $parent->Frame(
                -background => '#ecf0f1',
                -relief => 'raised',
                -borderwidth => 2,
            )->pack(-fill => 'x', -padx => 10, -pady => 10);
            
            my $header_frame = $node_frame->Frame(
                -background => '#34495e',
            )->pack(-fill => 'x');
            
            my $display_node_name = $nn;
            if (length($display_node_name) > 30) {
                $display_node_name = substr($display_node_name, 0, 27) . "...";
            }
            
            $header_frame->Label(
                -text => "Node: $display_node_name",
                -font => ['Arial', 12, 'bold'],
                -background => '#34495e',
                -foreground => 'white',
                -anchor => 'w',
            )->pack(-side => 'left', -padx => 10, -pady => 8);
            
            my $node_ip = $self->{node_addresses}->{$nn} || 'unknown';
            $header_frame->Label(
                -text => "IP: $node_ip:8898 (HTTPS)",
                -font => ['Arial', 9],
                -background => '#34495e',
                -foreground => '#bdc3c7',
                -anchor => 'e',
            )->pack(-side => 'right', -padx => 10, -pady => 8);
            
            my $sensors = $temp_info->{sensors} || [];
            my $status = $temp_info->{status};
            
            if ($status ne 'ok' || !@$sensors) {
                my $msg = $status ne 'ok' ? "Status: $status" : "No sensors found";
                $node_frame->Label(
                    -text => $msg,
                    -font => ['Arial', 10],
                    -background => '#ecf0f1',
                    -foreground => '#e74c3c',
                )->pack(-padx => 10, -pady => 10);
                next;
            }
            
            # Group sensors by type
            my %sensor_groups = (
                cpu_package => [],
                cpu_core => [],
                thermal_zone => [],
                motherboard => [],
                nvme => [],
                other => [],
            );
            
            foreach my $sensor (@$sensors) {
                my $sensor_type = $sensor->{type} || 'other';
                push @{$sensor_groups{$sensor_type}}, $sensor;
            }
            
            # Display sensors
            my @display_order = qw(cpu_package cpu_core thermal_zone motherboard nvme other);
            my %type_names = (
                cpu_package => 'CPU Package',
                cpu_core => 'CPU Cores',
                thermal_zone => 'Thermal Zones',
                motherboard => 'Motherboard',
                nvme => 'NVMe Drives',
                other => 'Other Sensors',
            );
            
            my $max_sensors_per_type = 20;
            my $total_displayed = 0;
            
            foreach my $sensor_type (@display_order) {
                my $group_sensors = $sensor_groups{$sensor_type};
                next unless @$group_sensors;
                
                # Type header
                my $type_frame = $node_frame->Frame(
                    -background => '#ecf0f1',
                )->pack(-fill => 'x', -padx => 10, -pady => [10, 5]);
                
                $type_frame->Label(
                    -text => $type_names{$sensor_type},
                    -font => ['Arial', 10, 'bold'],
                    -background => '#ecf0f1',
                    -foreground => '#2c3e50',
                )->pack(-anchor => 'w');
                
                my @sensors_to_show = @$group_sensors[0..min($max_sensors_per_type-1, $#$group_sensors)];
                my $remaining = scalar(@$group_sensors) - scalar(@sensors_to_show);
                
                foreach my $sensor (@sensors_to_show) {
                    my $temp = $sensor->{temperature};
                    my $label_text = $sensor->{label} || 'Unknown';
                    my $chip = $sensor->{chip} || 'N/A';
                    
                    # Truncate long text
                    if (length($label_text) > 40) {
                        $label_text = substr($label_text, 0, 37) . "...";
                    }
                    if (length($chip) > 30) {
                        $chip = substr($chip, 0, 27) . "...";
                    }
                    
                    my $sensor_frame = $node_frame->Frame(
                        -background => 'white',
                    )->pack(-fill => 'x', -padx => 20, -pady => 2);
                    
                    my $temp_color = $self->get_temp_color($temp);
                    
                    $sensor_frame->Label(
                        -text => "$label_text:",
                        -font => ['Arial', 9],
                        -background => 'white',
                        -anchor => 'w',
                        -width => 30,
                    )->pack(-side => 'left');
                    
                    $sensor_frame->Label(
                        -text => "${temp}°C",
                        -font => ['Arial', 9, 'bold'],
                        -background => 'white',
                        -foreground => $temp_color,
                        -width => 10,
                    )->pack(-side => 'left');
                    
                    $sensor_frame->Label(
                        -text => "($chip)",
                        -font => ['Arial', 8],
                        -background => 'white',
                        -foreground => '#7f8c8d',
                    )->pack(-side => 'left', -padx => 5);
                    
                    $total_displayed++;
                }
                
                if ($remaining > 0) {
                    my $more_frame = $node_frame->Frame(
                        -background => 'white',
                    )->pack(-fill => 'x', -padx => 20, -pady => 2);
                    
                    $more_frame->Label(
                        -text => "... and $remaining more " . lc($type_names{$sensor_type}),
                        -font => ['Arial', 8, 'italic'],
                        -background => 'white',
                        -foreground => '#7f8c8d',
                    )->pack(-anchor => 'w');
                }
            }
            
            if ($total_displayed > 0) {
                my $summary_frame = $node_frame->Frame(
                    -background => '#ecf0f1',
                )->pack(-fill => 'x', -padx => 10, -pady => 10);
                
                $summary_frame->Label(
                    -text => "Showing $total_displayed of " . scalar(@$sensors) . " total sensors",
                    -font => ['Arial', 8],
                    -background => '#ecf0f1',
                    -foreground => '#7f8c8d',
                )->pack();
            }
        };
        
        if ($@) {
            main::log_message('ERROR', "Error displaying sensors for node $nn: $@");
        }
    }
}

sub min {
    my ($a, $b) = @_;
    return $a < $b ? $a : $b;
}

sub create_widgets {
    my ($self) = @_;
    
    # Top bar
    my $top_frame = $self->{root}->Frame(
        -background => '#2c3e50',
        -height => 140,
    )->pack(-fill => 'x');
    
    # Node Temperature Frame
    $self->{node_temp_container} = $self->{root}->Frame(
        -background => '#34495e',
        -height => 40,
    )->pack(-fill => 'x');
    
    $self->{node_temp_frame} = $self->{node_temp_container}->Frame(
        -background => '#34495e',
    )->pack(-side => 'left', -padx => 10, -pady => 5, -fill => 'both', -expand => 1);
    
    $self->{node_temp_frame}->Label(
        -text => "Node Temperatures:",
        -font => ['Arial', 9, 'bold'],
        -background => '#34495e',
        -foreground => '#bdc3c7',
    )->pack(-side => 'left', -padx => [0, 10]);
    
    # Details button
    my $details_btn = $self->{node_temp_container}->Button(
        -text => "[Details]",
        -command => sub { $self->show_temperature_details(undef) },
        -background => '#3498db',
        -foreground => 'white',
        -font => ['Arial', 9, 'bold'],
        -cursor => 'hand2',
        -relief => 'flat',
        -padx => 10,
        -pady => 5,
    )->pack(-side => 'right', -padx => 10, -pady => 5);
    
    # Left section: Title
    my $title_label = $top_frame->Label(
        -text => "Proxmox VM/CT Dashboard",
        -font => ['Arial', 18, 'bold'],
        -background => '#2c3e50',
        -foreground => 'white',
    )->pack(-side => 'left', -padx => 20, -pady => 50);
    
    # Right section: Status indicators
    $self->{status_frame} = $top_frame->Frame(
        -background => '#2c3e50',
    )->pack(-side => 'right', -padx => 20, -pady => 10);
    
    # Center section: VM Summary
    my $vm_summary_container = $top_frame->Frame(
        -background => '#2c3e50',
    )->pack(-side => 'left', -fill => 'both', -expand => 1);
    
    my $vm_summary_frame = $vm_summary_container->Frame(
        -background => '#2c3e50',
    )->place(-relx => 0.5, -rely => 0.5, -anchor => 'center');
    
    my $summary_title = $vm_summary_frame->Label(
        -text => "VMs/CTs:",
        -font => ['Arial', 12, 'bold'],
        -background => '#2c3e50',
        -foreground => '#ecf0f1',
    )->pack(-pady => [0, 5]);
    
    # Running count
    my $running_summary_frame = $vm_summary_frame->Frame(
        -background => '#2c3e50',
    )->pack(-pady => 2);
    
    $self->{running_led} = $self->create_led_indicator($running_summary_frame, '#27ae60', 8);
    $self->{running_led}->pack(-side => 'left', -padx => [0, 5]);
    
    $self->{running_count_label} = $running_summary_frame->Label(
        -text => "Running: 0",
        -font => ['Arial', 10],
        -background => '#2c3e50',
        -foreground => '#27ae60',
    )->pack(-side => 'left');
    
    # Stopped count
    my $stopped_summary_frame = $vm_summary_frame->Frame(
        -background => '#2c3e50',
    )->pack(-pady => 2);
    
    $self->{stopped_led} = $self->create_led_indicator($stopped_summary_frame, '#e74c3c', 8);
    $self->{stopped_led}->pack(-side => 'left', -padx => [0, 5]);
    
    $self->{stopped_count_label} = $stopped_summary_frame->Label(
        -text => "Stopped: 0",
        -font => ['Arial', 10],
        -background => '#2c3e50',
        -foreground => '#e74c3c',
    )->pack(-side => 'left');
    
    # Status indicators
    # Row 0: Connection and LIVE
    my $connection_frame = $self->{status_frame}->Frame(
        -background => '#2c3e50',
    )->grid(-row => 0, -column => 0, -sticky => 'w', -padx => 5, -pady => 3);
    
    $self->{connection_led} = $self->create_led_indicator($connection_frame, '#27ae60');
    $self->{connection_led}->pack(-side => 'left', -padx => [0, 5]);
    
    $self->{connection_label} = $connection_frame->Label(
        -text => "Connected",
        -font => ['Arial', 10, 'bold'],
        -background => '#2c3e50',
        -foreground => '#27ae60',
    )->pack(-side => 'left');
    
    my $live_frame = $self->{status_frame}->Frame(
        -background => '#2c3e50',
    )->grid(-row => 0, -column => 1, -sticky => 'w', -padx => 15, -pady => 3);
    
    $self->{live_led} = $self->create_led_indicator($live_frame, '#27ae60');
    $self->{live_led}->pack(-side => 'left', -padx => [0, 5]);
    
    $self->{live_indicator} = $live_frame->Label(
        -text => "LIVE",
        -font => ['Arial', 10, 'bold'],
        -background => '#2c3e50',
        -foreground => '#27ae60',
    )->pack(-side => 'left');
    
    # Row 1: SSL and Nodes
    my $ssl_frame = $self->{status_frame}->Frame(
        -background => '#2c3e50',
    )->grid(-row => 1, -column => 0, -sticky => 'w', -padx => 5, -pady => 3);
    
    $self->{ssl_label} = $ssl_frame->Label(
        -text => "SSL: Checking...",
        -font => ['Arial', 10],
        -background => '#2c3e50',
        -foreground => 'white',
    )->pack();
    
    my $nodes_frame = $self->{status_frame}->Frame(
        -background => '#2c3e50',
    )->grid(-row => 1, -column => 1, -sticky => 'w', -padx => 15, -pady => 3);
    
    $self->{node_label} = $nodes_frame->Label(
        -text => "Nodes: 0",
        -font => ['Arial', 10],
        -background => '#2c3e50',
        -foreground => 'white',
    )->pack();
    
    # Row 2: Last update
    my $update_frame = $self->{status_frame}->Frame(
        -background => '#2c3e50',
    )->grid(-row => 2, -column => 0, -sticky => 'w', -padx => 5, -pady => 3, -columnspan => 2);
    
    $self->{last_update_label} = $update_frame->Label(
        -text => "Updated: --",
        -font => ['Arial', 9],
        -background => '#2c3e50',
        -foreground => '#bdc3c7',
    )->pack();
    
    # Control panel
    my $control_frame = $self->{root}->Frame(
        -background => '#ecf0f1',
        -height => 80,
    )->pack(-fill => 'x');
    
    my $btn_container = $control_frame->Frame(
        -background => '#ecf0f1',
    )->pack(-pady => 15);
    
    $self->{start_btn} = $btn_container->Button(
        -text => "Start",
        -command => sub { $self->start_selected() },
        -background => '#27ae60',
        -foreground => 'white',
        -font => ['Arial', 11, 'bold'],
        -width => 12,
        -height => 2,
        -cursor => 'hand2',
        -relief => 'raised',
        -borderwidth => 2,
    )->pack(-side => 'left', -padx => 5);
    
    $self->{stop_btn} = $btn_container->Button(
        -text => "Stop",
        -command => sub { $self->stop_selected() },
        -background => '#e74c3c',
        -foreground => 'white',
        -font => ['Arial', 11, 'bold'],
        -width => 12,
        -height => 2,
        -cursor => 'hand2',
        -relief => 'raised',
        -borderwidth => 2,
    )->pack(-side => 'left', -padx => 5);
    
    $btn_container->Button(
        -text => "Refresh",
        -command => sub { $self->refresh_data_async() },
        -background => '#3498db',
        -foreground => 'white',
        -font => ['Arial', 11, 'bold'],
        -width => 12,
        -height => 2,
        -cursor => 'hand2',
        -relief => 'raised',
        -borderwidth => 2,
    )->pack(-side => 'left', -padx => 5);
    
    $btn_container->Button(
        -text => "Start All",
        -command => sub { $self->start_all_stopped() },
        -background => '#16a085',
        -foreground => 'white',
        -font => ['Arial', 11, 'bold'],
        -width => 12,
        -height => 2,
        -cursor => 'hand2',
        -relief => 'raised',
        -borderwidth => 2,
    )->pack(-side => 'left', -padx => 5);
    
    $btn_container->Button(
        -text => "Change Credentials",
        -command => sub { $self->change_credentials() },
        -background => '#9b59b6',
        -foreground => 'white',
        -font => ['Arial', 10, 'bold'],
        -width => 15,
        -height => 2,
        -cursor => 'hand2',
        -relief => 'raised',
        -borderwidth => 2,
    )->pack(-side => 'left', -padx => 5);
    
    # Live feed controls
    my $live_controls = $btn_container->Frame(
        -background => '#ecf0f1',
    )->pack(-side => 'left', -padx => 15);
    
    $self->{pause_resume_btn} = $live_controls->Button(
        -text => "Pause Live",
        -command => sub { $self->toggle_auto_refresh() },
        -background => '#e67e22',
        -foreground => 'white',
        -font => ['Arial', 10, 'bold'],
        -width => 12,
        -cursor => 'hand2',
        -relief => 'raised',
        -borderwidth => 2,
    )->pack(-side => 'left', -padx => 5);
    
    # Refresh rate selector
    my $rate_frame = $live_controls->Frame(
        -background => '#ecf0f1',
    )->pack(-side => 'left', -padx => 10);
    
    $rate_frame->Label(
        -text => "Update every:",
        -font => ['Arial', 9],
        -background => '#ecf0f1',
    )->pack(-side => 'left');
    
    foreach my $rate ([2, '2s'], [3, '3s'], [5, '5s'], [10, '10s'], [30, '30s']) {
        my ($value, $text) = @$rate;
        my $rb = $rate_frame->Radiobutton(
            -text => $text,
            -variable => \$self->{refresh_rate},
            -value => $value,
            -command => sub { $self->update_refresh_rate() },
            -font => ['Arial', 10],
            -bg => '#ecf0f1',
            -activebackground => '#ecf0f1',
            -indicatoron => 1,
        )->pack(-side => 'left', -padx => 2);
    }
    
    # Search bar
    my $search_frame = $self->{root}->Frame(
        -background => '#ecf0f1',
        -height => 40,
    )->pack(-fill => 'x');
    
    $search_frame->Label(
        -text => "Search:",
        -font => ['Arial', 10],
        -background => '#ecf0f1',
    )->pack(-side => 'left', -padx => 10);
    
    $self->{search_entry} = $search_frame->Entry(
        -font => ['Arial', 10],
        -width => 30,
    )->pack(-side => 'left', -padx => 5);
    
    $self->{search_entry}->bind('<KeyRelease>', sub { $self->filter_vms() });
    
    $search_frame->Label(
        -text => "Filter by ID, Name, Type, Status, Node",
        -font => ['Arial', 9],
        -background => '#ecf0f1',
        -foreground => '#7f8c8d',
    )->pack(-side => 'left', -padx => 10);
    
    # Table with scrollbars
    my $table_container = $self->{root}->Frame()->pack(
        -fill => 'both',
        -expand => 1,
        -padx => 10,
        -pady => 10,
    );
    
    # Create custom header row with centered labels
    # (HList native headers don't support centering)
    my $header_frame = $table_container->Frame(
        -background => '#3498db',
        -relief => 'raised',
        -borderwidth => 2,
    )->pack(-fill => 'x', -side => 'top');
    
    my @columns = (
        ['ID', 10],
        ['Type', 10],
        ['Status', 12],
        ['Name', 35],
        ['Node', 18],
        ['Cores', 10],
        ['Sockets', 10],
        ['CPU', 20],
        ['Memory', 25],
        ['Disk', 18],
        ['TotalFS', 18],
        ['FreeDisk', 18],
        ['Free%', 12],
    );
    
    # Create centered header labels
    foreach my $col_def (@columns) {
        my ($col_name, $col_width) = @$col_def;
        my $label = $header_frame->Label(
            -text => $col_name,
            -font => ['Arial', 11, 'bold'],
            -background => '#3498db',
            -foreground => 'white',
            -width => $col_width,
            -anchor => 'center',
            -relief => 'flat',
        )->pack(-side => 'left', -fill => 'both', -expand => 0);
    }
    
    # Use HList for table-like display (without native headers now)
    $self->{tree} = $table_container->Scrolled(
        'HList',
        -header => 0,  # Disable native headers, we created custom ones above
        -columns => 13,
        -scrollbars => 'se',
        -width => 200,
        -height => 12,
        -selectmode => 'single',
        -background => 'white',
        -foreground => 'black',
        -separator => '/',
        -itemtype => 'text',
        -selectbackground => '#3498db',
        -selectforeground => 'white',
        -indent => 10,
        -font => ['Arial', 11],
        -gap => 8,  # Add vertical spacing between rows
    )->pack(-fill => 'both', -expand => 1);
    
    # Create a centered text style for table cells
    $self->{centered_style} = $self->{tree}->ItemStyle('text',
        -anchor => 'center',
        -font => ['Arial', 11],
    );
    
    # Set column widths to match header labels
    for my $i (0..$#columns) {
        my ($col_name, $col_width) = @{$columns[$i]};
        $self->{tree}->column('width', $i, -char => $col_width);
    }
    
    # Store column definitions for later use
    
    # Store color mappings for direct application
    $self->{status_colors} = {
        running => { bg => '#27ae60', fg => 'white' },      # Green background, white text
        stopped => { bg => '#e74c3c', fg => 'white' },      # Red background, white text
        normal => { bg => 'white', fg => 'black' },         # White background, black text
        hover => { bg => '#5dade2', fg => 'white' },        # Light blue hover
    };
    
    # Add hover bindings for mouse over effect
    $self->{tree}->bind('<Motion>', sub {
        my $w = shift;
        my $e = $w->XEvent;
        my $entry = $w->nearest($e->y);
        
        # Store current hover entry
        if ($entry && (!$self->{hover_entry} || $self->{hover_entry} ne $entry)) {
            # Restore previous hover entry to normal style
            if ($self->{hover_entry}) {
                $self->restore_row_style($self->{hover_entry});
            }
            
            # Apply hover style to new entry (all columns)
            $self->apply_row_style($entry, 'hover');
            
            $self->{hover_entry} = $entry;
        }
    });
    
    $self->{tree}->bind('<Leave>', sub {
        my $w = shift;
        # Restore hover entry when leaving the widget
        if ($self->{hover_entry}) {
            $self->restore_row_style($self->{hover_entry});
            $self->{hover_entry} = undef;
        }
    });
    
    # Status bar
    my $status_bar = $self->{root}->Frame(
        -background => '#34495e',
        -height => 30,
    )->pack(-fill => 'x');
    
    $self->{status_label} = $status_bar->Label(
        -text => "Ready",
        -font => ['Arial', 9],
        -background => '#34495e',
        -foreground => 'white',
        -anchor => 'w',
    )->pack(-side => 'left', -padx => 10, -fill => 'x', -expand => 1);
}

sub authenticate {
    my ($self) = @_;
    
    
    # Track authentication result outside eval
    my $auth_result = 0;
    
    eval {
        if (-e $main::CREDENTIALS_FILE) {
            
            while (1) {
                my $dialog = $self->{root}->DialogBox(
                    -title => "Master Password",
                    -buttons => ["OK", "Cancel"],
                );
                
                $dialog->add('Label', -text => "Enter your master password:")->pack();
                my $entry = $dialog->add('Entry', -show => '*', -width => 30)->pack();
                $entry->focus();
                
                my $answer = $dialog->Show();
                
                if ($answer eq "Cancel") {
                    $auth_result = 0;
                    return;  # Exit eval - user cancelled
                }
                
                my $master_password = $entry->get();
                
                
                # Try to decrypt credentials
                my $creds;
                eval {
                    $creds = CredentialManager::load_credentials($master_password);
                };
                
                if ($@) {
                    main::log_message('ERROR', "Failed to decrypt credentials: $@");
                    $self->{root}->messageBox(
                        -title => "Decryption Error",
                        -message => "Failed to decrypt credentials:\n$@\n\nPlease check your master password.",
                        -type => 'OK',
                        -icon => 'error',
                    );
                    next;
                }
                
                unless ($creds) {
                    main::log_message('ERROR', "No credentials returned from load");
                    $self->{root}->messageBox(
                        -title => "Error",
                        -message => "No credentials found in file.",
                        -type => 'OK',
                        -icon => 'error',
                    );
                    next;
                }
                
                
                # Try to authenticate
                eval {
                    $self->{api} = ProxmoxAPI->new(
                        $creds->{host},
                        $creds->{token_id},
                        $creds->{token_secret},
                    );
                    
                    
                    $self->{status_label}->configure(-text => "Connected to $creds->{host}");
                    $self->{ssl_label}->configure(-text => "SSL: " . $self->{api}->{ssl_status});
                    $self->{connection_healthy} = 1;
                };
                
                if ($@) {
                    main::log_message('ERROR', "Authentication failed with stored credentials: $@");
                    
                    my $response = $self->{root}->messageBox(
                        -title => "Authentication Failed",
                        -message => "Failed to authenticate with stored credentials:\n\n$@\n\n" .
                                   "The API token may have been revoked or is invalid.\n\n" .
                                   "Would you like to delete the old credentials and set up new ones?",
                        -type => 'YesNo',
                        -icon => 'warning',
                    );
                    
                    if ($response eq 'Yes') {
                        eval {
                            unlink $main::CREDENTIALS_FILE;
                        };
                        
                        if ($@) {
                            main::log_message('ERROR', "Failed to delete credentials file: $@");
                        }
                        
                        $self->{root}->messageBox(
                            -title => "Credentials Deleted",
                            -message => "Old credentials have been deleted.\n\n" .
                                       "You will now be guided through setting up new credentials.",
                            -type => 'OK',
                            -icon => 'info',
                        );
                        last;
                    } else {
                        next;
                    }
                } else {
                    # Authentication successful
                    $auth_result = 1;
                    return;  # Exit eval successfully
                }
            }
        }
        
        # No credentials file - setup flow
        
        $self->{root}->messageBox(
            -title => "Setup Required",
            -message => "No credentials found.\n\n" .
                       "You'll need to create an API token in Proxmox first.\n\n" .
                       "The next screen will show you how.",
            -type => 'OK',
            -icon => 'info',
        );
        
        my $guide = TokenCreationGuide->new($self->{root});
        $guide->wait_window();
        
        my $dialog = CredentialsDialog->new($self->{root}, 1);
        $dialog->wait_window();
        
        if ($dialog->{result}) {
            my $result = $dialog->{result};
            
            
            # First authenticate with API
            $self->{api} = ProxmoxAPI->new(
                $result->{host},
                $result->{token_id},
                $result->{token_secret},
            );
            
            
            # Then save credentials
            CredentialManager::save_credentials(
                $result->{host},
                $result->{master},
                $result->{token_id},
                $result->{token_secret},
            );
            
            # Verify the file was actually created
            unless (-e $main::CREDENTIALS_FILE) {
                die "Credentials file was not created at $main::CREDENTIALS_FILE";
            }
            
            my $file_size = -s $main::CREDENTIALS_FILE;
            
            if ($file_size == 0) {
                die "Credentials file is empty";
            }
            
            # Try to read it back immediately to verify it works
            my $verify_creds = CredentialManager::load_credentials($result->{master});
            
            unless ($verify_creds) {
                die "Failed to verify saved credentials - could not decrypt";
            }
            
            unless ($verify_creds->{host} eq $result->{host}) {
                die "Credential verification failed - host mismatch";
            }
            
            
            $self->{root}->messageBox(
                -title => "Success",
                -message => "Credentials saved successfully!",
                -type => 'OK',
                -icon => 'info',
            );
            
            $self->{status_label}->configure(-text => "Connected to $result->{host}");
            $self->{ssl_label}->configure(-text => "SSL: " . $self->{api}->{ssl_status});
            $self->{connection_healthy} = 1;
            $auth_result = 1;
            return;  # Exit eval successfully
        }
        
        $auth_result = 0;
        return;  # Exit eval - user cancelled
    };
    
    # Handle Tk exit specially - this is normal when dialogs close
    if ($@ && $@ =~ /_TK_EXIT_/) {
        return $auth_result;
    }
    
    if ($@) {
        main::log_message('CRITICAL', "FATAL ERROR in authenticate(): $@");
        $self->{root}->messageBox(
            -title => "Critical Error",
            -message => "Authentication failed with critical error:\n\n$@",
            -type => 'OK',
            -icon => 'error',
        );
        return 0;
    }
    
    return $auth_result;
}

sub start_task_processor {
    my ($self) = @_;
    
    # Simple task processing - Perl/Tk handles events differently
    # We'll use the task queue for threading operations
}

sub run_async {
    my ($self, $func, $callback) = @_;
    
    # Execute function in a thread
    my $thr = threads->create(sub {
        my $result;
        my $error;
        
        eval {
            $result = $func->();
        };
        
        if ($@) {
            $error = $@;
        }
        
        return { result => $result, error => $error };
    });
    
    # Schedule callback to check thread completion
    $self->{root}->after(100, sub {
        if ($thr->is_joinable()) {
            my $ret = $thr->join();
            if ($callback) {
                $callback->($ret->{result}, $ret->{error});
            }
        } else {
            # Reschedule check
            $self->{root}->after(100, sub { });
        }
    });
}

sub show_loading {
    my ($self, $message) = @_;
    $message = "Loading..." unless defined $message;
    
    $self->{is_loading} = 1;
    $self->{status_label}->configure(-text => "[Loading] $message");
    $self->{root}->configure(-cursor => 'watch');
    $self->{root}->update();
}

sub hide_loading {
    my ($self) = @_;
    
    $self->{is_loading} = 0;
    $self->{root}->configure(-cursor => '');
    $self->{root}->update();
}

sub start_health_check {
    my ($self) = @_;
    
    # Simple periodic health check using after()
    $self->{root}->repeat(60000, sub {
        return unless $self->{api};
        
        eval {
            $self->{api}->get('/version');
            $self->{connection_healthy} = 1;
            $self->{connection_label}->configure(
                -text => "Connected",
                -foreground => '#27ae60',
            );
            $self->update_led_color($self->{connection_led}, '#27ae60');
        };
        
        if ($@) {
            $self->{connection_healthy} = 0;
            $self->{connection_label}->configure(
                -text => "Disconnected",
                -foreground => '#e74c3c',
            );
            $self->update_led_color($self->{connection_led}, '#e74c3c');
            $self->attempt_reconnect();
        }
    });
}

sub attempt_reconnect {
    my ($self) = @_;
    
    return if $self->{is_loading};
    
    my $response = $self->{root}->messageBox(
        -title => "Connection Lost",
        -message => "Connection to Proxmox was lost. Attempt to reconnect?",
        -type => 'YesNo',
        -icon => 'warning',
    );
    
    if ($response eq 'Yes') {
        $self->show_loading("Reconnecting...");
        
        eval {
            $self->{api}->get('/version');
            $self->hide_loading();
            $self->{root}->messageBox(
                -title => "Success",
                -message => "Reconnected successfully!",
                -type => 'OK',
                -icon => 'info',
            );
            $self->refresh_data_async();
        };
        
        if ($@) {
            $self->hide_loading();
            $self->{root}->messageBox(
                -title => "Error",
                -message => "Reconnection failed. Please restart the application.",
                -type => 'OK',
                -icon => 'error',
            );
        }
    }
}

sub filter_vms {
    my ($self) = @_;
    
    my $query = lc($self->{search_entry}->get() || '');
    
    # Clear tree
    $self->{tree}->delete('all');
    
    my $running_count = 0;
    my $stopped_count = 0;
    
    $self->{filtered_vm_data} = [];
    
    foreach my $vm (@{$self->{vm_data}}) {
        if ($query eq '' ||
            index(lc($vm->{id} || ''), $query) >= 0 ||
            index(lc($vm->{name} || ''), $query) >= 0 ||
            index(lc($vm->{type} || ''), $query) >= 0 ||
            index(lc($vm->{status} || ''), $query) >= 0 ||
            index(lc($vm->{node} || ''), $query) >= 0) {
            
            push @{$self->{filtered_vm_data}}, $vm;
            
            my $status = lc($vm->{status});
            if ($status eq 'running') {
                $running_count++;
            } elsif ($status eq 'stopped') {
                $stopped_count++;
            }
            
            # Add to tree
            my $entry = $self->{tree}->add($vm->{id});
            
            # Create all items with centered style
            $self->{tree}->itemCreate($entry, 0, -itemtype => 'text', -text => $vm->{id}, -style => $self->{centered_style});
            $self->{tree}->itemCreate($entry, 1, -itemtype => 'text', -text => $vm->{type}, -style => $self->{centered_style});
            $self->{tree}->itemCreate($entry, 2, -itemtype => 'text', -text => $vm->{status}, -style => $self->{centered_style});
            $self->{tree}->itemCreate($entry, 3, -itemtype => 'text', -text => $vm->{name}, -style => $self->{centered_style});
            $self->{tree}->itemCreate($entry, 4, -itemtype => 'text', -text => $vm->{node}, -style => $self->{centered_style});
            $self->{tree}->itemCreate($entry, 5, -itemtype => 'text', -text => $vm->{cores} || 'N/A', -style => $self->{centered_style});
            $self->{tree}->itemCreate($entry, 6, -itemtype => 'text', -text => $vm->{sockets} || 'N/A', -style => $self->{centered_style});
            $self->{tree}->itemCreate($entry, 7, -itemtype => 'text', -text => $vm->{cpu} || 'N/A', -style => $self->{centered_style});
            $self->{tree}->itemCreate($entry, 8, -itemtype => 'text', -text => $vm->{memory} || 'N/A', -style => $self->{centered_style});
            $self->{tree}->itemCreate($entry, 9, -itemtype => 'text', -text => $vm->{disk} || 'N/A', -style => $self->{centered_style});
            $self->{tree}->itemCreate($entry, 10, -itemtype => 'text', -text => $vm->{total_fs} || 'N/A', -style => $self->{centered_style});
            $self->{tree}->itemCreate($entry, 11, -itemtype => 'text', -text => $vm->{free_disk} || 'N/A', -style => $self->{centered_style});
            $self->{tree}->itemCreate($entry, 12, -itemtype => 'text', -text => $vm->{free_pct} || 'N/A', -style => $self->{centered_style});
            
            # Now apply the appropriate colors based on status
            my $style = 'normal';
            if ($status eq 'running') {
                $style = 'running';
            } elsif ($status eq 'stopped') {
                $style = 'stopped';
            }
            
            # Apply style/colors to the row
            $self->apply_row_style($entry, $style);
        }
    }
    
    # Update counts
    $self->{running_count_label}->configure(-text => "Running: $running_count");
    $self->{stopped_count_label}->configure(-text => "Stopped: $stopped_count");
    
    if ($query) {
        my $total = scalar(@{$self->{vm_data}});
        my $showing = scalar(@{$self->{filtered_vm_data}});
        $self->{status_label}->configure(-text => "Showing $showing of $total VMs/CTs");
    } else {
        my $total = scalar(@{$self->{vm_data}});
        $self->{status_label}->configure(-text => "Ready - $total VMs/CTs across $self->{node_count} node(s)");
    }
}

sub apply_row_style {
    my ($self, $entry, $style_name) = @_;
    
    return unless $entry && $style_name;
    
    my $colors = $self->{status_colors}->{$style_name};
    if ($colors) {
        for my $col (0..12) {
            eval { 
                $self->{tree}->itemConfigure($entry, $col, 
                    -background => $colors->{bg},
                    -foreground => $colors->{fg}
                ); 
            };
        }
    }
}

sub restore_row_style {
    my ($self, $entry) = @_;
    
    return unless $entry;
    
    # Find the VM data for this entry to determine proper style
    my $vmid = $entry;
    my $style = 'normal';
    
    foreach my $vm (@{$self->{vm_data}}) {
        if ($vm->{id} eq $vmid) {
            my $status = lc($vm->{status});
            if ($status eq 'running') {
                $style = 'running';
            } elsif ($status eq 'stopped') {
                $style = 'stopped';
            }
            last;
        }
    }
    
    # Use apply_row_style to handle both style and direct color approaches
    $self->apply_row_style($entry, $style);
}

sub format_bytes {
    my ($self, $bytes_val) = @_;
    
    return 'N/A' unless defined $bytes_val && $bytes_val ne 'N/A';
    
    my $result;
    eval {
        $bytes_val = 0 + $bytes_val;  # Force numeric
        
        if ($bytes_val < 0) {
            $result = 'N/A';
            return;
        }
        
        my @units = ('B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB');
        
        foreach my $unit (@units) {
            if ($bytes_val < 1024 || $unit eq 'PiB') {
                $result = sprintf("%.1f%s", $bytes_val, $unit);
                return;
            }
            $bytes_val /= 1024;
        }
    };
    
    if ($@) {
        main::log_message('ERROR', "Error formatting bytes value: $@");
        return 'N/A';
    }
    
    return $result || 'N/A';
}

sub fetch_single_vm_data {
    my ($self, $node, $vm, $vm_type) = @_;
    
    my $n = $node->{node};
    my $endpoint = $vm_type eq 'VM' ? 'qemu' : 'lxc';
    my $vmid = $vm->{vmid};
    
    # Initialize with defaults
    my $cores = 'N/A';
    my $memory = 'N/A';
    my $total_disk = 'N/A';
    my $sockets = 'N/A';
    my $cpu_type = 'N/A';
    
    # Get config - this is critical, if it fails we can't show the VM
    my $cfg;
    eval {
        $cfg = $self->{api}->get("/nodes/$n/$endpoint/$vmid/config");
    };
    
    if ($@) {
        main::log_message('ERROR', "Failed to get config for $vm_type $vmid: $@");
        return undef;  # Can't show VM without config
    }
    
    # Extract cores (safely)
    eval {
        $cores = $cfg->{cores} || 'N/A';
    };
    
    # Memory (safely)
    eval {
        if ($vm_type eq 'VM') {
            my $memory_val = $cfg->{memory} || 0;
            $memory_val = int($memory_val) if $memory_val;
            
            main::log_message('ERROR', "DEBUG VM $vmid: Raw memory value = $memory_val, balloon = " . ($cfg->{balloon} // 'none'));
            
            if (exists $cfg->{balloon}) {
                my $balloon_val = int($cfg->{balloon} || $memory_val);
                my $minmem = int($balloon_val);
                my $maxmem = int($memory_val);
                
                if ($minmem > 0 && $maxmem > 0) {
                    my $minmem_str = $self->format_bytes($minmem * 1024 * 1024);
                    my $maxmem_str = $self->format_bytes($maxmem * 1024 * 1024);
                    $memory = "$minmem_str-$maxmem_str";
                    main::log_message('ERROR', "DEBUG VM $vmid: Memory formatted as $memory");
                } else {
                    $memory = $memory_val ? $self->format_bytes($memory_val * 1024 * 1024) : 'N/A';
                }
            } else {
                $memory = $memory_val ? $self->format_bytes($memory_val * 1024 * 1024) : 'N/A';
                main::log_message('ERROR', "DEBUG VM $vmid: No balloon, memory = $memory");
            }
        } else {
            my $memory_mb = int($cfg->{memory} || 0);
            my $swap_mb = int($cfg->{swap} || 0);
            
            main::log_message('ERROR', "DEBUG CT $vmid: memory=$memory_mb MB, swap=$swap_mb MB");
            
            if ($memory_mb > 0) {
                my $mem_str = $self->format_bytes($memory_mb * 1024 * 1024);
                if ($swap_mb > 0) {
                    my $swap_str = $self->format_bytes($swap_mb * 1024 * 1024);
                    $memory = "$mem_str+$swap_str";
                } else {
                    $memory = $mem_str;
                }
            } else {
                $memory = 'N/A';
            }
            main::log_message('ERROR', "DEBUG CT $vmid: Final memory = $memory");
        }
    };
    
    if ($@) {
        main::log_message('ERROR', "Error parsing memory for $vm_type $vmid: $@");
    }
    
    # Disk size (safely)
    eval {
        if ($vm_type eq 'VM') {
            foreach my $key (sort keys %$cfg) {
                if ($key =~ /^(scsi0|sata0|ide0|virtio0)$/) {
                    my $value = $cfg->{$key};
                    if ($value =~ /size=([^,]+)/) {
                        my $size_str = $1;
                        if ($size_str =~ /^(\d+)G$/) {
                            $total_disk = "${1}GiB";
                        }
                        last;
                    }
                }
            }
        } else {
            my $rootfs = $cfg->{rootfs} || '';
            if ($rootfs =~ /size=([^,]+)/) {
                my $size_str = $1;
                if ($size_str =~ /^(\d+)G$/) {
                    $total_disk = "${1}GiB";
                }
            }
        }
    };
    
    if ($@) {
        main::log_message('ERROR', "Error parsing disk size for $vm_type $vmid: $@");
    }
    
    # Free disk - only if running
    my ($free_disk, $free_pct, $total_fs) = ('N/A', 'N/A', 'N/A');
        
        if ($vm->{status} eq 'running') {
            main::log_message('ERROR', "DEBUG $vm_type $vmid: VM is running, checking filesystem data");
            
            if ($vm_type eq 'VM') {
                # Try guest agent first (may fail if not installed/running)
                eval {
                    main::log_message('ERROR', "DEBUG VM $vmid: Trying guest agent get-fsinfo");
                    my $fsinfo = $self->{api}->get("/nodes/$n/qemu/$vmid/agent/get-fsinfo");
                    
                    if ($fsinfo && $fsinfo->{result}) {
                        my @filesystems = @{$fsinfo->{result}};
                        main::log_message('ERROR', "DEBUG VM $vmid: Guest agent returned " . scalar(@filesystems) . " filesystems");
                        
                        my %excluded_types = map { $_ => 1 } qw(iso9660 udf tmpfs devtmpfs);
                        my %included_mountpoints = map { $_ => 1 } qw(/ /boot /home /var /tmp /usr);
                        
                        my $total_bytes_sum = 0;
                        my $used_bytes_sum = 0;
                        
                        foreach my $fs (@filesystems) {
                            my $fs_type = lc($fs->{type} || '');
                            my $mountpoint = $fs->{mountpoint} || '';
                            
                            next if $excluded_types{$fs_type};
                            next unless $included_mountpoints{$mountpoint};
                            
                            if (exists $fs->{'total-bytes'} && exists $fs->{'used-bytes'}) {
                                my $fs_total = $fs->{'total-bytes'};
                                my $fs_used = $fs->{'used-bytes'};
                                
                                if ($fs_total > 0) {
                                    $total_bytes_sum += $fs_total;
                                    $used_bytes_sum += $fs_used;
                                    main::log_message('ERROR', "DEBUG VM $vmid: Added filesystem $mountpoint: total=$fs_total, used=$fs_used");
                                }
                            }
                        }
                        
                        if ($total_bytes_sum > 0) {
                            $total_fs = $self->format_bytes($total_bytes_sum);
                            my $free_bytes = $total_bytes_sum - $used_bytes_sum;
                            if ($free_bytes >= 0) {
                                $free_disk = $self->format_bytes($free_bytes);
                                $free_pct = sprintf("%.1f%%", ($free_bytes / $total_bytes_sum * 100));
                                main::log_message('ERROR', "DEBUG VM $vmid: Guest agent success - TotalFS=$total_fs, FreeDisk=$free_disk, Free%=$free_pct");
                            }
                        } else {
                            main::log_message('ERROR', "DEBUG VM $vmid: Guest agent returned filesystems but total_bytes_sum = 0");
                        }
                    } else {
                        main::log_message('ERROR', "DEBUG VM $vmid: Guest agent returned no result");
                    }
                };
                
                if ($@) {
                    # Guest agent errors are expected when agent is not installed/running
                    main::log_message('ERROR', "DEBUG VM $vmid: Guest agent failed - $@");
                }
                
                # Fallback to status if guest agent fails or returns no data
                if ($total_fs eq 'N/A') {
                    eval {
                        main::log_message('ERROR', "DEBUG VM $vmid: Trying status API fallback");
                        my $stat = $self->{api}->get("/nodes/$n/qemu/$vmid/status/current");
                        
                        # Log the full status response to see what we're getting
                        if ($stat) {
                            main::log_message('ERROR', "DEBUG VM $vmid: Status API returned - disk=" . ($stat->{disk} // 'undef') . 
                                ", maxdisk=" . ($stat->{maxdisk} // 'undef'));
                        } else {
                            main::log_message('ERROR', "DEBUG VM $vmid: Status API returned undef/empty");
                        }
                        
                        my $disk_used = $stat->{disk} || 0;
                        my $disk_max = $stat->{maxdisk} || 0;
                        
                        main::log_message('ERROR', "DEBUG VM $vmid: After defaults - disk_used=$disk_used, disk_max=$disk_max");
                        
                        if ($disk_max > 0 && $disk_used >= 0) {
                            $total_fs = $self->format_bytes($disk_max);
                            my $free_bytes = $disk_max - $disk_used;
                            if ($free_bytes >= 0) {
                                $free_disk = $self->format_bytes($free_bytes);
                                $free_pct = sprintf("%.1f%%", ($free_bytes / $disk_max * 100));
                                main::log_message('ERROR', "DEBUG VM $vmid: Status API success - TotalFS=$total_fs, FreeDisk=$free_disk");
                            }
                        } else {
                            main::log_message('ERROR', "DEBUG VM $vmid: Status API disk_max is 0, cannot calculate filesystem usage");
                        }
                    };
                    
                    if ($@) {
                        main::log_message('ERROR', "DEBUG VM $vmid: Status API failed with error - $@");
                    }
                }
            } else {
                # CT - use status API
                eval {
                    main::log_message('ERROR', "DEBUG CT $vmid: Trying status API");
                    my $stat = $self->{api}->get("/nodes/$n/lxc/$vmid/status/current");
                    
                    # Log what we got
                    if ($stat) {
                        main::log_message('ERROR', "DEBUG CT $vmid: Status API returned - disk=" . ($stat->{disk} // 'undef') . 
                            ", maxdisk=" . ($stat->{maxdisk} // 'undef'));
                    } else {
                        main::log_message('ERROR', "DEBUG CT $vmid: Status API returned undef/empty");
                    }
                    
                    my $disk_used = $stat->{disk} || 0;
                    my $disk_max = $stat->{maxdisk} || 0;
                    
                    main::log_message('ERROR', "DEBUG CT $vmid: After defaults - disk_used=$disk_used, disk_max=$disk_max");
                    
                    if ($disk_max > 0 && $disk_used >= 0) {
                        $total_fs = $self->format_bytes($disk_max);
                        my $free_bytes = $disk_max - $disk_used;
                        if ($free_bytes >= 0) {
                            $free_disk = $self->format_bytes($free_bytes);
                            $free_pct = sprintf("%.1f%%", ($free_bytes / $disk_max * 100));
                            main::log_message('ERROR', "DEBUG CT $vmid: Status API success - TotalFS=$total_fs, FreeDisk=$free_disk");
                        }
                    } else {
                        main::log_message('ERROR', "DEBUG CT $vmid: Status API disk_max is 0, cannot calculate filesystem usage");
                    }
                };
                
                if ($@) {
                    main::log_message('ERROR', "DEBUG CT $vmid: Status API failed with error - $@");
                }
            }
        } else {
            main::log_message('ERROR', "DEBUG $vm_type $vmid: VM is stopped, skipping filesystem data");
        }
        
        # Extract sockets and CPU type safely
        eval {
            $sockets = ($vm_type eq 'VM') ? ($cfg->{sockets} || 'N/A') : 'N/A';
            $cpu_type = ($vm_type eq 'VM') ? ($cfg->{cpu} || 'N/A') : 'N/A';
        };
        
        if ($@) {
            main::log_message('ERROR', "Error parsing sockets/cpu for $vm_type $vmid: $@");
        }
        
        # Return VM data
        my $result = {
            id => $vmid,
            type => $vm_type,
            status => $vm->{status},
            name => $vm->{name},
            node => $n,
            cores => $cores,
            sockets => $sockets,
            cpu => $cpu_type,
            memory => $memory,
            disk => $total_disk,
            total_fs => $total_fs,
            free_disk => $free_disk,
            free_pct => $free_pct,
        };
        
        main::log_message('ERROR', "DEBUG $vm_type $vmid: FINAL DATA - memory=$memory, total_fs=$total_fs, free_disk=$free_disk");
        
        return $result;
}

sub refresh_data_async {
    my ($self) = @_;
    
    return if $self->{is_loading};
    
    unless ($self->{api}) {
        $self->{status_label}->configure(-text => "Not connected");
        $self->{connection_label}->configure(-text => "Disconnected", -foreground => '#e74c3c');
        $self->update_led_color($self->{connection_led}, '#e74c3c');
        return;
    }
    
    $self->{is_loading} = 1;
    $self->{status_label}->configure(-text => "Fetching data...");
    $self->{root}->update();  # Force UI update
    
    # Use after() to avoid blocking - fetch data in chunks
    $self->{root}->after(10, sub {
        my @vm_data;
        my $error;
        
        eval {
            my $nodes = $self->{api}->get('/nodes');
            
            unless ($nodes && ref($nodes) eq 'ARRAY') {
                die "Failed to get nodes list - invalid response";
            }
            
            $self->{node_count} = scalar(@$nodes);
            $self->{node_label}->configure(-text => "Nodes: $self->{node_count}");
            
            foreach my $node (@$nodes) {
                my $n = $node->{node};
                
                # Get VMs
                my $vms = $self->{api}->get("/nodes/$n/qemu");
                if ($vms && ref($vms) eq 'ARRAY') {
                    main::log_message('ERROR', "DEBUG: Processing " . scalar(@$vms) . " VMs on node $n");
                    foreach my $vm (@$vms) {
                        main::log_message('ERROR', "DEBUG: Calling fetch_single_vm_data for VM " . $vm->{vmid});
                        my $vm_data = $self->fetch_single_vm_data($node, $vm, 'VM');
                        if ($vm_data) {
                            push @vm_data, $vm_data;
                            main::log_message('ERROR', "DEBUG: Successfully added VM " . $vm_data->{id} . " to array");
                        } else {
                            main::log_message('ERROR', "DEBUG: fetch_single_vm_data returned undef for VM " . $vm->{vmid});
                        }
                    }
                }
                
                # Get containers
                my $cts = $self->{api}->get("/nodes/$n/lxc");
                if ($cts && ref($cts) eq 'ARRAY') {
                    foreach my $ct (@$cts) {
                        my $ct_data = $self->fetch_single_vm_data($node, $ct, 'CT');
                        push @vm_data, $ct_data if $ct_data;
                    }
                }
                
                # Update UI periodically to prevent freezing
                $self->{root}->update() if scalar(@vm_data) % 3 == 0;
            }
        };
        
        if ($@) {
            $error = $@;
            main::log_message('ERROR', "Data fetch failed: $error");
            main::log_message('ERROR', "DEBUG: vm_data array has " . scalar(@vm_data) . " items before error handling");
        } else {
            main::log_message('ERROR', "DEBUG: Data fetch completed successfully, vm_data array has " . scalar(@vm_data) . " items");
        }
        
        $self->{is_loading} = 0;
        
        if ($error) {
            $self->{status_label}->configure(-text => "Error: $error");
            $self->{connection_label}->configure(-text => "Error", -foreground => '#e74c3c');
            $self->update_led_color($self->{connection_led}, '#e74c3c');
        } else {
            $self->{vm_data} = \@vm_data;
            $self->filter_vms();
            
            my $now = main::strftime("%H:%M:%S", localtime);
            if ($self->{auto_refresh}) {
                my $refresh_rate = $self->{refresh_rate};
                $self->{last_update_label}->configure(-text => "LIVE - Updated: $now (every ${refresh_rate}s)");
            } else {
                $self->{last_update_label}->configure(-text => "Updated: $now (paused)");
            }
            
            $self->{connection_label}->configure(-text => "Connected", -foreground => '#27ae60');
            $self->update_led_color($self->{connection_led}, '#27ae60');
            
            # Update temperatures in background
            $self->{root}->after(100, sub { $self->update_node_temperatures(); });
        }
    });
}

sub get_selected_vm {
    my ($self) = @_;
    
    my @selection = $self->{tree}->info('selection');
    
    unless (@selection) {
        $self->{root}->messageBox(
            -title => "Warning",
            -message => "Please select a VM/CT",
            -type => 'OK',
            -icon => 'warning',
        );
        return undef;
    }
    
    my $vmid = $selection[0];
    
    foreach my $vm (@{$self->{vm_data}}) {
        if ($vm->{id} eq $vmid) {
            return $vm;
        }
    }
    
    return undef;
}

sub start_selected {
    my ($self) = @_;
    
    my $vm = $self->get_selected_vm();
    return unless $vm;
    
    $self->{status_label}->configure(-text => "Starting $vm->{type} $vm->{id}...");
    $self->{root}->update();
    
    $self->{root}->after(50, sub {
        eval {
            my $endpoint = $vm->{type} eq 'VM' ? 'qemu' : 'lxc';
            $self->{api}->post("/nodes/$vm->{node}/$endpoint/$vm->{id}/status/start");
            AuditLogger::log_vm_action("START", $vm->{id}, $vm->{type}, $vm->{name}, 1);
            $self->{status_label}->configure(-text => "Started $vm->{type} $vm->{id} ($vm->{name})");
            $self->{root}->after(2000, sub { $self->refresh_data_async() });
        };
        
        if ($@) {
            AuditLogger::log_vm_action("START", $vm->{id}, $vm->{type}, $vm->{name}, 0, $@);
            $self->{root}->messageBox(
                -title => "Error",
                -message => "Failed to start:\n$@",
                -type => 'OK',
                -icon => 'error',
            );
        }
    });
}

sub stop_selected {
    my ($self) = @_;
    
    my $vm = $self->get_selected_vm();
    return unless $vm;
    
    my $response = $self->{root}->messageBox(
        -title => "Confirm",
        -message => "Stop $vm->{type} $vm->{id} ($vm->{name})?",
        -type => 'YesNo',
        -icon => 'question',
    );
    
    return unless $response eq 'Yes';
    
    $self->{status_label}->configure(-text => "Stopping $vm->{type} $vm->{id}...");
    $self->{root}->update();
    
    $self->{root}->after(50, sub {
        eval {
            my $endpoint = $vm->{type} eq 'VM' ? 'qemu' : 'lxc';
            $self->{api}->post("/nodes/$vm->{node}/$endpoint/$vm->{id}/status/stop");
            AuditLogger::log_vm_action("STOP", $vm->{id}, $vm->{type}, $vm->{name}, 1);
            $self->{status_label}->configure(-text => "Stopped $vm->{type} $vm->{id} ($vm->{name})");
            $self->{root}->after(2000, sub { $self->refresh_data_async() });
        };
        
        if ($@) {
            AuditLogger::log_vm_action("STOP", $vm->{id}, $vm->{type}, $vm->{name}, 0, $@);
            $self->{root}->messageBox(
                -title => "Error",
                -message => "Failed to stop:\n$@",
                -type => 'OK',
                -icon => 'error',
            );
        }
    });
}

sub change_credentials {
    my ($self) = @_;
    
    my $response = $self->{root}->messageBox(
        -title => "Change Credentials",
        -message => "This will delete your current credentials and guide you through setting up new ones.\n\nContinue?",
        -type => 'YesNo',
        -icon => 'warning',
    );
    
    return unless $response eq 'Yes';
    
    # Stop auto-refresh
    $self->{auto_refresh} = 0;
    
    # Delete old credentials
    eval {
        if (-e $main::CREDENTIALS_FILE) {
            unlink $main::CREDENTIALS_FILE;
        }
    };
    
    if ($@ && $@ =~ /_TK_EXIT_/) {
        # Tk window exit during deletion dialog - check if deletion succeeded
        if (! -e $main::CREDENTIALS_FILE) {
            $@ = undef;  # Clear the error
        }
    }
    
    if ($@) {
        main::log_message('ERROR', "Failed to delete credentials file: $@");
        $self->{root}->messageBox(
            -title => "Error",
            -message => "Failed to delete credentials:\n$@",
            -type => 'OK',
            -icon => 'error',
        );
        $self->{auto_refresh} = 1;
        return;
    }
    
    # Close API
    $self->{api} = undef;
    $self->{connection_healthy} = 0;
    $self->{status_label}->configure(-text => "Not connected - setting up new credentials");
    $self->{connection_label}->configure(
        -text => "Disconnected",
        -foreground => '#e74c3c',
    );
    $self->update_led_color($self->{connection_led}, '#e74c3c');
    
    # Clear temperature data
    $self->{node_temp_api_available} = {};
    $self->{node_addresses} = {};
    $self->{node_temps_full_data} = {};
    
    # Show setup
    $self->{root}->messageBox(
        -title => "Setup New Credentials",
        -message => "You'll need to create a new API token in Proxmox.\n\nThe next screen will show you how.",
        -type => 'OK',
        -icon => 'info',
    );
    
    my $guide = TokenCreationGuide->new($self->{root});
    $guide->wait_window();
    
    my $dialog = CredentialsDialog->new($self->{root}, 1);
    $dialog->wait_window();
    
    if ($dialog->{result}) {
        my $result = $dialog->{result};
        
        eval {
            $self->{api} = ProxmoxAPI->new(
                $result->{host},
                $result->{token_id},
                $result->{token_secret},
            );
            
            CredentialManager::save_credentials(
                $result->{host},
                $result->{master},
                $result->{token_id},
                $result->{token_secret},
            );
            
            unless (-e $main::CREDENTIALS_FILE) {
                die "Credentials file was not created";
            }
            
            $self->{root}->messageBox(
                -title => "Success",
                -message => "New credentials saved successfully!\n\nThe dashboard will now refresh.",
                -type => 'OK',
                -icon => 'info',
            );
            
            $self->{status_label}->configure(-text => "Connected to $result->{host}");
            $self->{ssl_label}->configure(-text => "SSL: " . $self->{api}->{ssl_status});
            $self->{connection_healthy} = 1;
            
            # Re-enable auto-refresh
            $self->{auto_refresh} = 1;
            
            # Re-check temperature API
            $self->{root}->after(1000, sub { $self->check_temperature_api_status() });
            
            # Refresh
            $self->refresh_data_async();
        };
        
        if ($@ && $@ =~ /_TK_EXIT_/) {
            # Tk window exit - ignore this, check if we succeeded
            if ($self->{api} && $self->{connection_healthy}) {
                return;
            }
        }
        
        if ($@) {
            main::log_message('ERROR', "Credential change failed: $@");
            $self->{root}->messageBox(
                -title => "Error",
                -message => "Failed to set up new credentials:\n\n$@\n\nPlease restart the dashboard and try again.",
                -type => 'OK',
                -icon => 'error',
            );
            $self->{connection_healthy} = 0;
            $self->{root}->destroy();
        }
    } else {
        $self->{root}->messageBox(
            -title => "Cancelled",
            -message => "Credential change cancelled.\n\nYour old credentials were already deleted.\nYou'll need to restart the dashboard and set up credentials to continue.",
            -type => 'OK',
            -icon => 'warning',
        );
        $self->{root}->destroy();
    }
}

sub start_all_stopped {
    my ($self) = @_;
    
    my @stopped = grep { $_->{status} ne 'running' } @{$self->{vm_data}};
    
    unless (@stopped) {
        $self->{root}->messageBox(
            -title => "Info",
            -message => "All VMs/CTs are already running",
            -type => 'OK',
            -icon => 'info',
        );
        return;
    }
    
    my $response = $self->{root}->messageBox(
        -title => "Confirm",
        -message => "Start " . scalar(@stopped) . " stopped VMs/CTs?",
        -type => 'YesNo',
        -icon => 'question',
    );
    
    return unless $response eq 'Yes';
    
    my $count = scalar(@stopped);
    $self->{status_label}->configure(-text => "Starting $count VMs/CTs...");
    $self->{root}->update();
    
    $self->{root}->after(50, sub {
        my $success_count = 0;
        
        foreach my $vm (@stopped) {
            eval {
                my $endpoint = $vm->{type} eq 'VM' ? 'qemu' : 'lxc';
                $self->{api}->post("/nodes/$vm->{node}/$endpoint/$vm->{id}/status/start");
                AuditLogger::log_vm_action("START_ALL", $vm->{id}, $vm->{type}, $vm->{name}, 1);
                $success_count++;
            };
            
            if ($@) {
                AuditLogger::log_vm_action("START_ALL", $vm->{id}, $vm->{type}, $vm->{name}, 0, $@);
            }
        }
        
        $self->{status_label}->configure(-text => "Started $success_count/$count VMs/CTs");
        $self->{root}->after(3000, sub { $self->refresh_data_async() });
    });
}

sub toggle_auto_refresh {
    my ($self) = @_;
    
    $self->{auto_refresh} = !$self->{auto_refresh};
    
    if ($self->{auto_refresh}) {
        $self->{pause_resume_btn}->configure(
            -text => "Pause Live",
            -background => '#e67e22',
        );
        $self->{live_indicator}->configure(
            -text => "LIVE",
            -foreground => '#27ae60',
        );
        $self->update_led_color($self->{live_led}, '#27ae60');
        $self->{status_label}->configure(-text => "Live feed enabled");
    } else {
        $self->{pause_resume_btn}->configure(
            -text => "Resume Live",
            -background => '#27ae60',
        );
        $self->{live_indicator}->configure(
            -text => "PAUSED",
            -foreground => '#95a5a6',
        );
        $self->update_led_color($self->{live_led}, '#95a5a6');
        $self->{status_label}->configure(-text => "Live feed paused");
    }
}

sub update_refresh_rate {
    my ($self) = @_;
    
    my $new_rate = $self->{refresh_rate};
    $self->{status_label}->configure(-text => "Update interval set to ${new_rate}s");
}

sub start_auto_refresh {
    my ($self) = @_;
    
    $self->refresh_data_async();
    
    # Use Tk's repeat for auto-refresh
    $self->{root}->repeat($self->{refresh_rate} * 1000, sub {
        if ($self->{auto_refresh}) {
            $self->refresh_data_async();
        }
    });
    
}

sub on_closing {
    my ($self) = @_;
    
    $self->{auto_refresh} = 0;
    $self->{root}->destroy();
}

################################################################################
# Main Entry Point
################################################################################
package main;

sub main {
    eval {
        log_message('INFO', "========================================");
        log_message('INFO', "Starting Proxmox Dashboard");
        log_message('INFO', "========================================");
        
        log_message('DEBUG', "Creating main window...");
        my $mw = MainWindow->new();
        log_message('DEBUG', "Main window created");
        
        log_message('DEBUG', "Creating ProxmoxDashboard object...");
        my $app = ProxmoxDashboard->new($mw);
        
        if ($app) {
            log_message('INFO', "Dashboard initialized successfully");
            log_message('INFO', "Entering Tk MainLoop...");
            MainLoop();
            log_message('INFO', "MainLoop exited normally");
        } else {
            # This is expected when user cancels credential setup or authentication fails
            log_message('INFO', "Dashboard initialization cancelled or failed - exiting cleanly");
            log_message('INFO', "========================================");
            exit 0;
        }
    };
    
    # Handle Tk exit - this is normal when the main window closes
    if ($@ && $@ =~ /_TK_EXIT_/) {
        log_message('INFO', "Application closed normally (Tk exit)");
        log_message('INFO', "========================================");
        exit 0;
    }
    
    if ($@) {
        log_message('CRITICAL', "FATAL ERROR in main(): $@");
        print STDERR "\n\n";
        print STDERR "========================================\n";
        print STDERR "FATAL ERROR\n";
        print STDERR "========================================\n";
        print STDERR "$@\n";
        print STDERR "\nCheck the log file for details: $LOG_FILE\n";
        print STDERR "========================================\n\n";
        exit 1;
    }
}

main() unless caller;
